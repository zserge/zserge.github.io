<!doctype html><html lang=en><head><meta charset=utf-8><title>The old way to the modern web services</title><meta name=description content="Using Go to build webservices in a boring, predictable, yet productive way."><meta name=author content="Serge Zaitsev"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=data:,><link rel="shortcut icon" sizes=32x32 href=/favicon.png><link rel="shortcut icon" sizes=192x192 href=/favicon-192x192.png><link rel=apple-touch-icon href=/favicon-192x192.png><link rel=alternate type=application/rss+xml title=RSS href=/rss.xml><link rel=canonical href=https://zserge.com/posts/go-web-services/><meta property="og:title" content="The old way to the modern web services"><meta property="og:type" content="article"><meta property="og:url" content="https://zserge.com/posts/go-web-services/"><meta property="og:image" content="https://zserge.com/logo.png"><meta property="og:description" content="Using Go to build webservices in a boring, predictable, yet productive way."><meta property="og:locale" content="en_US"><meta name=twitter:card content="Using Go to build webservices in a boring, predictable, yet productive way."><meta name=twitter:site content="@zsergo"><style type=text/css>body{padding:1rem;margin:auto;max-width:46rem;font-family:pt serif,Georgia,Cambria,times new roman,Times,serif;line-height:1.5;font-size:20px;color:rgba(0,0,0,.87);-webkit-font-smoothing:antialiased;font-weight:300}nav{display:flex;justify-content:space-between;align-items:center;margin:1em 0 3em}nav ul,nav li{display:inline-block;list-style:none;margin:0 0 0 .5rem;padding:0}nav ul{margin-right:1rem}.logo{background-color:rgba(0,0,0,.87);color:#fff;min-width:48px;min-height:48px;font-size:28px;border-radius:2px;display:flex;justify-content:center;align-items:center}.logo:hover{color:#fff}h1,h2{line-height:1.2;font-family:roboto,system-ui,segoe ui,Helvetica,Arial,sans-serif;font-weight:400;text-transform:uppercase;margin:1.34em 0 0}h1{font-size:1.95em}h2{font-size:1.25em;border-bottom:2px solid rgba(0,0,0,.87)}h1 a{color:rgba(0,0,0,.87)}p{margin:.67em 0 1em}a{color:#0076df;text-decoration:none;word-break:break-word}a:hover{color:rgba(0,0,0,.87)}ul,ol{list-style-position:outside;margin-left:1em}img{display:block;margin-left:auto;margin-right:auto;max-width:100%}pre,code{font-family:roboto mono,SFMono-Regular,Consolas,liberation mono,Menlo,monospace;font-weight:400;font-size:18px;color:rgba(0,0,0,.6);background:#eee}code{padding:.2rem .4rem;font-size:14px;border-radius:2px}pre{overflow-y:auto;line-height:20px;border-radius:2px;padding:1em}pre code{font-size:14px;padding:0;color:rgba(0,0,0,.87)}footer{font-size:12px}@media(prefers-color-scheme:dark){.logo{color:#444;background-color:#e4e4e4}.logo:hover{color:#444}body,h1 a,h2 a{background-color:#444;color:#e4e4e4}pre,pre code{background:#333;color:#e4e4e4}h2{border-bottom:1px solid #e4e4e4}code{color:#aaa;background:#333}a{color:#e39777}a:hover{color:#e4e4e4}img{filter:grayscale(30%)}}.hl{display:block;width:100%;background-color:#ffc}.ow,.gh,.gp,.gs,.gu,.nt,.nn,.ne,.ni,.nc,.kr,.kn,.kd,.kc,.k{font-weight:700}.c,.ch,.cm,.c1,.cs,.ge{color:#777}</style><link rel="shortcut icon" href=/favicon.ico></head><body><header><nav><a class=logo href=/>Z</a><ul><li><a href=/about/>about</a></li><li><a href=/posts/>posts</a></li><li><a href=https://twitter.com/zsergo>@me</a></li><li><a href=https://github.com/zserge>&lt;/>me</a></li></ul></nav></header><div id=content><h1>The old way to the modern web services</h1><p>Yes, modern web development is complex. Frameworks change each other, cognitive load increases, hype-driven development introduces new risks that lead to &ldquo;the Big Rewrite&rdquo;, which at the end rarely goes well. But does it have to be this way?</p><p>Looking back, we may notice that the websites written in plain HTML+CSS still open and work perfectly. Boring technologies survive. Similarly, web services built with a dull tech stack are surprisingly robust.</p><p>Here&rsquo;s my approach to keeping things simple and boring, while absorbing the advantages of modern tooling where possible.</p><h2 id=go>Go</h2><p>Go is a nice language. Pragmatic, fast, stable, easy to use. My web services written in Go five years ago still work without any changes. Yes, a language that is <em>only</em> 11 years old can hardly be known as &ldquo;old&rdquo;, but it feels very dull, readable, obvious, and productive in many use cases, especially backend development.</p><p>Here I will be talking about Go 1.16, which is about to become the newest release (at the moment of writing these lines). It is compatible, as always, with all the past versions, but also introduces the native asset embedding, pluggable file systems, and many other cool features, that will be covered a bit later.</p><h2 id=web-frameworks>Web Frameworks</h2><p>First of all, you might not need micro-services - starting with a monolith would probably lead you to a working product much sooner. But even with monoliths you still have to lay the ground for your work and choose a web framework.</p><p>There is nothing wrong with using <a href=https://github.com/labstack/echo>labstack/echo</a>, <a href=https://github.com/gin-gonic/gin>gin-gonic</a> or similar frameworks. I used both in the past, and they had proven themselves to be very stable, powerful and, pleasant. But if you aim for ultimate minimalism - you can go with just a standard library. I tend to drop a single <code>web.go</code> file that implements a &ldquo;good-enough&rdquo; framework that I can extend to my needs:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Middleware wraps given http.Handler adding some extra functionality
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Middleware</span> <span class=kd>func</span><span class=p>(</span><span class=nx>next</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span>

<span class=c1>// Logger middleware logs every incoming request
</span><span class=c1></span><span class=kd>func</span> <span class=nf>Logger</span><span class=p>()</span> <span class=nx>Middleware</span> <span class=p>{</span>
	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>next</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>http</span><span class=p>.</span><span class=nf>HandlerFunc</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
			<span class=nx>start</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
			<span class=nx>next</span><span class=p>.</span><span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
			<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s %s -- %v&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>Method</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>URL</span><span class=p>.</span><span class=nx>Path</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Since</span><span class=p>(</span><span class=nx>start</span><span class=p>))</span>
		<span class=p>})</span>
	<span class=p>}</span>
<span class=p>}</span>

<span class=c1>// Recovery middleware handles panics inside handlers
</span><span class=c1></span><span class=kd>func</span> <span class=nf>Recovery</span><span class=p>()</span> <span class=nx>Middleware</span> <span class=p>{</span>
	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>next</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>http</span><span class=p>.</span><span class=nf>HandlerFunc</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
				<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nb>recover</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
					<span class=nx>w</span><span class=p>.</span><span class=nf>WriteHeader</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nx>StatusInternalServerError</span><span class=p>)</span>
					<span class=nx>debug</span><span class=p>.</span><span class=nf>PrintStack</span><span class=p>()</span>
				<span class=p>}</span>
			<span class=p>}()</span>
			<span class=nx>next</span><span class=p>.</span><span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
		<span class=p>})</span>
	<span class=p>}</span>
<span class=p>}</span>

<span class=c1>// Hook middleware runs a function on each request, can be used to reload templates, build frontend etc
</span><span class=c1></span><span class=kd>func</span> <span class=nf>Hook</span><span class=p>(</span><span class=nx>f</span> <span class=kd>func</span><span class=p>())</span> <span class=nx>Middleware</span> <span class=p>{</span>
	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>next</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>http</span><span class=p>.</span><span class=nf>HandlerFunc</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
			<span class=nf>f</span><span class=p>()</span>
			<span class=nx>next</span><span class=p>.</span><span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
		<span class=p>})</span>
	<span class=p>}</span>
<span class=p>}</span>

<span class=c1>// Use applies multiple middleware to the given handler
</span><span class=c1></span><span class=kd>func</span> <span class=nf>Use</span><span class=p>(</span><span class=nx>h</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>,</span> <span class=nx>mw</span> <span class=o>...</span><span class=nx>Middleware</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span> <span class=p>{</span>
	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>mw</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span> <span class=p>{</span>
		<span class=nx>h</span> <span class=p>=</span> <span class=nx>mw</span><span class=p>[</span><span class=nx>i</span><span class=p>](</span><span class=nx>h</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>h</span>
<span class=p>}</span>
</code></pre></div><p>If you look in the sources of Gin or Echo, you will find very similar middleware, just with more configurable options. Depending on the service you are building, you might achieve better results with your own middleware.</p><p>But of course, if your web service becomes too large and complex - switching to a real battle-tested framework could bring some benefits, but you don&rsquo;t have to use one only because everybody else does.</p><h2 id=static-assets>Static assets</h2><p>If you ever used Go in the past - you would know that dealing with static assets is a pain. Go build system does not cover it, so you have written custom build scripts that either recompiled your binary every time you changed a line of CSS, or created a set of interfaces to switch between reading files from disk (&ldquo;dev&rdquo; mode) vs using embedded assets.</p><p>With Go 1.16 you have this functionality in the standard library:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=c1>//go:embed assets
</span><span class=c1></span><span class=kd>var</span> <span class=nx>assets</span> <span class=nx>embed</span><span class=p>.</span><span class=nx>FS</span>
<span class=o>...</span>
<span class=nx>mux</span><span class=p>.</span><span class=nf>Handle</span><span class=p>(</span><span class=s>&#34;/assets/&#34;</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nf>FileServer</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nf>FS</span><span class=p>(</span><span class=nx>assets</span><span class=p>)))</span>
</code></pre></div><p>This includes all files from the <code>./assets/</code> directory as the <code>assets</code> file system in your code. Custom file systems can be used for static file handlers, templates, and every other part of the stdlib. Embedding such assets is actually very fast so you can rebuild your binary on every file change. You may use existing wrappers, like <code>gow</code>, or create your own one if you use custom a build script anyway:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash><span class=nb>trap</span> <span class=s1>&#39;exit&#39;</span> INT TERM <span class=p>;</span> <span class=nb>trap</span> <span class=s1>&#39;kill 0&#39;</span> EXIT
<span class=k>while</span> inotifywait -rqe modify . <span class=p>;</span> <span class=k>do</span>
	go1.16beta1 build -o example <span class=o>||</span> <span class=k>continue</span>
	<span class=nb>kill</span> <span class=nv>$PID</span>
	./example <span class=p>&amp;</span>
	<span class=nv>PID</span><span class=o>=</span><span class=nv>$!</span>
	<span class=nv>w</span><span class=o>=</span><span class=k>$(</span>xdotool getwindowfocus<span class=k>)</span>
	xdotool search --onlyvisible --class <span class=s2>&#34;Chromium&#34;</span> windowfocus key <span class=s1>&#39;F5&#39;</span>
	xdotool windowactivate <span class=nv>$w</span>
<span class=k>done</span>
</code></pre></div><p>The main loop waits for changes, rebuild the binary, kills the old one, and restarts the web service. It also uses <code>xdotool</code> to find your browser and reload the page. On macOS there is <code>xdotool</code>, but you may use the following snippet instead:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>osascript -e &#39;tell application &#34;Google Chrome&#34;
	reload active tab of window 1
end tell&#39;
</code></pre></div><p>Again, find the right tool for the job, you might use existing solutions or you might want to reload the page manually to keep things simple.</p><h2 id=frontend>Frontend</h2><p>As we speak about browsers, we should probably talk about the frontend. Single-page applications are cool, but often not needed. Similarly, you might really need server-side rendering, as most search engines handle javascript just fine.</p><p>What I found to be a good compromise - is to use Go templates to fill the HTML page with some JSON data and use JavaScript to render it. In this case, the page loads almost immediately, but you may still use a frontend framework of your choice and split your app into components with proper tests and so on.</p><p>My current frontend stack is neither fancy nor large. I use <a href=https://preactjs.com/>Preact</a>, because I&rsquo;m used to React philosophy and I like small libraries. I tried both, Preact+JSX and <a href=https://github.com/developit/htm>htm</a> bundle. The latter allows you to skip the compilation step and use JavaScript just as you write it.</p><p>If you need a compilation step - the recent marvel I discovered is <a href>esbuild</a>, which truly is the fastest bundler for the frontend. In fact, it is written in Go, so you may use it as a library and let your service compile/minify the assets on start. Since esbuild itself is blazing fast, and embedding is barely noticeable - you can afford to do both on every file change.</p><p>Isn&rsquo;t it actually sweet when developer tools are made with performance in mind?</p><h2 id=deploy>Deploy</h2><p>Finally, your webservice is running locally and you want to expose it to the world. I see two major options if you use Go - deploy a Docker image, or deploy it as a good old system service.</p><p>For Docker there&rsquo;s not much to be said, just put your binary into the Alpine image (or even a &ldquo;scratch&rdquo; one if that works for you). Docker option is preferred when your service needs other dependencies like PostgreSQL or Redis - in this case, you may use <code>docker-compose</code> or something similar.</p><p>The system service option is good for smaller self-contained services. In this case, create a typical <code>myservice.service</code> for systemd to recognize your service, and use commands like <code>service myservice stop</code> / <code>service myservice start</code> to control it and <code>journalctl -u myservice -f</code> to watch the logs. This is probably as basic as you can get, deploy and backup with <code>rsync</code>, control with shell scripts, and rely on the OS instead of &ldquo;yet-another-modern-Go-tool&rdquo; in between.</p><h2 id=summing-up>Summing up</h2><p>With all this in mind you can jump from an idea to a working service in a couple of days, and most of the time you would spend actually writing your business logic instead of messing up with the new hot framework or k8s.</p><p>Of course, your service could be very unique and might deserve a proper architecture and infrastructure from the very beginning, but I personally find this world complex enough to make <em>every</em> web service complicated.</p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href=https://github.com/zserge>Github</a>, <a href=https://twitter.com/zsergo>Twitter</a> or subscribe via <a href=/rss.xml>rss</a>.</p><p class=date style=text-align:right><em>Jan 20, 2021</em></p><p>See also:
<a href=/posts/containers/>Linux containers in a few lines of code</a> and <a href=/posts/>more</a>.</p></div><footer><p>&copy;2012&ndash;2021 &#183;
<a href=https://zserge.com>Serge Zaitsev</a> &#183;
<a href=mailto:hello@zserge.com>hello@zserge.com</a></p></footer><script>(function(e,t,n,i,s,a,c){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)};a=t.createElement(i);c=t.getElementsByTagName(i)[0];a.async=true;a.src=s;c.parentNode.insertBefore(a,c)})(window,document,"galite","script","https://cdn.jsdelivr.net/npm/ga-lite@2/dist/ga-lite.min.js");galite('create','UA-33644825-1','auto');galite('send','pageview');</script><script>new Image().src='https://nullitics.com/file.gif?r='+encodeURI(document.referrer)+'&d='+screen.width</script><noscript><img src=https://nullitics.com/file.gif></noscript></body></html>