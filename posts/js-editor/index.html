<!doctype html><html lang=en><head><meta charset=utf-8><title>Minimal code editor in JavaScript</title><meta name=description content="How to write a small extensible code editor in pure javascript, with syntax highlighting and a few other nice features in 1KB. Absolutely no dependencies, a bit of contenteditable magic, with a strong focus on keeping it small and simple."><meta name=author content="Serge Zaitsev"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel="shortcut icon" type=image/png href=/favicon.png><link rel=alternate type=application/rss+xml title=RSS href=/rss.xml><link rel=canonical href=https://zserge.com/posts/js-editor/><meta property="og:title" content="Minimal code editor in JavaScript"><meta property="og:type" content="article"><meta property="og:url" content="https://zserge.com/posts/js-editor/"><meta property="og:image" content="https://zserge.com/logo.png"><meta property="og:description" content="How to write a small extensible code editor in pure javascript, with syntax highlighting and a few other nice features in 1KB. Absolutely no dependencies, a bit of contenteditable magic, with a strong focus on keeping it small and simple."><meta property="og:locale" content="en_US"><meta name=twitter:card content="How to write a small extensible code editor in pure javascript, with syntax highlighting and a few other nice features in 1KB. Absolutely no dependencies, a bit of contenteditable magic, with a strong focus on keeping it small and simple."><meta name=twitter:site content="@zsergo"><link href=/styles.css rel=stylesheet type=text/css><link rel="shortcut icon" href=/favicon.ico></head><body><header><nav><a class=logo href=/>Z</a></nav><div class=empty></div><nav><section><a href=/about/>about</a>
<a href=/posts/>posts</a></section><section><a href=https://twitter.com/zsergo>@me</a>
<a href=https://github.com/zserge>&lt;/>me</a></section></nav></header><div id=content><h1>Minimal code editor in JavaScript</h1><p>How would one write a code editor in JavaScript? A long time ago one would take a regular textarea to handle user input and would create another div that would do syntax highlighting etc. However, this approach quickly becomes unusable when someone opens it on mobile. That&rsquo;s why CodeMirror has been rewritten to use contenteditable and many other editors followed this approach.</p><h2 id=contenteditable>contenteditable</h2><p>Contenteditable, as the name suggests, allows users to edit the contents of the element using the browser-native techniques - all shortcuts for text selection and navigation work as expected, so does the clipboard and other minor editing features.</p><p>Let&rsquo;s try making a tiny code editor using a single contenteditable div and a bit of JavaScript.</p><p>We start with a minimal markup in a single HTML file. The only element we would need is a div:</p><div class=highlight><pre class=chroma><code class=language-html data-lang=html><span class=p>&lt;</span><span class=nt>div</span> <span class=na>class</span><span class=o>=</span><span class=s>&#34;editor&#34;</span> <span class=na>contenteditable</span><span class=o>=</span><span class=s>&#34;true&#34;</span> <span class=na>spellcheck</span><span class=o>=</span><span class=s>&#34;false&#34;</span><span class=p>&gt;</span>
  <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span>function example() {<span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
  <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span>  return 42;<span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
  <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span>}<span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
<span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
</code></pre></div><p>At this point, our editor behaves much like textarea - one can type, select or edit text.</p><p>Let&rsquo;s drop in some rudimentary syntax highlighting. It can be a function that takes a DOM element, iterates over all its children (in our case - lines) and wraps the keywords or other meaningful tokens into additional markup that would help styling and highlighting it with CSS:</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=kr>const</span> <span class=nx>js</span> <span class=o>=</span> <span class=nx>el</span> <span class=p>=&gt;</span> <span class=p>{</span>
  <span class=k>for</span> <span class=p>(</span><span class=kr>const</span> <span class=nx>node</span> <span class=k>of</span> <span class=nx>el</span><span class=p>.</span><span class=nx>children</span><span class=p>)</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>s</span> <span class=o>=</span> <span class=nx>node</span><span class=p>.</span><span class=nx>innerText</span>
      <span class=p>.</span><span class=nx>replace</span><span class=p>(</span><span class=sr>/(\/\/.*)/g</span><span class=p>,</span> <span class=s1>&#39;&lt;em&gt;$1&lt;/em&gt;&#39;</span><span class=p>)</span>
      <span class=p>.</span><span class=nx>replace</span><span class=p>(</span>
        <span class=sr>/\b(new|if|else|do|while|switch|for|in|of|continue|break|return|typeof|function|var|const|let|\.length|\.\w+)(?=[^\w])/g</span><span class=p>,</span>
        <span class=s1>&#39;&lt;strong&gt;$1&lt;/strong&gt;&#39;</span><span class=p>,</span>
      <span class=p>)</span>
      <span class=p>.</span><span class=nx>replace</span><span class=p>(</span><span class=sr>/(&#34;.*?&#34;|&#39;.*?&#39;|`.*?`)/g</span><span class=p>,</span> <span class=s1>&#39;&lt;strong&gt;&lt;em&gt;$1&lt;/em&gt;&lt;/strong&gt;&#39;</span><span class=p>)</span>
      <span class=p>.</span><span class=nx>replace</span><span class=p>(</span><span class=sr>/\b(\d+)/g</span><span class=p>,</span> <span class=s1>&#39;&lt;em&gt;&lt;strong&gt;$1&lt;/strong&gt;&lt;/em&gt;&#39;</span><span class=p>);</span>
    <span class=nx>node</span><span class=p>.</span><span class=nx>innerHTML</span> <span class=o>=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>split</span><span class=p>(</span><span class=s1>&#39;\n&#39;</span><span class=p>).</span><span class=nx>join</span><span class=p>(</span><span class=s1>&#39;&lt;br/&gt;&#39;</span><span class=p>);</span>
  <span class=p>}</span>
<span class=p>};</span>
</code></pre></div><p>If we now apply the function to our editor - we would see that the code inside looks not so boring anymore, numbers and keywords look bolder and stand out, while comments and strings look italic.</p><h2 id=handling-cursor>handling cursor</h2><p>However, as soon as we start editing the text - the highlighting remains static, so we need to re-apply our function every time the contents of the editor change. Now, if you start listening to the key presses and call the <code>js(el)</code> function on each of them - you will see the cursor behaves weirdly. It jumps to the start position every time. Thus, we need to save cursor position before applying the highlighter and restore it later.</p><p>To get caret position one may use the following function:</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=kr>const</span> <span class=nx>caret</span> <span class=o>=</span> <span class=nx>el</span> <span class=p>=&gt;</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>range</span> <span class=o>=</span> <span class=nb>window</span><span class=p>.</span><span class=nx>getSelection</span><span class=p>().</span><span class=nx>getRangeAt</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
  <span class=kr>const</span> <span class=nx>prefix</span> <span class=o>=</span> <span class=nx>range</span><span class=p>.</span><span class=nx>cloneRange</span><span class=p>();</span>
  <span class=nx>prefix</span><span class=p>.</span><span class=nx>selectNodeContents</span><span class=p>(</span><span class=nx>el</span><span class=p>);</span>
  <span class=nx>prefix</span><span class=p>.</span><span class=nx>setEnd</span><span class=p>(</span><span class=nx>range</span><span class=p>.</span><span class=nx>endContainer</span><span class=p>,</span> <span class=nx>range</span><span class=p>.</span><span class=nx>endOffset</span><span class=p>);</span>
  <span class=k>return</span> <span class=nx>prefix</span><span class=p>.</span><span class=nx>toString</span><span class=p>().</span><span class=nx>length</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div><p>It basically takes the current selection from the editor (a cursor is a zero-width selection where start and end are at the same position), and returns the position of its end. To restore the caret we would have to do something more tricky, we need to recursively iterate the child nodes of the highlighted text inside the editor and find the one containing the caret, and restore the selection range there:</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=kr>const</span> <span class=nx>setCaret</span> <span class=o>=</span> <span class=p>(</span><span class=nx>pos</span><span class=p>,</span> <span class=nx>parent</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
  <span class=k>for</span> <span class=p>(</span><span class=kr>const</span> <span class=nx>node</span> <span class=k>of</span> <span class=nx>parent</span><span class=p>.</span><span class=nx>childNodes</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>nodeType</span> <span class=o>==</span> <span class=nx>Node</span><span class=p>.</span><span class=nx>TEXT_NODE</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>if</span> <span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>length</span> <span class=o>&gt;=</span> <span class=nx>pos</span><span class=p>)</span> <span class=p>{</span>
        <span class=kr>const</span> <span class=nx>range</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>createRange</span><span class=p>();</span>
        <span class=kr>const</span> <span class=nx>sel</span> <span class=o>=</span> <span class=nb>window</span><span class=p>.</span><span class=nx>getSelection</span><span class=p>();</span>
        <span class=nx>range</span><span class=p>.</span><span class=nx>setStart</span><span class=p>(</span><span class=nx>node</span><span class=p>,</span> <span class=nx>pos</span><span class=p>);</span>
        <span class=nx>range</span><span class=p>.</span><span class=nx>collapse</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span>
        <span class=nx>sel</span><span class=p>.</span><span class=nx>removeAllRanges</span><span class=p>();</span>
        <span class=nx>sel</span><span class=p>.</span><span class=nx>addRange</span><span class=p>(</span><span class=nx>range</span><span class=p>);</span>
        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
      <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=nx>pos</span> <span class=o>=</span> <span class=nx>pos</span> <span class=o>-</span> <span class=nx>node</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span>
      <span class=p>}</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=nx>pos</span> <span class=o>=</span> <span class=nx>setCaret</span><span class=p>(</span><span class=nx>pos</span><span class=p>,</span> <span class=nx>node</span><span class=p>);</span>
      <span class=k>if</span> <span class=p>(</span><span class=nx>pos</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>pos</span><span class=p>;</span>
      <span class=p>}</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=nx>pos</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div><p>Now we should be able to listen to key-up events and highlight contents of the editor without losing the caret position:</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=nx>el</span><span class=p>.</span><span class=nx>addEventListener</span><span class=p>(</span><span class=s1>&#39;keyup&#39;</span><span class=p>,</span> <span class=nx>e</span> <span class=p>=&gt;</span> <span class=p>{</span>
  <span class=k>if</span> <span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>keyCode</span> <span class=o>&gt;=</span> <span class=mh>0x30</span> <span class=o>||</span> <span class=nx>e</span><span class=p>.</span><span class=nx>keyCode</span> <span class=o>==</span> <span class=mh>0x20</span><span class=p>)</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>pos</span> <span class=o>=</span> <span class=nx>caret</span><span class=p>();</span>
    <span class=nx>highlight</span><span class=p>(</span><span class=nx>el</span><span class=p>);</span>
    <span class=nx>setCaret</span><span class=p>(</span><span class=nx>pos</span><span class=p>);</span>
  <span class=p>}</span>
<span class=p>});</span>
</code></pre></div><h2 id=line-numbers>line numbers</h2><p>A nice bonus here would be line numbers. Of course, one can render a column of small divs, each containing a line number aligned with a row in a contenteditable and manipulate them every time line count changes. But with CSS counters this can be achieved with almost no code:</p><div class=highlight><pre class=chroma><code class=language-css data-lang=css><span class=p>.</span><span class=nc>editor</span> <span class=p>{</span>
  <span class=err>...</span>
  <span class=k>counter-reset</span><span class=p>:</span> <span class=n>line</span><span class=p>;</span> <span class=c>/* reset the &#34;line&#34; counter */</span>
<span class=p>}</span>
<span class=p>.</span><span class=nc>editor</span> <span class=nt>div</span><span class=p>::</span><span class=nd>before</span> <span class=p>{</span>
  <span class=err>...</span>
  <span class=k>content</span><span class=p>:</span> <span class=nb>counter</span><span class=p>(</span><span class=n>line</span><span class=p>);</span>   <span class=c>/* insert a div with the value of the counter */</span>
  <span class=k>counter-increment</span><span class=p>:</span> <span class=n>line</span><span class=p>;</span>  <span class=c>/* increment the counter */</span>
  <span class=k>position</span><span class=p>:</span> <span class=kc>absolute</span><span class=p>;</span>
  <span class=k>right</span><span class=p>:</span> <span class=nb>calc</span><span class=p>(</span><span class=mi>100</span><span class=kt>%</span> <span class=o>+</span> <span class=mi>16</span><span class=kt>px</span><span class=p>);</span> <span class=c>/* add some space between this and the code line next to it */</span>
<span class=p>}</span>
</code></pre></div><p>Here&rsquo;s how it looks like, with no additional styling:</p><p><img src=/images/js-editor.png alt=js-editor></p><p>Not bad for a low-code solution?</p><h2 id=a-fly-in-the-ointment>a fly in the ointment</h2><p>Why did I have to filter out key presses to apply highlighting only after some printable character was typed? Unfortunately, Chrome seems to calculate cursor position when a newline is added or removed, also when someone moves caret with arrow keys or selects some text with hotkeys - calling <code>setCaret()</code> would rather prevent his intentions.</p><p>A possible alternative here would be to use a different type of contenteditable attribute, <code>contenteditable="plaintext-only"</code>. This is not standardized yet, however Chrome and WebKit browsers support it. This, however, would make it impossible to use CSS for line numbers, and one would have to re-implement it in JavaScript.</p><p>So, on the one hand, it seems to be possible to write a lightweight code editor in under 50 lines of vanilla JavaScript. But for a more featureful and production-ready code editor one should probably use battle-tested implementations, like CodeMirror or VSCode&rsquo;s Monaco.</p><p>If you are willing to experiment further with contenteditable approach and minimal code - the single-HTML gist is available <a href=https://gist.github.com/zserge/03280e5efebae83cc41c78dbd7e73608>here</a>, or here is the jsfiddle - <a href=https://jsfiddle.net/zserge/gkbjv47n/>https://jsfiddle.net/zserge/gkbjv47n/</a>.</p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href=https://github.com/zserge>Github</a>, <a href=https://twitter.com/zsergo>Twitter</a> or subscribe via <a href=/rss.xml>rss</a>.</p><p class=date style=text-align:right><em>Aug 24, 2020</em></p><p>See also:
<a href=/posts/rss/>RSS is dead</a>
and <a href=/posts/>more</a>.</p></div><footer><p>&copy;2012&ndash;2020 &#183;
<a href=https://zserge.com>Serge Zaitsev</a> &#183;
<a href=mailto:zaitsev.serge@gmail.com>zaitsev.serge@gmail.com</a></p></footer><script src=https://ajax.googleapis.com/ajax/libs/webfont/1.6.16/webfont.js></script><script>WebFontConfig={google:{families:['PT Serif','Roboto','Roboto Mono']}};(function(d){var wf=d.createElement('script'),s=d.scripts[0];wf.src='https://ajax.googleapis.com/ajax/libs/webfont/1.6.16/webfont.js';s.parentNode.insertBefore(wf,s);})(document);</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-33644825-1','zserge.com');ga('send','pageview');</script><script>new Image().src='https://nullitics.com/file.gif?r='+encodeURI(document.referrer)+'&d='+screen.width</script><noscript><img src=https://nullitics.com/file.gif></noscript></body></html>