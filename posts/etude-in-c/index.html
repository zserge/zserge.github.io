<!doctype html><html lang=en><head><meta charset=utf-8><title>Étude in C minor</title><meta name=description content="Making music with low-level C code, from a simple saw wave to playing melodies"><meta name=author content="Serge Zaitsev"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=data:,><link rel="shortcut icon" sizes=32x32 href=/favicon.png><link rel="shortcut icon" sizes=192x192 href=/favicon-192x192.png><link rel=apple-touch-icon href=/favicon-192x192.png><link rel=alternate type=application/rss+xml title=RSS href=/rss.xml><link rel=canonical href=https://zserge.com/posts/etude-in-c/><meta property="og:title" content="Étude in C minor"><meta property="og:type" content="article"><meta property="og:url" content="https://zserge.com/posts/etude-in-c/"><meta property="og:image" content="https://zserge.com/logo.png"><meta property="og:description" content="Making music with low-level C code, from a simple saw wave to playing melodies"><meta property="og:locale" content="en_US"><meta name=twitter:card content="Making music with low-level C code, from a simple saw wave to playing melodies"><meta name=twitter:site content="@zsergo"><style type=text/css>body{padding:1rem;margin:auto;max-width:46rem;font-family:pt serif,Georgia,Cambria,times new roman,Times,serif;line-height:1.5;font-size:20px;color:rgba(0,0,0,.87);-webkit-font-smoothing:antialiased;font-weight:300}nav{display:flex;justify-content:space-between;align-items:center;margin:1em 0 3em}nav ul,nav li{display:inline-block;list-style:none;margin:0}nav li{margin:0 .5rem}.logo{background-color:rgba(0,0,0,.87);color:#fff;min-width:48px;min-height:48px;font-size:28px;border-radius:2px;display:flex;justify-content:center;align-items:center}.logo:hover{color:#fff}h1,h2{line-height:1.2;font-family:roboto,system-ui,segoe ui,Helvetica,Arial,sans-serif;font-weight:400;text-transform:uppercase;margin:1.34em 0 0}h1{font-size:1.95em}h2{font-size:1.25em;border-bottom:2px solid rgba(0,0,0,.87)}h1 a{color:rgba(0,0,0,.87)}p{margin:.67em 0 1em}a{color:#0076df;text-decoration:none;word-break:break-word}a:hover{color:rgba(0,0,0,.87)}ul,ol{list-style-position:outside;margin-left:1em}img{display:block;margin-left:auto;margin-right:auto;max-width:100%}pre,code{font-family:roboto mono,SFMono-Regular,Consolas,liberation mono,Menlo,monospace;font-weight:400;font-size:18px;color:rgba(0,0,0,.6);background:#eee}pre{overflow-y:auto;line-height:20px;border-radius:2px;padding:1em}pre code{font-size:14px;color:rgba(0,0,0,.87)}footer{font-size:12px}@media(prefers-color-scheme:dark){.logo{color:#444;background-color:#e4e4e4}.logo:hover{color:#444}body,h1 a,h2 a{background-color:#444;color:#e4e4e4}pre,pre code{background:#333;color:#e4e4e4}h2{border-bottom:1px solid #e4e4e4}code{color:#aaa;background:#333}a{color:#e39777}a:hover{color:#e4e4e4}img{filter:grayscale(30%)}}.hl{display:block;width:100%;background-color:#ffc}.ow,.gh,.gp,.gs,.gu,.nt,.nn,.ne,.ni,.nc,.kr,.kn,.kd,.kc,.k{font-weight:700}.c,.ch,.cm,.c1,.cs,.ge{color:#777}</style><link rel="shortcut icon" href=/favicon.ico></head><body><header><nav><a class=logo href=/>Z</a><ul><li><a href=/about/>about</a></li><li><a href=/posts/>posts</a></li><li><a href=https://twitter.com/zsergo>@me</a></li><li><a href=https://github.com/zserge>&lt;/>me</a></li></ul></nav></header><div id=content><h1>Étude in C minor</h1><p>Let me start with a picture.</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c>        <span class=kt>int</span>
       <span class=nf>main</span><span class=p>()</span>
      <span class=p>{</span><span class=kt>float</span> <span class=n>f</span>
    <span class=p>;</span><span class=kt>char</span> <span class=n>c</span><span class=p>;</span><span class=kt>int</span>
  <span class=n>d</span><span class=p>,</span><span class=n>o</span><span class=p>;</span><span class=k>while</span><span class=p>(</span><span class=n>scanf</span><span class=p>(</span>
 <span class=s>&#34;%d%c%d &#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=n>d</span><span class=p>,</span><span class=o>&amp;</span><span class=n>c</span><span class=p>,</span><span class=o>&amp;</span><span class=n>o</span><span class=p>)</span>
<span class=o>&gt;</span><span class=mi>0</span><span class=p>){</span><span class=n>c</span><span class=o>&amp;=</span><span class=mi>31</span><span class=p>;</span><span class=k>for</span><span class=p>(</span><span class=n>f</span><span class=o>=!</span><span class=p>(</span><span class=n>c</span><span class=o>&gt;&gt;</span><span class=mi>4</span><span class=p>)</span><span class=o>*</span><span class=mi>55</span><span class=p>,</span><span class=n>c</span><span class=o>=</span><span class=p>(</span><span class=n>c</span><span class=o>*</span><span class=mi>8</span><span class=o>/</span><span class=mi>5</span><span class=o>+</span><span class=mi>8</span><span class=p>)</span><span class=o>%</span><span class=mi>12</span><span class=o>+</span><span class=n>o</span><span class=o>*</span>
                     <span class=mi>12</span><span class=o>-</span><span class=mi>24</span><span class=p>;</span><span class=n>c</span><span class=o>--</span><span class=p>;</span><span class=n>f</span><span class=o>*=</span><span class=mf>1.0595</span><span class=p>);</span>
                        <span class=k>for</span><span class=p>(</span><span class=n>d</span><span class=o>=</span><span class=mf>16e3</span><span class=o>/</span><span class=n>d</span><span class=p>;</span><span class=n>d</span><span class=o>--</span><span class=p>;</span>
                           <span class=n>putchar</span><span class=p>(</span><span class=n>d</span><span class=o>*</span><span class=n>f</span>
                            <span class=o>*</span><span class=mf>.032</span><span class=p>))</span>
                              <span class=p>;}}</span>
</code></pre></div><p>I don&rsquo;t really draw well, so I used formatted C code instead. That was supposed to be a triangular sound wave written in C. In fact, this very C code plays two-octave melodies written in text notation from stdin.</p><p>It&rsquo;s only 160 bytes, fits into a modern-day tweet, and the reason it&rsquo;s there is to show how simple it is to create minimal music with code in any programming language, not just the special languages like <a href=https://csound.com>CSound</a>, <a href=https://chuck.cs.princeton.edu/>ChucK</a>, or <a href=https://sonic-pi.net/>SonicPi</a>.</p><h2 id=playing-digital-sound>Playing digital sound</h2><p>Now let me actually draw something:</p><p><img src=/images/etude-in-c-digital-sound.png alt="digital sound"></p><p>This is sound - something that oscillates and moves the air in time, and the air reaches your ears and you hear it. The wave that goes up and down in the picture illustrates show the air vibrates. To describe this wave in digital terms people came up with an idea to measure the amplitude of the wave at fixed time intervals and use these sampled data points as &ldquo;digital sound&rdquo;.</p><p>Two questions arise - how often to sample the sound wave, and how to digitally represent the units of the amplitude range? To answer the first question we should recall that the human ear can not hear anything higher than 20000 Hz, that&rsquo;s why CD music had a sample rate of 22000 Hz. Modern sound cards however tend to use sampling rates twice as high - 44100 Hz or 48000 Hz or even 96000 Hz. Lo-fi audio devices like Arduino or NES simply could not produce sound at such a high speed, so they used a reasonably low sampling rate, like 8000 Hz, and this is what we will be using in this article.</p><p>The amplitude quantization is also a matter of compromise. In theory, people can recognize a very subtle change of the amplitude, but computers can&rsquo;t use infinitely precise numbers for each sample. Instead, they perform quantization - they map the amplitude value into a fixed-width number, like a float or an integer. In the picture above I&rsquo;ve used +1 and -1 as the minimum and maximum value of the amplitude, assuming the <code>float</code> data type, but other popular formats are signed <code>int16</code>, where amplitude changes from -32768 to +32767, or a <code>uint8</code>, where amplitude changes from 0 to 255. The last one is what we will be using in this article because it&rsquo;s very easy to understand and brings a few nice tricks.</p><p>Now, having the sample rate of 8000 and data format of unsigned uint8, digital sound is nothing more nothing less than an array of bytes shifting in time at the speed of 8000 bytes per second.</p><p>If our array is all zeros - there will be silence. If our array will be all 255 - there will be silence as well. However, if our array would contain different numbers - that would be a sound wave.</p><p>How can we hear it? One route would be to use native OS APIs, and that would be a route to the cross-platform programming hell because each OS has a different set of APIs, equally complex and unpleasant to use. And this is where UNIX way comes to the rescue. There are small utilities, and if you are lucky - they might even come with your OS - that allows you to play the sound streaming from stdin. On linux that would be <code>aplay</code> or <code>pacat</code>, while macOS and Windows users would have to install <a href=http://sox.sourceforge.net/>SoX</a> and use the <code>play</code> command.</p><p>Here are a few commands that should allow you to play raw unsigned bytes from stdin at the rate of 8000 samples per second:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash><span class=nb>alias</span> <span class=nv>PLAY</span><span class=o>=</span><span class=s1>&#39;aplay&#39;</span>
<span class=nb>alias</span> <span class=nv>PLAY</span><span class=o>=</span><span class=s1>&#39;pacat --rate 8000 --channels 1 --format u8&#39;</span>
<span class=nb>alias</span> <span class=nv>PLAY</span><span class=o>=</span><span class=s1>&#39;play -c1 -b8 -eunsigned -traw -r8k -&#39;</span>
<span class=nb>alias</span> <span class=nv>PLAY</span><span class=o>=</span><span class=s1>&#39;mplayer -cache 1024 -quiet -rawaudio samplesize=1:channels=1:rate=8000 -demuxer rawaudio -&#39;</span>
<span class=nb>alias</span> <span class=nv>PLAY</span><span class=o>=</span><span class=s1>&#39;ffplay -ar 8000 -ac 1 -f u8 -nodisp -&#39;</span>

<span class=c1># Play some white noise</span>
cat /dev/urandom <span class=p>|</span> PLAY
</code></pre></div><h2 id=oscillators>Oscillators</h2><p>Digital sound is a very simple programming concept, and producing it can be as simple as writing a for-loop. For example, this tiny app should make infinite white noise:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=c1>// cc noise.c -o noise &amp;&amp; ./noise | PLAY
</span><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span> <span class=k>for</span> <span class=p>(;;)</span> <span class=n>putchar</span><span class=p>(</span><span class=n>rand</span><span class=p>());</span> <span class=p>}</span>
</code></pre></div><p>To play a note rather than the noise we should make our sound periodic, the waveform should repeat itself at a certain frequency, and that frequency would define the note pitch. Here are the most common oscillator waveforms:</p><p><img src=/images/etude-in-c-oscillator-waveforms.png alt="oscillator waveforms"></p><p>The simplest oscillator in C would be the sawtooth wave. C implicitly casts <code>int</code> to <code>unsigned char</code> inside <code>putchar</code>, so if we simply write <code>for (int t = 0;; t++) putchar(t)</code> - we get a sawtooth wave. It won&rsquo;t be a note yet, only a low buzzing sound. To play a note we need to know it frequency. For example, the most common &ldquo;reference&rdquo; note is A from octave 4, which has the frequency of exactly 440 Hz, and this is what most tuning forks (kamertons) resonate to.</p><p>440 Hz means the oscillator should go from 0 to 255 exactly 440 times per second. We also know that during one second our loop must produce 8000 values because that is our sample rate. So every time the loop iterates we should increase the oscillator counter by <code>256*440/8000=14.08</code>. Roughly, 14.</p><p>To create a square wave we can simply get the 8th bit of the oscillator counter, it will be 0 for the values 0..127 and 0x80 for the values 127..255. This will result in a square wave of the same frequency as the sawtooth, it will be a bit more quiet, since the amplitude range will be twice as narrow, but still loud enough to hear it.</p><p>The sine wave requires the <code>sin()</code> function, we can use the oscillator counter (phase), divide it by 255, and multiply by 2π. The resulting amplitude should be multiplied by 255 to get it as loud as the other oscillators because <code>sin()</code> returns the values in the range [-1..1].</p><p>Here is the code that plays these three oscillators, one second each:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cm>/* Sawtooth */</span>
<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>t</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>osc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>t</span> <span class=o>&lt;</span> <span class=mi>8000</span><span class=p>;</span> <span class=n>t</span><span class=o>++</span><span class=p>,</span> <span class=n>osc</span> <span class=o>=</span> <span class=n>osc</span> <span class=o>+</span> <span class=mi>14</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>putchar</span><span class=p>(</span><span class=n>osc</span><span class=p>);</span>
<span class=p>}</span>
<span class=cm>/* Square */</span>
<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>t</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>osc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>t</span> <span class=o>&lt;</span> <span class=mi>8000</span><span class=p>;</span> <span class=n>t</span><span class=o>++</span><span class=p>,</span> <span class=n>osc</span> <span class=o>=</span> <span class=n>osc</span> <span class=o>+</span> <span class=mi>14</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>putchar</span><span class=p>(</span><span class=n>osc</span> <span class=o>&amp;</span> <span class=mh>0x80</span><span class=p>);</span>
<span class=p>}</span>
<span class=cm>/* Sine wave */</span>
<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>t</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>osc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>t</span> <span class=o>&lt;</span> <span class=mi>8000</span><span class=p>;</span> <span class=n>t</span><span class=o>++</span><span class=p>,</span> <span class=n>osc</span> <span class=o>=</span> <span class=n>osc</span> <span class=o>+</span> <span class=mi>14</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>putchar</span><span class=p>(</span><span class=mi>127</span> <span class=o>*</span> <span class=n>sin</span><span class=p>(</span><span class=n>osc</span><span class=o>/</span><span class=mf>255.0</span><span class=o>*</span><span class=mi>2</span><span class=o>*</span><span class=mf>3.14</span><span class=p>)</span> <span class=o>+</span> <span class=mi>128</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>There is one more approach to produce oscillating sound, and it&rsquo;s a clever one. It is often used to simulate bass or guitar strings. The idea is to fill the array with random data. The length of the array should be equal to the period of the oscillator, in our case for 440 Hz that would be ~18 samples. Then we will &ldquo;play&rdquo; bytes from that array, going back to the first item when we reach the end of the buffer. Despite being filled with random bytes, the repeating pattern of that random noise will sound like an oscillator and we will hear a distinctive pitch. But to make it sound like a trick we would have to smooth the data every time we loop over the array - we would replace elements with the average value of the current element and the next one. That&rsquo;s how with each iteration the random number would become more and more smooth until they are all equal and the oscillator fades out in silence:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>a</span><span class=p>[</span><span class=mi>18</span><span class=p>];</span>
<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>a</span><span class=p>);</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>rand</span><span class=p>();</span>
<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>t</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>t</span> <span class=o>&lt;</span> <span class=mi>8000</span><span class=p>;</span> <span class=n>t</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
  <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>t</span> <span class=o>%</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
  <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=p>(</span><span class=n>t</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
  <span class=n>putchar</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=p>])</span><span class=o>/</span><span class=mi>2</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>Try using larger arrays and see how the pitch becomes lower and the duration of the sound gets longer. Doesn&rsquo;t it resemble the sound of a string or kalimba tines?</p><h2 id=sequencers>Sequencers</h2><p>Now that we are able to play a single note, how can we play a melody? We need to change the pitch of the notes in time and that is what step sequencers do. We may have a fixed number of steps, each having a fixed duration, we can iterate them in a loop and change the pitch accordingly. Each step may contain the increment of the oscillator phase counter, zero would notate a pause. For example, here&rsquo;s a familiar riff &ldquo;E B D E D B A B&rdquo;. It uses only 4 notes - D and E from one octave and A + B from the other, lower octave. If we look at the <a href=https://pages.mtu.edu/~suits/notefreqs.html>note frequency table</a>, the pitches of those notes in octaves 5 and 4 would be 659.2Hz (E), 587.3Hz (D), 440Hz (A) and 493.8Hz (B).</p><p>The oscillator phase increments would then be approximately 21 (E), 19 (D), 14 (A) and 16 (B). Each step may take 2000 samples (1/4 of a second). Then the playback loop could look like:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=n>osc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=kt>int</span> <span class=n>melody</span><span class=p>[</span><span class=mi>8</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>21</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>19</span><span class=p>,</span> <span class=mi>21</span><span class=p>,</span> <span class=mi>19</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>14</span><span class=p>,</span> <span class=mi>16</span><span class=p>};</span>
<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>step</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;;</span><span class=n>step</span> <span class=o>=</span> <span class=p>(</span><span class=n>step</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=mi>8</span><span class=p>)</span> <span class=p>{</span>
  <span class=kt>int</span> <span class=n>increment</span> <span class=o>=</span> <span class=n>melody</span><span class=p>[</span><span class=n>step</span><span class=p>];</span>
  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>t</span> <span class=o>&lt;</span> <span class=mi>2000</span><span class=p>;</span> <span class=n>t</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>osc</span> <span class=o>=</span> <span class=n>osc</span> <span class=o>+</span> <span class=n>increment</span><span class=p>;</span>
    <span class=n>putchar</span><span class=p>(</span><span class=n>osc</span><span class=p>);</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>I guess, now it&rsquo;s time to deobfuscate the melody player from the very beginning of this post:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=c1>// play.c
</span><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=kt>float</span> <span class=n>f</span><span class=p>;</span> <span class=cm>/* note frequency */</span>
  <span class=kt>char</span> <span class=n>c</span><span class=p>;</span> <span class=cm>/* &#34;cdefgab&#34; for notes or &#34;pr&#34; for pause */</span>
  <span class=kt>int</span> <span class=n>d</span><span class=p>,</span> <span class=n>o</span><span class=p>;</span> <span class=cm>/* d = duration, o = octave */</span>
  <span class=k>while</span> <span class=p>(</span><span class=n>scanf</span><span class=p>(</span><span class=s>&#34;%d%c%d &#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>d</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>c</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>o</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=cm>/* convert note to lowercase */</span>
    <span class=n>c</span> <span class=o>&amp;=</span> <span class=mi>31</span><span class=p>;</span>
    <span class=cm>/* c&gt;&gt;4 is 0 for CDEFGAB and 1 for &#34;PR&#34; */</span>
    <span class=cm>/* so, for pauses f would be zero, for notes - 55 */</span>
    <span class=n>f</span> <span class=o>=</span> <span class=o>!</span><span class=p>(</span><span class=n>c</span> <span class=o>&gt;&gt;</span> <span class=mi>4</span><span class=p>)</span> <span class=o>*</span> <span class=mi>55</span><span class=p>;</span>
    <span class=cm>/* a trick we used in Nokia Composer post to conver note letter to note index */</span>
    <span class=n>c</span> <span class=o>=</span> <span class=p>(</span><span class=n>c</span> <span class=o>*</span> <span class=mi>8</span> <span class=o>/</span> <span class=mi>5</span> <span class=o>+</span> <span class=mi>8</span><span class=p>)</span> <span class=o>%</span> <span class=mi>12</span> <span class=o>+</span> <span class=n>o</span> <span class=o>*</span> <span class=mi>12</span> <span class=o>-</span> <span class=mi>22</span><span class=p>;</span>
    <span class=cm>/* Note `x` frequency is 2^(x/12), or (2^(1/12))^x */</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>c</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>f</span> <span class=o>*=</span> <span class=mf>1.0595</span><span class=p>;</span> <span class=cm>/* 1.0595 is 2^(1/12) */</span>
    <span class=p>}</span>
    <span class=cm>/* Play sawtooth wave for the given duration with given pitch */</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>d</span> <span class=o>=</span> <span class=mf>16e3</span> <span class=o>/</span> <span class=n>d</span><span class=p>;</span> <span class=n>d</span><span class=o>--</span><span class=p>;</span> <span class=n>putchar</span><span class=p>(</span><span class=n>d</span> <span class=o>*</span> <span class=n>f</span> <span class=o>*</span> <span class=mf>.032</span><span class=p>));</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>It plays music in something similar to MML, RTTTL or ABC notation. It expects a sequence of notes coming from stdin. Notes can be separated by whitespace, or commas or any other symbols that scanf would safely ignore. Each note has 3 parts - duration, pitch and octave, for example our loop from above can be written as &ldquo;8e5 8b4 8d5 8e5 8d5 8b4 8a4 8b4&rdquo;. Note frequency calculation is taken from <a href=/posts/nokia>Nokia Composer</a> and note playback is done with the sawtooth oscillator, as been described above.</p><p>Due to the numerous overflows, there are ASCII symbols beyond CDEFGAB that result in sharp notes:</p><ul><li>C# - <code>k</code></li><li>D# - <code>l</code></li><li>F# - <code>n</code></li><li>G# - <code>o</code> or <code>h</code></li><li>A# - <code>i</code></li></ul><h2 id=bytebeat>Bytebeat</h2><p>There is a niche music genre, known as ByteBeat, where music is written as terse C expressions. I hope to cover it in more detail in further articles, because it combines the cleverness of tiny code with the creativity of music composing. It heavily uses bit shifts and bitmasks to juggle notes. Some of the melodies are created by accident, some are carefully composed with some end goal in mind. They tend to sound a bit harsh and maybe slightly off-tune, but their beauty is in their code. A typical example of bytebeat would be:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=n>t</span><span class=o>*</span><span class=p>(</span><span class=n>t</span><span class=o>+</span><span class=p>(</span><span class=n>t</span><span class=o>&gt;&gt;</span><span class=mi>9</span><span class=o>|</span><span class=n>t</span><span class=o>&gt;&gt;</span><span class=mi>13</span><span class=p>))</span><span class=o>%</span><span class=mi>40</span><span class=o>&amp;</span><span class=mi>120</span>
</code></pre></div><p>It produces a repetitive melody of the uncertain pitch, that sounds like multiple instruments and has a certain rhythm. You might find a lot more bytebeat examples on the web, if you are interested.</p><h2 id=effects>Effects</h2><p>The pure oscillating sound is boring. But fortunately, there are a few sound effects that we can apply to it without much of a hassle.</p><p>For example, the bytebeat tune above can be passed through some kind of a low-pass filter that would smoothen the high frequencies and leave the low frequencies. The simplest form of a low-pass filter would be approximating the current output value with the previous one stored in the accumulator:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=kt>int</span> <span class=n>prev</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;;</span> <span class=n>t</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>output</span> <span class=o>=</span> <span class=n>t</span><span class=o>*</span><span class=p>(</span><span class=n>t</span><span class=o>+</span><span class=p>(</span><span class=n>t</span><span class=o>&gt;&gt;</span><span class=mi>9</span><span class=o>|</span><span class=n>t</span><span class=o>&gt;&gt;</span><span class=mi>13</span><span class=p>))</span><span class=o>%</span><span class=mi>40</span><span class=o>&amp;</span><span class=mi>120</span><span class=p>;</span>
    <span class=n>prev</span> <span class=o>=</span> <span class=n>prev</span> <span class=o>*</span> <span class=mf>0.8</span> <span class=o>+</span> <span class=n>output</span> <span class=o>*</span> <span class=mf>0.2</span><span class=p>;</span>
    <span class=n>putchar</span><span class=p>(</span><span class=n>prev</span><span class=p>);</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>The sound should become more muffled and less high-pitched. If you change 0.8/0.2 to 0.9/0.1 the effect should become even stronger. Try adjusting the coefficients and see how it affects the sound.</p><p>If you want to reduce the low frequencies and leave the high ones - just subtract the filtered low-pass signal from the original signal.</p><p>Another simple affect would be a delay line, which is just another array, storing a few recent signal values. For example, we want to re-play our sound with a 0.1 second delay. At the sampling rate of 8000 Hz we need to store 800 most recent samples and add them to the current output signal with a 800 byte offset:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp>#define N 800
</span><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=kt>int</span> <span class=n>delay</span><span class=p>[</span><span class=n>N</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;;</span> <span class=n>t</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>output</span> <span class=o>=</span> <span class=p>((</span><span class=n>t</span><span class=o>*</span><span class=p>(</span><span class=mi>42</span><span class=o>&amp;</span><span class=n>t</span><span class=o>&gt;&gt;</span><span class=mi>10</span><span class=p>))</span><span class=o>&amp;</span><span class=mh>0xff</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span>
    <span class=n>delay</span><span class=p>[</span><span class=n>t</span><span class=o>%</span><span class=n>N</span><span class=p>]</span> <span class=o>=</span> <span class=n>output</span><span class=p>;</span> <span class=cm>/* put current sample into delay line */</span>
    <span class=n>putchar</span><span class=p>(</span><span class=n>output</span> <span class=o>+</span> <span class=n>delay</span><span class=p>[(</span><span class=n>t</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>%</span><span class=n>N</span><span class=p>]);</span> <span class=cm>/* mix current sample with the oldest sample from the delay line */</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>This should bring a bit of polyphony to the sound and there would be some echo. Delay lines are very easy to implement, and mixed with filters that may result in the reverberation effect.</p><h2 id=and-much-more>And much more</h2><p>There are many more possible effects one could code in C, but the post is long enough and I guess I should stop. Similarly, playing with an oscillator may inspire you to create a sample player, or a granular synthesizer, or a frequency-modulating synthesizer. Of course, sequencers are also an endless area of experimentation - from random music generation and self-evolving melodies to compact sequencers like old mod trackers, that could be used in short demos and games.</p><p>If you are into music - feel free to share your sound experiments! In the meantime, I&rsquo;m preparing a post about the elegance of 1-bit sound with a simple tool to create 1-bit music. If there are any other music+programming topic you would like to hear about - just drop me a line.</p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href=https://github.com/zserge>Github</a>, <a href=https://twitter.com/zsergo>Twitter</a> or subscribe via <a href=/rss.xml>rss</a>.</p><p class=date style=text-align:right><em>Oct 15, 2020</em></p><p>See also:
<a href=/posts/nokia/>Nokia Composer in 512 bytes</a> and <a href=/posts/>more</a>.</p></div><footer><p>&copy;2012&ndash;2021 &#183;
<a href=https://zserge.com>Serge Zaitsev</a> &#183;
<a href=mailto:zaitsev.serge@gmail.com>zaitsev.serge@gmail.com</a></p></footer><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-33644825-1','zserge.com');ga('send','pageview');</script><script>new Image().src='https://nullitics.com/file.gif?r='+encodeURI(document.referrer)+'&d='+screen.width</script><noscript><img src=https://nullitics.com/file.gif></noscript></body></html>