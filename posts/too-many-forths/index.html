<!doctype html><html lang=en><head><meta charset=utf-8><title>Learn a language by writing too many Forths</title><meta name=description content="An exploration around RPN, concatenative languages, esoteric weirdness and threading techniques, while trying to learn Rust once again."><meta name=author content="Serge Zaitsev"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=data:,><link rel="shortcut icon" sizes=32x32 href=/favicon.png><link rel="shortcut icon" sizes=192x192 href=/favicon-192x192.png><link rel=apple-touch-icon href=/favicon-192x192.png><link rel=alternate type=application/rss+xml title=RSS href=/rss.xml><link rel=canonical href=https://zserge.com/posts/too-many-forths/><meta property="og:title" content="Learn a language by writing too many Forths"><meta property="og:type" content="article"><meta property="og:url" content="https://zserge.com/posts/too-many-forths/"><meta property="og:image" content="https://zserge.com/logo.png"><meta property="og:description" content="An exploration around RPN, concatenative languages, esoteric weirdness and threading techniques, while trying to learn Rust once again."><meta property="og:locale" content="en_US"><meta name=twitter:card content="An exploration around RPN, concatenative languages, esoteric weirdness and threading techniques, while trying to learn Rust once again."><meta name=twitter:site content="@zsergo"><style type=text/css>body{padding:1rem;margin:auto;max-width:46rem;font-family:pt serif,Georgia,Cambria,times new roman,Times,serif;line-height:1.5;font-size:20px;color:rgba(0,0,0,.87);-webkit-font-smoothing:antialiased;font-weight:300}nav{display:flex;justify-content:space-between;align-items:center;margin:1em 0 3em}nav ul,nav li{display:inline-block;list-style:none;margin:0 0 0 .5rem;padding:0}nav ul{margin-right:1rem}.logo{background-color:rgba(0,0,0,.87);color:#fff;min-width:48px;min-height:48px;font-size:28px;border-radius:2px;display:flex;justify-content:center;align-items:center}.logo:hover{color:#fff}h1,h2{line-height:1.2;font-family:roboto,system-ui,segoe ui,Helvetica,Arial,sans-serif;font-weight:400;text-transform:uppercase;margin:1.34em 0 0}h1{font-size:1.95em}h2{font-size:1.25em;border-bottom:2px solid rgba(0,0,0,.87)}h1 a{color:rgba(0,0,0,.87)}p{margin:.67em 0 1em}a{color:#0076df;text-decoration:none;word-break:break-word}a:hover{color:rgba(0,0,0,.87)}ul,ol{list-style-position:outside;margin-left:1em}img{display:block;margin-left:auto;margin-right:auto;max-width:100%}pre,code{font-family:roboto mono,SFMono-Regular,Consolas,liberation mono,Menlo,monospace;font-weight:400;font-size:18px;color:rgba(0,0,0,.6);background:#eee}code{padding:.2rem .4rem;font-size:14px;border-radius:2px}pre{overflow-y:auto;line-height:20px;border-radius:2px;padding:1em}pre code{font-size:14px;padding:0;color:rgba(0,0,0,.87)}footer{font-size:12px}@media(prefers-color-scheme:dark){.logo{color:#444;background-color:#e4e4e4}.logo:hover{color:#444}body,h1 a,h2 a{background-color:#444;color:#e4e4e4}pre,pre code{background:#333;color:#e4e4e4}h2{border-bottom:1px solid #e4e4e4}code{color:#aaa;background:#333}a{color:#e39777}a:hover{color:#e4e4e4}img{filter:grayscale(30%)}}.hl{display:block;width:100%;background-color:#ffc}.ow,.gh,.gp,.gs,.gu,.nt,.nn,.ne,.ni,.nc,.kr,.kn,.kd,.kc,.k{font-weight:700}.c,.ch,.cm,.c1,.cs,.ge{color:#777}</style><link rel="shortcut icon" href=/favicon.ico></head><body><header><nav><a class=logo href=/>Z</a><ul><li><a href=/about/>about</a></li><li><a href=/posts/>posts</a></li><li><a href=https://mastodon.social/@zserge rel=me>@me</a></li><li><a href=https://github.com/zserge rel=me>&lt;/>me</a></li></ul></nav></header><div id=content><h1>Learn a language by writing too many Forths</h1><p>Every developer eventually wants to explore new programming languages. As motivating as it gets, there&rsquo;s always a question of finding a suitable project for that noble goal.</p><p>You can rewrite classical games, you can make a text editor, a UNIX shell or clones of traditional UNIX core utils. If you can afford it - build a web server, write an <a href=https://en.wikipedia.org/wiki/CHIP-8>emulator</a>, a <a href=/posts/raytracer/>ray tracer</a> or even an <a href=https://www.reddit.com/r/osdev/>operating system</a>. To each his own.</p><p>I prefer having as little programming overhead as possible to rapidly get the impression of a new language. I don&rsquo;t like googling for &ldquo;best socket library in language X&rdquo; or &ldquo;top UI frameworks in 2022&rdquo; as the first step into the language. Ecosystem details are quite important for production use, but newcomers often find such details distracting.</p><p>Thus, my &ldquo;try the new language&rdquo; exercise is: write as many Forths as you can in it.</p><p>Concatenative languages are conceptually simple and flexible, however implementing them covers lots of fundamental concepts, such as data structures (stacks, linked lists or hashmaps), algorithms (search, parsing) and it can get as complicated as you want. Choose your own adventure.</p><h2 id=rpn>RPN</h2><p>The first and the most trivial &ldquo;forth-like&rdquo; program to write is an RPN calculator. Many of us did that a number of times in their academy years. This silly exercise would help you to find the answers to:</p><ul><li>how to write the main() function</li><li>how to handle numeric types and enums</li><li>how to write loops, conditionals, switch/case</li><li>how to use stacks (or vectors, or arrays, or lists)</li><li>how to handle errors</li><li>how to write tests and/or how to debug</li></ul><p>At this point I don&rsquo;t even bother with user input. I define a set of operations, typically <code>+ - * / %</code> and a separate operation that puts a number on stack. Then I write a single <code>rpn</code> function that evaluates the stack. Vector of opcodes is my input, stack is my output. All validation happens in the tests.</p><p>Normally, an exercise takes just a few lines of code and can be accomplished in several minutes. Here&rsquo;s my approach in Rust:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>enum</span> <span class=nc>Op</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>Add</span><span class=p>,</span><span class=w> </span><span class=n>Sub</span><span class=p>,</span><span class=w> </span><span class=n>Mul</span><span class=p>,</span><span class=w> </span><span class=n>Div</span><span class=p>,</span><span class=w> </span><span class=n>Mod</span><span class=p>,</span><span class=w> </span><span class=n>Num</span><span class=p>(</span><span class=kt>i32</span><span class=p>)</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>rpn</span><span class=p>(</span><span class=n>code</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=n>Op</span><span class=p>])</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>stack</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>code</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>Op</span>::<span class=n>Num</span><span class=p>(</span><span class=n>n</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>stack</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=o>*</span><span class=n>n</span><span class=p>),</span><span class=w>
</span><span class=w>            </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=n>stack</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                    </span><span class=k>return</span><span class=w> </span><span class=nb>None</span><span class=p>;</span><span class=w>
</span><span class=w>                </span><span class=p>}</span><span class=w>
</span><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stack</span><span class=p>.</span><span class=n>pop</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stack</span><span class=p>.</span><span class=n>pop</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w>                </span><span class=k>match</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                    </span><span class=n>Op</span>::<span class=n>Add</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>stack</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>b</span><span class=p>),</span><span class=w>
</span><span class=w>                    </span><span class=n>Op</span>::<span class=n>Mul</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>stack</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>b</span><span class=p>),</span><span class=w>
</span><span class=w>                    </span><span class=n>Op</span>::<span class=n>Sub</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>stack</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>b</span><span class=p>),</span><span class=w>
</span><span class=w>                    </span><span class=n>Op</span>::<span class=n>Div</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>stack</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>b</span><span class=p>),</span><span class=w>
</span><span class=w>                    </span><span class=n>Op</span>::<span class=n>Mod</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>stack</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>b</span><span class=p>),</span><span class=w>
</span><span class=w>                    </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=nb>None</span><span class=p>,</span><span class=w>
</span><span class=w>                </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>stack</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>...</span><span class=w>
</span><span class=w></span><span class=cp>#[test]</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>test_rpn</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>rpn</span><span class=p>(</span><span class=o>&amp;</span><span class=p>[</span><span class=n>Op</span>::<span class=n>Num</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span><span class=w> </span><span class=n>Op</span>::<span class=n>Num</span><span class=p>(</span><span class=mi>3</span><span class=p>),</span><span class=w> </span><span class=n>Op</span>::<span class=n>Add</span><span class=p>]),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=mi>5</span><span class=p>));</span><span class=w>
</span><span class=w>		</span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>rpn</span><span class=p>(</span><span class=o>&amp;</span><span class=p>[</span><span class=n>Op</span>::<span class=n>Num</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span><span class=w> </span><span class=n>Op</span>::<span class=n>Num</span><span class=p>(</span><span class=mi>3</span><span class=p>),</span><span class=w> </span><span class=n>Op</span>::<span class=n>Num</span><span class=p>(</span><span class=mi>5</span><span class=p>),</span><span class=w> </span><span class=n>Op</span>::<span class=n>Mul</span><span class=p>,</span><span class=w> </span><span class=n>Op</span>::<span class=n>Add</span><span class=p>]),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=mi>17</span><span class=p>));</span><span class=w>
</span><span class=w>		</span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>rpn</span><span class=p>(</span><span class=o>&amp;</span><span class=p>[]),</span><span class=w> </span><span class=nb>None</span><span class=p>);</span><span class=w>
</span><span class=w>		</span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>rpn</span><span class=p>(</span><span class=o>&amp;</span><span class=p>[</span><span class=n>Op</span>::<span class=n>Add</span><span class=p>]),</span><span class=w> </span><span class=nb>None</span><span class=p>);</span><span class=w>
</span><span class=w>		</span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>rpn</span><span class=p>(</span><span class=o>&amp;</span><span class=p>[</span><span class=n>Op</span>::<span class=n>Num</span><span class=p>(</span><span class=mi>3</span><span class=p>),</span><span class=w> </span><span class=n>Op</span>::<span class=n>Add</span><span class=p>]),</span><span class=w> </span><span class=nb>None</span><span class=p>);</span><span class=w>
</span><span class=w>		</span><span class=p>...</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Naturally, one can turn it into a CLI calculator similar to <code>dc</code>. But I usually switch to the proper Forth-like language with dictionaries and words instead.</p><h2 id=tiny-forth>Tiny Forth</h2><p>Here the goal is more ambitious &ndash; to evaluate a string of words with the support of user-defined words. We don&rsquo;t aim to implement a proper Forth with all the underlying dict-related primitives, we simply want <code>:</code> to define a new word and <code>;</code> to terminate that definition.</p><p>This exercise involves some basic string tokenisation and lots of error handling. There&rsquo;s more than one possible data type for a dictionary, hashmap is an obvious choice, but a vector or a list would also work.</p><p>My Rust solution is far from being perfect, but at least it&rsquo;s small. It was also an eye-opening case on how convenient the <code>?</code> operator is in Rust when it comes to error handling.</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>type</span> <span class=nc>Value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kt>i32</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>type</span> <span class=nb>Result</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>std</span>::<span class=n>result</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>Error</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(Debug, Copy, Clone)]</span><span class=w>
</span><span class=w></span><span class=k>enum</span> <span class=nc>Token</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>Add</span><span class=p>,</span><span class=w> </span><span class=n>Sub</span><span class=p>,</span><span class=w> </span><span class=n>Mul</span><span class=p>,</span><span class=w> </span><span class=n>Div</span><span class=p>,</span><span class=w> </span><span class=n>Dup</span><span class=p>,</span><span class=w> </span><span class=nb>Drop</span><span class=p>,</span><span class=w> </span><span class=n>Swap</span><span class=p>,</span><span class=w> </span><span class=n>Over</span><span class=p>,</span><span class=w> </span><span class=n>Num</span><span class=p>(</span><span class=kt>i32</span><span class=p>),</span><span class=w> </span><span class=n>Word</span><span class=p>(</span><span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(Debug, Clone)]</span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>Word</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>name</span>: <span class=nb>String</span><span class=p>,</span><span class=w> </span><span class=n>tokens</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>Token</span><span class=o>&gt;</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Forth</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>stack</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>dict</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>Word</span><span class=o>&gt;</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(Debug, PartialEq)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>Error</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>DivisionByZero</span><span class=p>,</span><span class=w> </span><span class=n>StackUnderflow</span><span class=p>,</span><span class=w> </span><span class=n>UnknownWord</span><span class=p>,</span><span class=w> </span><span class=n>InvalidWord</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Forth</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Forth</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Forth</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>stack</span>: <span class=nc>vec</span><span class=o>!</span><span class=p>[],</span><span class=w> </span><span class=n>dict</span>: <span class=nc>vec</span><span class=o>!</span><span class=p>[]</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>eval</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>input</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>words</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>input</span><span class=p>.</span><span class=n>split</span><span class=p>(</span><span class=s>&#34; &#34;</span><span class=p>).</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>s</span><span class=o>|</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>to_lowercase</span><span class=p>());</span><span class=w>
</span><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>word</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>words</span><span class=p>.</span><span class=n>next</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=n>word</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=s>&#34;:&#34;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=bp>self</span><span class=p>.</span><span class=n>new_word</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>words</span><span class=p>)</span><span class=o>?</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=bp>self</span><span class=p>.</span><span class=n>apply</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>tokenise</span><span class=p>(</span><span class=o>&amp;</span><span class=n>word</span><span class=p>)</span><span class=o>?</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>(())</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>tokenise</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>word</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=n>Token</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>idx</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>find_word</span><span class=p>(</span><span class=o>&amp;</span><span class=n>word</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>Token</span>::<span class=n>Word</span><span class=p>(</span><span class=n>idx</span><span class=p>));</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>token</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>word</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;+&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=n>Add</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;-&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=n>Sub</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;*&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=n>Mul</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;/&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=n>Div</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;dup&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=n>Dup</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;drop&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=nb>Drop</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;swap&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=n>Swap</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;over&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=n>Over</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>w</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>w</span><span class=p>.</span><span class=n>parse</span>::<span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=nb>Ok</span><span class=p>(</span><span class=n>n</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=n>Num</span><span class=p>(</span><span class=n>n</span><span class=p>),</span><span class=w>
</span><span class=w>                </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=n>Error</span>::<span class=n>UnknownWord</span><span class=p>),</span><span class=w>
</span><span class=w>            </span><span class=p>},</span><span class=w>
</span><span class=w>        </span><span class=p>};</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=n>token</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>apply</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>token</span>: <span class=nc>Token</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=n>token</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>Token</span>::<span class=n>Add</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>pop</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>pop</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>b</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>a</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=n>Token</span>::<span class=n>Sub</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>pop</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>pop</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>b</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>a</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=n>Token</span>::<span class=n>Mul</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>pop</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>pop</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>b</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>a</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=n>Token</span>::<span class=n>Div</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>pop</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>pop</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                    </span><span class=k>return</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=n>Error</span>::<span class=n>DivisionByZero</span><span class=p>);</span><span class=w>
</span><span class=w>                </span><span class=p>}</span><span class=w>
</span><span class=w>                </span><span class=bp>self</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>b</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>a</span><span class=p>);</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=n>Token</span>::<span class=n>Dup</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>pick</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>a</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=n>Token</span>::<span class=nb>Drop</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>pop</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=n>Token</span>::<span class=n>Swap</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>pop</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>pop</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>a</span><span class=p>);</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>b</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=n>Token</span>::<span class=n>Over</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>pick</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>b</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=n>Token</span>::<span class=n>Num</span><span class=p>(</span><span class=n>n</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>n</span><span class=p>),</span><span class=w>
</span><span class=w>            </span><span class=n>Token</span>::<span class=n>Word</span><span class=p>(</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=k>for</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>dict</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>tokens</span><span class=p>.</span><span class=n>clone</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                    </span><span class=bp>self</span><span class=p>.</span><span class=n>apply</span><span class=p>(</span><span class=n>t</span><span class=p>)</span><span class=o>?</span><span class=w>
</span><span class=w>                </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>(())</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>find_word</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>name</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=kt>usize</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>dict</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>enumerate</span><span class=p>().</span><span class=n>rfind</span><span class=p>(</span><span class=o>|</span><span class=p>(</span><span class=n>_</span><span class=p>,</span><span class=w> </span><span class=n>Word</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>name</span>: <span class=nc>n</span><span class=p>,</span><span class=w> </span><span class=p>..</span><span class=w> </span><span class=p>})</span><span class=o>|</span><span class=w> </span><span class=o>*</span><span class=n>n</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>name</span><span class=p>).</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=o>|</span><span class=w> </span><span class=n>i</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>new_word</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>words</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w>
</span><span class=w>    </span><span class=k>where</span><span class=w>
</span><span class=w>        </span><span class=n>T</span>: <span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>words</span><span class=p>.</span><span class=n>next</span><span class=p>().</span><span class=n>ok_or</span><span class=p>(</span><span class=n>Error</span>::<span class=n>InvalidWord</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>name</span><span class=p>.</span><span class=n>parse</span>::<span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;</span><span class=p>().</span><span class=n>is_ok</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=n>Error</span>::<span class=n>InvalidWord</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>tokens</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>vec</span><span class=o>!</span><span class=p>[];</span><span class=w>
</span><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>word</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>words</span><span class=p>.</span><span class=n>next</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=n>word</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=s>&#34;;&#34;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=bp>self</span><span class=p>.</span><span class=n>dict</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>Word</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>tokens</span><span class=w> </span><span class=p>});</span><span class=w>
</span><span class=w>                </span><span class=k>return</span><span class=w> </span><span class=nb>Ok</span><span class=p>(());</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=n>tokens</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>tokenise</span><span class=p>(</span><span class=o>&amp;</span><span class=n>word</span><span class=p>)</span><span class=o>?</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=nb>Err</span><span class=p>(</span><span class=n>Error</span>::<span class=n>InvalidWord</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>pop</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>stack</span><span class=p>.</span><span class=n>pop</span><span class=p>().</span><span class=n>ok_or</span><span class=p>(</span><span class=n>Error</span>::<span class=n>StackUnderflow</span><span class=p>)</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>push</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>value</span>: <span class=nc>Value</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>stack</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>pick</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>i</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>stack</span><span class=p>.</span><span class=n>len</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=nb>Ok</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>stack</span><span class=p>[</span><span class=n>n</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>])</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=nb>Err</span><span class=p>(</span><span class=n>Error</span>::<span class=n>StackUnderflow</span><span class=p>)</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>...</span><span class=w>
</span><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Forth</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=n>f</span><span class=p>.</span><span class=n>eval</span><span class=p>(</span><span class=s>&#34;: five 2 3 + ; five five *&#34;</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>f</span><span class=p>.</span><span class=n>pop</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></code></pre></div><p>Actually, this toy project may become a starting point for something bigger &ndash; you&rsquo;ve now built a core for a domain-specific language of your choice and can embed it into other applications as a scripting engine.</p><h2 id=false>FALSE</h2><p>Now, let me open some esoteric and weird territories: meet <a href=https://esolangs.org/wiki/FALSE>FALSE</a>. An esoteric language invented by Wouter van Ooermersen in 1993 to become as powerful as possible with a tiny implementation. The original compiler was only 1024 bytes and easily fit one screen.</p><p>However, the language is quite powerful - it supports lambda functions, variables, most of the arithmetic expressions, conditionals and loops, and some I/O support.</p><p>Implementing FALSE is very convenient for entry-level programmers because it doesn&rsquo;t require a parser - each character is a separate command ready for execution. A complete language &ldquo;specification&rdquo; can be presented as follows:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>      STACK     STACK           
CMD   BEFORE    AFTER           EXAMPLE          DESCRIPTION
-------------------------------------------------------------------------
{..}  -                                          { this is a comment }
[..]  -         function        [1+]             { (lambda (x) (+ x 1)) }
a..z  -         varadr          a                { use a: or a; }
A..Z  -         value of a..z   A                { [1+]a: 3 A! }
1..9  -         value           1                { 1 }
&#39;c    -         value           &#39;A               { 65 }
:     n,varadr  -               1a:              { a:=1 }
;     varadr    varvalue        a;               { a }
!     function  -               f;!              { f() }
+     n1,n1     n1+n2           1 2+             { 1+2 }
-     n1,n2     n1-n2           1 2-             { 1-2 }
*     n1,n2     n1*n2           1 2*             { 1*2 }
/     n1,n2     n1/n2           1 2/             { 1/2 }
_     n         -n              1_               { -1 }
&lt;     n1,n2     n1&lt;n2           3 2&lt;             { 3&lt;2 }
=     n1,n1     n1=n2           1 2=~            { 1&lt;&gt;2 }
&gt;     n1,n2     n1&gt;n2           1 2&gt;             { 1&gt;2 }
&amp;     n1,n2     n1 and n2       1 2&amp;             { 1&amp;2 }
|     n1,n2     n1 or n2        1 2|             { 1|2 }
~     n         not n           0~               { 0,1 }
$     n         n,n             1$               { dupl. top stack }
%     n         -               1%               { del. top stack }
\     n1,n2     n2,n1           1 2\             { swap }
@     n,n1,n2   n1,n2,n         1 2 3@           { rot }
?     bool,fun  -               a;2=[1f;!]?      { if a=2 then f(1) }
#     bool,fun  -               1[$100&lt;][1+]#    { while a&lt;100 do a:=a+1 }
.     n         -               1.               { printnum(1) }
&#34;..&#34;  -         string          &#34;hi!&#34;            { printstr(&#34;hi!&#34;) }
,     ch        -               10,              { putc(10) }
^     -         ch              ^                { getc() }
</code></pre></div><p>Values are integers, each command performs some action with the values on top of the stack. Not too different from our tiny Forth above, except for lambdas. Lambda is a piece of code within the square brackets. For example <code>[1+]</code> is a lambda that increments the top value on stack. To apply the lambda use <code>!</code>, i.e. <code>2[1+]!</code> returns <code>3</code>. It&rsquo;s common to assign lambdas to some named variables and invoke them later: <code>[1+]i:</code> defines our increment lambda under name &ldquo;i&rdquo; and <code>2i;!</code> applies it to the value of &ldquo;2&rdquo;.</p><p>For a compact language like this it&rsquo;s very tempting to try out macros and some meta-programming. Some FALSE implementations are type-safe (so that an arbitrary integer on stack can&rsquo;t be used as a variable name or a lambda), which would be also interesting to implement.</p><p>It&rsquo;s not the first time I approach FALSE, so my implementation in Rust easily took ~250 LOC - here&rsquo;s the <a href=https://gist.github.com/zserge/c26f541af4f0ce8db7b0ac9d02e9ac93>gist</a>.</p><p>The simplicity and the power of FALSE makes it a good candidate to explore low-level programming: try making a bootable OS image from a FALSE interpreter to get a &ldquo;False OS&rdquo;, akin to many BASIC systems from the past. Code is small, but possibilities are endless. Or maybe add some GUI and turn it into a <a href=https://forthsalon.appspot.com/>False Haiku</a> evaluator where one can define a pixel shader in FALSE. Or maybe spice it up with some DSP algorithms and turn it into a music programming system like <a href=https://esolangs.org/wiki/StackBeat>StackBeat</a> or <a href=https://paulbatchelor.github.io/proj/cook/>Sporth</a>.</p><h2 id=threading-techniques>Threading techniques</h2><p>Finally, if you got to this point and still think you need to go deeper - you can check out how the assembly code is produced by the compiler (if you are studying a compiled language or the one with JIT).</p><p>Threaded code is a technique for implementing virtual machine interpreters. Say, your program consists of three instructions: <code>pushA</code>, <code>pushB</code> and <code>add</code>. We could write the following machine code to execute these instructions:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=o>*</span><span class=n>sp</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>pushA</span><span class=p>()</span> <span class=p>{</span> <span class=o>*</span><span class=n>sp</span><span class=o>++</span> <span class=o>=</span> <span class=n>A</span><span class=p>;</span> <span class=p>}</span>
<span class=kt>void</span> <span class=nf>pushB</span><span class=p>()</span> <span class=p>{</span> <span class=o>*</span><span class=n>sp</span><span class=o>++</span> <span class=o>=</span> <span class=n>B</span><span class=p>;</span> <span class=p>}</span>
<span class=kt>void</span> <span class=nf>add</span><span class=p>()</span>   <span class=p>{</span> <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=o>*</span><span class=n>sp</span><span class=o>--</span><span class=p>,</span> <span class=o>*</span><span class=n>b</span> <span class=o>=</span> <span class=o>*</span><span class=n>sp</span><span class=o>--</span><span class=p>;</span> <span class=o>*</span><span class=n>sp</span><span class=o>++</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span> <span class=p>}</span>

<span class=n>pushA</span><span class=p>();</span>  <span class=c1>// asm: call pushA
</span><span class=c1></span><span class=n>pushB</span><span class=p>();</span>  <span class=c1>// asm: call pushB
</span><span class=c1></span><span class=n>add</span><span class=p>();</span>    <span class=c1>// asm: call add
</span></code></pre></div><p>This is called &ldquo;subroutine-threaded code&rdquo;, but it&rsquo;s not a threaded code really. If we avoid the call instructions, however, we would get an array of code addresses. Now to execute such code we need to keep track of current instruction pointer and introduce a <code>NEXT</code> command that would jump from one instruction to the other:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=nf>void</span> <span class=p>(</span><span class=o>*</span><span class=n>op</span><span class=p>)();</span>
<span class=n>op</span> <span class=n>code</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=n>pushA</span><span class=p>,</span> <span class=n>pushB</span><span class=p>,</span> <span class=n>add</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>};</span>
<span class=n>op</span> <span class=o>*</span><span class=n>ip</span> <span class=o>=</span> <span class=n>code</span><span class=p>;</span>
<span class=cp>#define NEXT ((*ip++)())
</span><span class=cp></span><span class=k>while</span> <span class=p>(</span><span class=n>ip</span><span class=p>)</span> <span class=n>NEXT</span><span class=p>;</span>
</code></pre></div><p>This technique is known as the &ldquo;call threading&rdquo;, it&rsquo;s available in most of the programming languages but requires a <code>call/ret</code> instruction for each subroutine and is usually very slow.</p><p>Direct threaded code uses command addresses as opcodes, but those are not subroutines and instead of <code>ret</code> instruction at the end they call <code>NEXT</code> to jump to the next opcode. In C this might be implemented with a computed <code>goto</code>:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp>#define NEXT goto **ip++
</span><span class=cp></span><span class=kt>void</span> <span class=o>*</span><span class=n>code</span> <span class=o>=</span> <span class=p>{</span> <span class=o>&amp;&amp;</span><span class=n>pushA</span><span class=p>,</span> <span class=o>&amp;&amp;</span><span class=n>pushB</span><span class=p>,</span> <span class=o>&amp;&amp;</span><span class=n>add</span><span class=p>,</span> <span class=o>&amp;&amp;</span><span class=n>halt</span> <span class=p>};</span>
<span class=kt>void</span> <span class=o>**</span><span class=n>ip</span> <span class=o>=</span> <span class=n>code</span><span class=p>;</span>
<span class=nl>pushA</span><span class=p>:</span>
	<span class=o>*</span><span class=n>sp</span><span class=o>++</span> <span class=o>=</span> <span class=n>A</span><span class=p>;</span>
	<span class=n>NEXT</span><span class=p>;</span>
<span class=nl>pushB</span><span class=p>:</span>
  <span class=o>*</span><span class=n>sp</span><span class=o>++</span> <span class=o>=</span> <span class=n>B</span><span class=p>;</span>
	<span class=n>NEXT</span><span class=p>;</span>
<span class=nl>add</span><span class=p>:</span>
	<span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=o>*</span><span class=n>sp</span><span class=o>--</span><span class=p>;</span>
	<span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=o>*</span><span class=n>sp</span><span class=o>--</span><span class=p>;</span>
	<span class=o>*</span><span class=n>sp</span><span class=o>++</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
	<span class=n>NEXT</span><span class=p>;</span>
<span class=nl>halt</span><span class=p>:</span>
</code></pre></div><p>Direct threading is faster than subroutine calls, but Forth implementations usually prefer indirect threading, which is a similar technique but stores addresses of addresses of the words instead. The reason is that indirect threading is more compact, as it uses a single pointer to <code>NEXT</code> at the end of each operation instead of a number of assembly instructions performing the indirect jump with increment.</p><p>Another common, more portable dispatch technique is what we have been using in the exercises above - a switch/case statement. It requires branching and a jump instruction for the outer loop, which may impact the performance, also some languages perform bounds checking on switch slowing it down. But it remains the most popular VM technique nowadays:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>enum { PUSHA, PUSHB, ADD, SUB, MUL, DIV, HALT };
int code[] = { PUSHA, PUSHB, ADD, HALT };
for (int i = 0; code[i] != HALT; i++) {
	switch (code[i]) {
		case PUSHA: ... break;
		case PUSHB: ... break;
		case ADD: ... break;
		...
	}
}
</code></pre></div><p>There is also a recursive continuation passing technique, where a subroutine never returns but invokes the next subroutine instead. It works well if the compiler uses tail-call optimisation and NEXT calls are replaced with jumps. This often results in the same machine code as computed goto but is supported by a broader circle of languages:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>void NEXT() { code[++ip](); }
void pushA() { ...; NEXT(); }
void pushB() { ...; NEXT(); }
...
fn_t code[] = { pushA, pushB, add, halt };
code[0]();
</code></pre></div><p>Not every programming language supports all such techniques, and not every language results in the same performance for every of them. Rust doesn&rsquo;t have computed goto but it supports calling functions by pointer, continuation passing optimises match statements pretty well.</p><p>My quick-n-dirty benchmarks in Rust have shown that subroutine calls are indeed 2x-3x slower, but a switch/match threading is as fast as continuation passing. At the same time <code>match{}</code> approach remains the shortest and the most readable code of them all.</p><p>I would probably go further and use inline assembly to implement threaded code, it would also be interesting to compare the performance on modern Intel CPUs and some 8-bit or 32-bit microcontrollers. Applying powerful Rust macros to unroll the switch statements could improve the performance even further, but course it would all imply reading lots of LLVM bytecode and exploring various compiler optimisations, which is also a way to learn new things.</p><p>Threaded code brings elegance, simplicity and improves code density. Once getting comfortable with threaded code one might try implementing a <a href=https://muforth.nimblemachines.com/threaded-code-literals-ifs-and-loops/>Forth in assembly</a> from the ground up, but that&rsquo;s a completely different story.</p><p>And what&rsquo;s your preferred way of learning new languages?</p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href=https://github.com/zserge>Github</a>, <a href=https://mastodon.social/@zserge>Mastodon</a>, <a href=https://twitter.com/zsergo>Twitter</a> or subscribe via <a href=/rss.xml>rss</a>.</p><p class=date style=text-align:right><em>Jul 05, 2022</em></p><p>See also:
<a href=/posts/tiny-font/>Making a tiny 2x3 bitmap font</a> and <a href=/posts/>more</a>.</p></div><footer><p>&copy;2012&ndash;2023 &#183;
<a class=h-card rel=me href=https://zserge.com/>Serge Zaitsev</a> &#183;
<a href=mailto:hello@zserge.com rel=me>hello@zserge.com</a> &#183;
<a href=https://mastodon.social/@zserge rel=me>@zserge@mastodon.social</a></p></footer><script>new Image().src='https://nullitics.com/file.gif?u='+encodeURI(location.href)+'&r='+encodeURI(document.referrer)+'&d='+screen.width</script><noscript><img src=https://nullitics.com/file.gif></noscript></body></html>