<!doctype html><html lang=en><head><meta charset=utf-8><title>Beep, beep, I'm a sheep</title><meta name=description content="Let's build a tiny cross-platform audio library for playing beeps to understand how low-level audio works across the platforms"><meta name=author content="Serge Zaitsev"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel="shortcut icon" type=image/png href=/favicon.png><link rel=alternate type=application/rss+xml title=RSS href=/rss.xml><link rel=canonical href=https://zserge.com/posts/beep/><meta property="og:title" content="Beep, beep, I'm a sheep"><meta property="og:type" content="article"><meta property="og:url" content="https://zserge.com/posts/beep/"><meta property="og:image" content="https://zserge.com/logo.png"><meta property="og:description" content="Let's build a tiny cross-platform audio library for playing beeps to understand how low-level audio works across the platforms"><meta property="og:locale" content="en_US"><meta name=twitter:card content="Let's build a tiny cross-platform audio library for playing beeps to understand how low-level audio works across the platforms"><meta name=twitter:site content="@zsergo"><link href=/styles.css rel=stylesheet type=text/css><link rel="shortcut icon" href=/favicon.ico></head><body><header><nav><a class=logo href=/>Z</a></nav><div class=empty></div><nav><section><a href=/about/>about</a>
<a href=/posts/>posts</a></section><section><a href=https://twitter.com/zsergo>@me</a>
<a href=https://github.com/zserge>&lt;/>me</a></section></nav></header><div id=content><h1>Beep, beep, I'm a sheep</h1><p>Audio I/O is a complex topic, which scares away many inspired musicians who are into programming (or programmers who are into music). Let&rsquo;s try making it look less complex and see how audio works on each modern desktop platform.</p><p>Our show case today will be a simple beeper. Remeber that annoying thing inside your PC boxes producing the irritating buzzing sound? It&rsquo;s long time gone, but I suggest to sumon its soul and make a library that plays beeps across all the platforms.</p><p>The end result is available here - <a href=https://github.com/zserge/beep>https://github.com/zserge/beep</a>.</p><h2 id=windows>Windows</h2><p>We are lucky here - Windows already has a <code>Beep(freqency, duration)</code> function in the <code>&lt;utilapiset.h></code>, we can reuse that.</p><p>The function has got a <a href=https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebeep>very long and hard life</a>. It has been introduced to play beeps through the hardware beeper using the 8245 programmable timer. As more and more PCs came without a beeper, this function became obsolete, but in Windows 7 it has been rewritten to play beeps using the regular sound card API.</p><p>Yet, behind the simplicity of this function hides the complexity of all the Windows sound APIs. There has been <a href=https://docs.microsoft.com/en-us/windows/win32/api/mmeapi/>MME</a> released in 1991, which is the default choice for audio because it&rsquo;s well supported. However, MME is known to have very high playback latency and probably won&rsquo;t be suitable for most audio apps. There is also <a href=https://docs.microsoft.com/en-us/windows/win32/coreaudio/wasapi>WASAPI</a> released in 2007, which has much lower latency, especially when used in exclusive mode (i.e. when you app runs - the user can&rsquo;t listen to Spotify or any other app, your app owns the sound hardware exclusively). WASAPI is often a good choice for audio apps, but there is also <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/bb318665(v=vs.85)">DirectSound</a>, which basically wraps WASAPI for DirectX interfacing.</p><p><em>If in doubt - use WASAPI.</em></p><h2 id=linux>Linux</h2><p>Audio is one of a few areas, where Linux APIs are no better than the rest of the platforms. First of all, there is ALSA, which is part of the kernel itself. ALSA works directly with the hardware and if you would like your app to work exclusively with sound - ALSA could probably be a good compromise between complexity and performance. If you are bulding a synth or a sampler for a Raspberry Pi - ALSA could be a good choice.</p><p>Then, there is PulseAudio, which is a modern desktop abstraction layer built on top of ALSA. It routes sound from various apps and tries to mix the audio streams so that the critial apps would not suffer from latency issues. Although PulseAudio brings many features that would not be possible with ALSA, like routing sound via internet, most musician apps don&rsquo;t use it.</p><p>They use <a href=https://jackaudio.org/>JACK Audio Connection Kit</a>. JACK was created for professional musicians and it cares about real-time playback, whereas PulseAudio was made for casual users who might tolerate some latency from their youtube playback. JACK connects audio apps with minimal latency, but keep in mind that it still works on top of ALSA, so if your app would be the only audio app running (i.e. if you are making a drum machine from an old Raspberry Pi) - then ALSA would be easier to use and would have a better performance.</p><p>Making a beeper function with ALSA is actually not so hard. We need to open the default audio device, configure it to use a well-supported sampling rate and sample format, and start writing data into it. Audio data can be a sawtooth wave, as described in the <a href=/posts/etude-in-c>previous audio article</a>.</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>beep</span><span class=p>(</span><span class=kt>int</span> <span class=n>freq</span><span class=p>,</span> <span class=kt>int</span> <span class=n>ms</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>static</span> <span class=kt>void</span> <span class=o>*</span><span class=n>pcm</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>pcm</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>snd_pcm_open</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pcm</span><span class=p>,</span> <span class=s>&#34;default&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=p>{</span>
      <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>snd_pcm_set_params</span><span class=p>(</span><span class=n>pcm</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>8000</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>20000</span><span class=p>);</span>
  <span class=p>}</span>
  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>2400</span><span class=p>];</span>
  <span class=kt>long</span> <span class=n>frames</span><span class=p>;</span>
  <span class=kt>long</span> <span class=n>phase</span><span class=p>;</span>
  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>ms</span> <span class=o>/</span> <span class=mi>50</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>snd_pcm_prepare</span><span class=p>(</span><span class=n>pcm</span><span class=p>);</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>buf</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>freq</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>?</span> <span class=p>(</span><span class=mi>255</span> <span class=o>*</span> <span class=n>j</span> <span class=o>*</span> <span class=n>freq</span> <span class=o>/</span> <span class=mi>8000</span><span class=p>)</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=kt>int</span> <span class=n>r</span> <span class=o>=</span> <span class=n>snd_pcm_writei</span><span class=p>(</span><span class=n>pcm</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>));</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>r</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>snd_pcm_recover</span><span class=p>(</span><span class=n>pcm</span><span class=p>,</span> <span class=n>r</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>Here we use synchronous API and we don&rsquo;t check for errors to keep the function small and simple. Synchronous blocking I/O is probably not the best option for serious audio applications, and fortunately ALSA comes with various transfer methods and various modes of operation: <a href=https://www.alsa-project.org/alsa-doc/alsa-lib/pcm.html>https://www.alsa-project.org/alsa-doc/alsa-lib/pcm.html</a>. But for our simple use case it&rsquo;s totally fine.</p><p><em>If in doubt - use ALSA; if you have to cooperate with other audio apps - use JACK.</em></p><h2 id=macos>macOS</h2><p>This one is rather <em>simple</em>, but not <em>easy</em> at all. MacOS has <a href=https://developer.apple.com/library/archive/documentation/MusicAudio/Conceptual/CoreAudioOverview/Introduction/Introduction.html>CoreAudio</a> framework, responsible for audio functionality on both, desktop and iOS. CoreAudio itself is a low-level API, tightly integrated with OS to optimize latency and performance. To play some sound with CoreAudio one would have to create an AudioUnit (audio plugin).</p><p>AudioUnit API is a little verbose, but easy to understand, here&rsquo;s how to create a new AudioUnit:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=n>AudioComponent</span> <span class=n>output</span><span class=p>;</span>
<span class=n>AudioUnit</span> <span class=n>unit</span><span class=p>;</span>
<span class=n>AudioComponentDescription</span> <span class=n>descr</span><span class=p>;</span>
<span class=n>AURenderCallbackStruct</span> <span class=n>cb</span><span class=p>;</span>
<span class=n>AudioStreamBasicDescription</span> <span class=n>stream</span><span class=p>;</span>

<span class=n>descr</span><span class=p>.</span><span class=n>componentType</span> <span class=o>=</span> <span class=n>kAudioUnitType_Output</span><span class=p>,</span>
<span class=n>descr</span><span class=p>.</span><span class=n>componentSubType</span> <span class=o>=</span> <span class=n>kAudioUnitSubType_DefaultOutput</span><span class=p>,</span>
<span class=n>descr</span><span class=p>.</span><span class=n>componentManufacturer</span> <span class=o>=</span> <span class=n>kAudioUnitManufacturer_Apple</span><span class=p>,</span>

<span class=c1>// Actual sound will be generated asynchronously in the callback tone_cb
</span><span class=c1></span><span class=n>cb</span><span class=p>.</span><span class=n>inputProc</span> <span class=o>=</span> <span class=n>tone_cb</span><span class=p>;</span>

<span class=n>stream</span><span class=p>.</span><span class=n>mFormatID</span> <span class=o>=</span> <span class=n>kAudioFormatLinearPCM</span><span class=p>;</span>
<span class=n>stream</span><span class=p>.</span><span class=n>mFormatFlags</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=n>stream</span><span class=p>.</span><span class=n>mSampleRate</span> <span class=o>=</span> <span class=mi>8000</span><span class=p>;</span>
<span class=n>stream</span><span class=p>.</span><span class=n>mBitsPerChannel</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
<span class=n>stream</span><span class=p>.</span><span class=n>mChannelsPerFrame</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
<span class=n>stream</span><span class=p>.</span><span class=n>mFramesPerPacket</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
<span class=n>stream</span><span class=p>.</span><span class=n>mBytesPerFrame</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
<span class=n>stream</span><span class=p>.</span><span class=n>mBytesPerPacket</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>

<span class=n>output</span> <span class=o>=</span> <span class=n>AudioComponentFindNext</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>descr</span><span class=p>);</span>
<span class=n>AudioComponentInstanceNew</span><span class=p>(</span><span class=n>output</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>unit</span><span class=p>);</span>
<span class=n>AudioUnitSetProperty</span><span class=p>(</span><span class=n>unit</span><span class=p>,</span> <span class=n>kAudioUnitProperty_SetRenderCallback</span><span class=p>,</span>
										 <span class=n>kAudioUnitScope_Input</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>cb</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>cb</span><span class=p>));</span>
<span class=n>AudioUnitSetProperty</span><span class=p>(</span><span class=n>unit</span><span class=p>,</span> <span class=n>kAudioUnitProperty_StreamFormat</span><span class=p>,</span>
										 <span class=n>kAudioUnitScope_Input</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stream</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>stream</span><span class=p>));</span>
<span class=n>AudioUnitInitialize</span><span class=p>(</span><span class=n>unit</span><span class=p>);</span>
<span class=n>AudioOutputUnitStart</span><span class=p>(</span><span class=n>unit</span><span class=p>);</span>
</code></pre></div><p>This code only creates and starts a new AudioUnit, the actual sound generation would happen asynchronously in the callback:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=n>OSStatus</span> <span class=nf>tone_cb</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>inRefCon</span><span class=p>,</span>
                        <span class=n>AudioUnitRenderActionFlags</span> <span class=o>*</span><span class=n>ioActionFlags</span><span class=p>,</span>
                        <span class=k>const</span> <span class=n>AudioTimeStamp</span> <span class=o>*</span><span class=n>inTimeStamp</span><span class=p>,</span> <span class=n>UInt32</span> <span class=n>inBusNumber</span><span class=p>,</span>
                        <span class=n>UInt32</span> <span class=n>inNumberFrames</span><span class=p>,</span> <span class=n>AudioBufferList</span> <span class=o>*</span><span class=n>ioData</span><span class=p>)</span> <span class=p>{</span>
  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>frame</span><span class=p>;</span>
  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span> <span class=o>=</span> <span class=n>ioData</span><span class=o>-&gt;</span><span class=n>mBuffers</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>mData</span><span class=p>;</span>
  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>inNumberFrames</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>beep_freq</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>?</span> <span class=p>(</span><span class=mi>255</span> <span class=o>*</span> <span class=n>theta</span> <span class=o>*</span> <span class=n>beep_freq</span> <span class=o>/</span> <span class=mi>8000</span><span class=p>)</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>theta</span><span class=o>++</span><span class=p>;</span>
    <span class=n>counter</span><span class=o>--</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>This callback generates sound similarly to how we did it with ALSA, but it is called asynchronously when CoreAudio thinks that audio buffer is almost empty and needs to be filled with new audio samples.</p><p>Such asynchronous approach to sound generation is very common, and almost every modern audio library supports it. If you want to build a music app - you should probably design it with asynchronous playback in mind.</p><p><em>If in doubt - use CoreAudio.</em></p><h2 id=sounds-like-too-much-work>Sounds like too much work</h2><p>If you are building a music app - you may follow the same path, implement audio backend for WASAPI, ALSA and CoreAudio. Actually it&rsquo;s not that hard. You may see the full sources of <a href=https://github.com/zserge/beep>beep</a>, it&rsquo;s roughly 100 lines of code for all three platforms.</p><p>However, there is a number of good cross-platform libraries, such as:</p><ul><li>RtAudio + RtMidi (very easy to use, a single .cpp and .h file).</li><li>PortAudio + PortMiidi (written in C and a bit larger), has tons of various backends.</li><li>SoundIO - <a href=https://github.com/andrewrk/libsoundio>https://github.com/andrewrk/libsoundio</a> - a wonderful little library from the creator of Zig.</li></ul><p>Some poeple prefer using JUCE for cross-platform audio apps, but it has its own limitations. Audio ecosystem may appear complex, and there are too many choices, but most of them are good ones. So keep playing!</p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href=https://github.com/zserge>Github</a>, <a href=https://twitter.com/zsergo>Twitter</a> or subscribe via <a href=/rss.xml>rss</a>.</p><p class=date style=text-align:right><em>Dec 13, 2020</em></p></div><footer><p>&copy;2012&ndash;2020 &#183;
<a href=https://zserge.com>Serge Zaitsev</a> &#183;
<a href=mailto:zaitsev.serge@gmail.com>zaitsev.serge@gmail.com</a></p></footer><script src=https://ajax.googleapis.com/ajax/libs/webfont/1.6.16/webfont.js></script><script>WebFontConfig={google:{families:['PT Serif','Roboto','Roboto Mono']}};(function(d){var wf=d.createElement('script'),s=d.scripts[0];wf.src='https://ajax.googleapis.com/ajax/libs/webfont/1.6.16/webfont.js';s.parentNode.insertBefore(wf,s);})(document);</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-33644825-1','zserge.com');ga('send','pageview');</script><script>new Image().src='https://nullitics.com/1.gif?r='+encodeURI(document.referrer)</script><noscript><img src=https://nullitics.com/foo.gif></noscript></body></html>