<!doctype html><html lang=en><head><meta charset=utf-8><title>Tiny Great Languages: Lisp</title><meta name=description content="???"><meta name=author content="Serge Zaitsev"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=data:,><link rel="shortcut icon" sizes=32x32 href=/favicon.png><link rel="shortcut icon" sizes=192x192 href=/favicon-192x192.png><link rel=apple-touch-icon href=/favicon-192x192.png><link rel=alternate type=application/rss+xml title=RSS href=/rss.xml><link rel=canonical href=https://zserge.com/posts/langs-lisp/><meta property="og:title" content="Tiny Great Languages: Lisp"><meta property="og:type" content="article"><meta property="og:url" content="https://zserge.com/posts/langs-lisp/"><meta property="og:image" content="https://zserge.com/logo.png"><meta property="og:description" content="???"><meta property="og:locale" content="en_US"><meta name=twitter:card content="???"><meta name=twitter:site content="@zsergo"><style type=text/css>body{padding:1rem;margin:auto;max-width:46rem;font-family:pt serif,Georgia,Cambria,times new roman,Times,serif;line-height:1.5;font-size:20px;color:rgba(0,0,0,.87);-webkit-font-smoothing:antialiased;font-weight:300}nav{display:flex;justify-content:space-between;align-items:center;margin:1em 0 3em}nav ul,nav li{display:inline-block;list-style:none;margin:0 0 0 .5rem;padding:0}nav ul{margin-right:1rem}.logo{background-color:rgba(0,0,0,.87);color:#fff;min-width:48px;min-height:48px;font-size:28px;border-radius:2px;display:flex;justify-content:center;align-items:center}.logo:hover{color:#fff}h1,h2{line-height:1.2;font-family:roboto,system-ui,segoe ui,Helvetica,Arial,sans-serif;font-weight:400;text-transform:uppercase;margin:1.34em 0 0}h1{font-size:1.95em}h2{font-size:1.25em;border-bottom:2px solid rgba(0,0,0,.87)}h1 a{color:rgba(0,0,0,.87)}p{margin:.67em 0 1em}a{color:#0076df;text-decoration:none;word-break:break-word}a:hover{color:rgba(0,0,0,.87)}ul,ol{list-style-position:outside;margin-left:1em}img{display:block;margin-left:auto;margin-right:auto;max-width:100%}pre,code{font-family:roboto mono,SFMono-Regular,Consolas,liberation mono,Menlo,monospace;font-weight:400;font-size:18px;color:rgba(0,0,0,.6);background:#eee}code{padding:.2rem .4rem;font-size:14px;border-radius:2px}pre{overflow-y:auto;line-height:20px;border-radius:2px;padding:1em}pre code{font-size:14px;padding:0;color:rgba(0,0,0,.87)}footer{font-size:12px}@media(prefers-color-scheme:dark){.logo{color:#444;background-color:#e4e4e4}.logo:hover{color:#444}body,h1 a,h2 a{background-color:#444;color:#e4e4e4}pre,pre code{background:#333;color:#e4e4e4}h2{border-bottom:1px solid #e4e4e4}code{color:#aaa;background:#333}a{color:#e39777}a:hover{color:#e4e4e4}img{filter:grayscale(30%)}}.hl{display:block;width:100%;background-color:#ffc}.ow,.gh,.gp,.gs,.gu,.nt,.nn,.ne,.ni,.nc,.kr,.kn,.kd,.kc,.k{font-weight:700}.c,.ch,.cm,.c1,.cs,.ge{color:#777}</style><link rel="shortcut icon" href=/favicon.ico></head><body><header><nav><a class=logo href=/>Z</a><ul><li><a href=/about/>about</a></li><li><a href=/posts/>posts</a></li><li><a href=https://mastodon.social/@zserge rel=me>@me</a></li><li><a href=https://github.com/zserge rel=me>&lt;/>me</a></li></ul></nav></header><div id=content><h1>Tiny Great Languages: Lisp</h1><p><em>This is part 4 from series &ldquo;Tiny Great Languages&rdquo;.</em></p><ul><li><em>Final code is on <a href=https://github.com/zserge/tinylangs>Github</a>.</em></li><li><em><a href=/posts/langs-asm/>Part 1: Assembly</a>.</em></li><li><em><a href=/posts/langs-basic/>Part 2: BASIC</a>.</em></li><li><em><a href=/posts/langs-mouse/>Part 3: Forth/MOUSE</a>.</em></li><li><em><a href=/posts/langs-lisp/>Part 4: Lisp</a>.</em></li></ul><p>Done with the concatenative language MOUSE, we can now turn our attention to another small and elegant language from way back: Lisp. Lisp is famous for its minimalist syntax (similar to Forth, the parser is almost nonexistent) and its clear, logical evaluation rules.</p><p>Created by John McCarthy in 1958, Lisp introduced ideas that forever changed how we think about programming. The language focused on recursion and symbolic computation, showing that with just a few operators and lambdas (anonymous functions), you can easily implement almost anything.</p><p>Interestingly, the original Lisp syntax wasn&rsquo;t the parentheses-heavy version we know today. It started with M-expressions: <code>car[cons[A,B]]</code>, which looks more like how modern languages call functions. However, <a href=https://en.wikipedia.org/wiki/S-expression>S-expressions</a> &ndash; a simpler and more uniform syntax &ndash; quickly took over. That&rsquo;s the Lisp syntax we use today, with all those parentheses.</p><p>S-expressions fit beautifully with Lisp’s core idea that &ldquo;code is data&rdquo;. In Lisp, everything follows the same structure and can be processed in the same way. This flexibility is why macros in Lisp can manipulate code just like any other data.</p><p>To build a Lisp, all you need is a parser for S-expressions and an <code>eval()</code> function to evaluate the resulting syntax tree (or list of lists).</p><h2 id=lisp-15>Lisp 1.5</h2><p>There is a famous reference from the Lisp 1.5 manual (page 13, for the curious) shows Lisp implemented in itself:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>apply[fn;x;a] =
     [atom[fn] -&gt; [eq[fn;CAR] -&gt; caar[x];
                  eq[fn;CDR] -&gt; cdar[x];
                  eq[fn;CONS] -&gt; cons[car[x];cadr[x]];
                  eq[fn;ATOM] -&gt; atom[car[x]];
                  eq[fn;EQ] -&gt; eq[car[x];cadr[x]];
                  T -&gt; apply[eval[fn;a];x;a]];
     eq[car[fn];LAMBDA] -&gt; eval[caddr[fn];pairlis[cadr[fn];x;a]];
     eq[car[fn];LABEL] -&gt; apply[caddr[fn];x;cons[cons[cadr[fn];
                               caddr[fn]];a]]]

eval[e;a] = [atom[e] -&gt; cdr[assoc[e;a]];
     atom[car[e]] -&gt;
      [eq[car[e],QUOTE] -&gt; cadr[e];
      eq[car[e];COND] -&gt; evcon[cdr[e];a];
      T -&gt; apply[car[e];evlis[cdr[e];a];a]];

evcon[c;a] = [eval[caar[c];a] -&gt; eval[cadar[c];a];
      T -&gt; evcon[cdr[c];a]]

evlis[m;a] = [null[m] -&gt; NIL;
      T -&gt; cons[eval[car[m];a];evlis[cdr[m];a]]]
</code></pre></div><p>It relies on a few basic primitives (CAR, CDR, CONS, ATOM, EQ) and leaves out all arithmetic operations (which we&rsquo;ll need for calculating factorials). Still, this structure is exactly what we need to start implementing a basic Lisp interpreter.</p><p>For our implementation, we&rsquo;ll use Python lists as the core data structure. While original Lisp used pairs to build lists, Python&rsquo;s built-in list utilities make it much easier (and save us a lot of time). We&rsquo;ll treat an empty list <code>[]</code> as <code>nil</code> and use the string &ldquo;t&rdquo; as our equivalent of True (it will be used as a quoted symbol <code>'t</code>).</p><p>Let’s start with the atom() primitive. In our Lisp, an atom is anything that isn’t a list (or is an empty list):</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>atom</span><span class=p>(</span><span class=n>x</span><span class=p>):</span> <span class=k>return</span> <span class=s2>&#34;t&#34;</span> <span class=k>if</span> <span class=nb>type</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>!=</span> <span class=nb>type</span><span class=p>([])</span> <span class=ow>or</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=k>else</span> <span class=p>[]</span>
</code></pre></div><p>We don’t need to explicitly define &ldquo;car&rdquo; and &ldquo;cdr&rdquo; functions—Python lets us access the first element of a list with <code>list[0]</code> and the rest of the list with <code>list[1:]</code>. Similarly, we can use Python’s native <code>==</code> for equality checks instead of defining &ldquo;eq&rdquo;. For &ldquo;cons&rdquo;, we’ll use Python’s <code>+</code> operator to concatenate lists.</p><p>This gives us enough to define the core apply function:</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>apply</span><span class=p>(</span><span class=n>f</span><span class=p>,</span> <span class=n>args</span><span class=p>,</span> <span class=n>L</span><span class=p>):</span>
    <span class=k>if</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;atom&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>atom</span><span class=p>(</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
    <span class=k>elif</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;car&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span>
    <span class=k>elif</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;cdr&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>1</span><span class=p>:]</span>
    <span class=k>elif</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;cons&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=p>[</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span> <span class=o>+</span> <span class=n>args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=k>elif</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;eq&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=s2>&#34;t&#34;</span> <span class=k>if</span> <span class=n>atom</span><span class=p>(</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=ow>and</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=k>else</span> <span class=p>[]</span>
    <span class=k>elif</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;+&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=k>elif</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;-&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=n>args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=k>elif</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;*&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=k>elif</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;/&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>/</span> <span class=n>args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=k>elif</span> <span class=n>f</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=s2>&#34;lambda&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=nb>eval</span><span class=p>(</span><span class=n>f</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>pairlis</span><span class=p>(</span><span class=n>f</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>args</span><span class=p>,</span> <span class=n>L</span><span class=p>))</span>
    <span class=k>else</span><span class=p>:</span> <span class=k>return</span> <span class=nb>apply</span><span class=p>(</span><span class=nb>eval</span><span class=p>(</span><span class=n>f</span><span class=p>,</span> <span class=n>L</span><span class=p>),</span> <span class=n>args</span><span class=p>,</span> <span class=n>L</span><span class=p>)</span>
</code></pre></div><p>Unlike <code>eval</code> that operates of special Lisp forms, apply merely executes functions. Atom checks if the argument is an atom, car returns the first element, cdr returns the rest, cons combines arguments into a list, eq checks for equality (two lists are never equal, only atoms can be compared like this). The goes arithmetics and finally we compute lambdas or fall back to a generic user function evaluation.</p><p>Lambdas in our Lisp have the following syntax:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>((lambda (x y z) (+ (+ x y) z)) 1 2 3)  ; returns 6
</code></pre></div><p>The lambda takes a list of parameters and a body. When evaluating a lambda, we substitute the parameters with their actual arguments in the current environment (without evaluating them yet). This is how <code>pairlis</code> does the substitution &ndash; it prepends pairs of (argument + value) to the environment list <code>L</code>:</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>pairlis</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>L</span><span class=p>):</span> <span class=k>return</span> <span class=n>L</span> <span class=k>if</span> <span class=ow>not</span> <span class=n>x</span> <span class=k>else</span> <span class=p>[[</span><span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>y</span><span class=p>[</span><span class=mi>0</span><span class=p>]]]</span> <span class=o>+</span> <span class=n>pairlis</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=n>y</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=n>L</span><span class=p>)</span>

<span class=n>pairlis</span><span class=p>([</span><span class=mi>3</span><span class=p>],</span> <span class=p>[</span><span class=mi>4</span><span class=p>],</span> <span class=p>[])</span>
<span class=c1># [[3, 4]]</span>

<span class=n>pairlis</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span> <span class=p>[</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>],</span> <span class=p>[[</span><span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>]])</span>
<span class=c1># [[1, 4], [2, 5], [3, 6], [7, 8]]</span>
</code></pre></div><p>Our environment would be holding variables (symbols) and their values in pairs and lookup would happen left-to-right. So if after <code>pairlis</code> a global variable is &ldquo;shadowed&rdquo; by the local parameter &ndash; it would be found first during the lookup.</p><p>Now we can implement <code>eval</code> and the rest of the interpreter:</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>evlis</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>L</span><span class=p>):</span> <span class=k>return</span> <span class=p>[</span><span class=nb>eval</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>L</span><span class=p>)]</span> <span class=o>+</span> <span class=n>evlis</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=n>L</span><span class=p>)</span> <span class=k>if</span> <span class=n>x</span> <span class=k>else</span> <span class=p>[]</span>

<span class=k>def</span> <span class=nf>evcon</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>L</span><span class=p>):</span> <span class=k>return</span> <span class=p>[]</span> <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=k>else</span> <span class=nb>eval</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>1</span><span class=p>],</span> <span class=n>L</span><span class=p>)</span> <span class=k>if</span> <span class=nb>eval</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>],</span> <span class=n>L</span><span class=p>)</span> <span class=k>else</span> <span class=n>evcon</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=n>L</span><span class=p>)</span>

<span class=k>def</span> <span class=nf>assoc</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>L</span><span class=p>):</span> <span class=k>return</span> <span class=p>[]</span> <span class=k>if</span> <span class=ow>not</span> <span class=n>L</span> <span class=k>else</span> <span class=n>L</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=k>if</span> <span class=n>L</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>x</span> <span class=k>else</span> <span class=n>assoc</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>L</span><span class=p>[</span><span class=mi>1</span><span class=p>:])</span>

<span class=k>def</span> <span class=nf>eval</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>L</span><span class=p>):</span>
    <span class=k>if</span> <span class=n>x</span> <span class=o>==</span> <span class=s2>&#34;nil&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=p>[]</span>
    <span class=k>elif</span> <span class=n>x</span> <span class=o>==</span> <span class=s2>&#34;t&#34;</span> <span class=ow>or</span> <span class=nb>type</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>==</span> <span class=nb>int</span><span class=p>:</span> <span class=k>return</span> <span class=n>x</span>
    <span class=k>elif</span> <span class=nb>type</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>==</span> <span class=nb>str</span><span class=p>:</span> <span class=k>return</span> <span class=n>assoc</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>L</span><span class=p>)</span>
    <span class=k>elif</span> <span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=s2>&#34;quote&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=k>elif</span> <span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=s2>&#34;cond&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>evcon</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=n>L</span><span class=p>)</span>
    <span class=k>elif</span> <span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=s2>&#34;label&#34;</span><span class=p>:</span> <span class=n>L</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=p>[</span><span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>x</span><span class=p>[</span><span class=mi>2</span><span class=p>]]);</span> <span class=k>return</span> <span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=k>else</span><span class=p>:</span> <span class=k>return</span> <span class=nb>apply</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>evlis</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=n>L</span><span class=p>),</span> <span class=n>L</span><span class=p>)</span>
</code></pre></div><p>Short and simple, <code>evlis</code> calls <code>eval</code> recursively for every element in the listand returns each computed value. This is needed to evaluate lambda parameters before calling it. Another helper is <code>evcon</code>, which looks up for a &ldquo;key&rdquo; in the list of pairs and evaluates the &ldquo;value&rdquo; part of it. This is required for <code>cond</code> form, which is analogous to <code>switch/case</code> in other languages. Last thing is <code>assoc</code> which retuns a value by the key without evaluating it. We need it to resolve symbols (variables) in the environments.</p><p>Putting it all together with a minimal parser - and we have a Lisp that can calculate factorials!</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>sys</span>
<span class=k>def</span> <span class=nf>lex</span><span class=p>(</span><span class=n>code</span><span class=p>):</span> <span class=k>return</span> <span class=n>code</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s2>&#34;(&#34;</span><span class=p>,</span> <span class=s2>&#34; ( &#34;</span><span class=p>)</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s2>&#34;)&#34;</span><span class=p>,</span> <span class=s2>&#34; ) &#34;</span><span class=p>)</span><span class=o>.</span><span class=n>split</span><span class=p>()</span>
<span class=k>def</span> <span class=nf>parse</span><span class=p>(</span><span class=n>tokens</span><span class=p>):</span>
    <span class=n>t</span> <span class=o>=</span> <span class=n>tokens</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>t</span> <span class=o>==</span> <span class=s2>&#34;(&#34;</span><span class=p>:</span>
        <span class=n>sexp</span> <span class=o>=</span> <span class=p>[]</span>
        <span class=k>while</span> <span class=n>tokens</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>!=</span> <span class=s2>&#34;)&#34;</span><span class=p>:</span> <span class=n>sexp</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>parse</span><span class=p>(</span><span class=n>tokens</span><span class=p>))</span>
        <span class=n>tokens</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>sexp</span>
    <span class=k>try</span><span class=p>:</span> <span class=k>return</span> <span class=nb>int</span><span class=p>(</span><span class=n>t</span><span class=p>)</span>
    <span class=k>except</span><span class=p>:</span> <span class=k>return</span> <span class=n>t</span>
<span class=k>def</span> <span class=nf>pairlis</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>L</span><span class=p>):</span> <span class=k>return</span> <span class=n>L</span> <span class=k>if</span> <span class=ow>not</span> <span class=n>x</span> <span class=k>else</span> <span class=p>[[</span><span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>y</span><span class=p>[</span><span class=mi>0</span><span class=p>]]]</span> <span class=o>+</span> <span class=n>pairlis</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=n>y</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=n>L</span><span class=p>)</span>
<span class=k>def</span> <span class=nf>assoc</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>L</span><span class=p>):</span> <span class=k>return</span> <span class=p>[]</span> <span class=k>if</span> <span class=ow>not</span> <span class=n>L</span> <span class=k>else</span> <span class=n>L</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=k>if</span> <span class=n>L</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>x</span> <span class=k>else</span> <span class=n>assoc</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>L</span><span class=p>[</span><span class=mi>1</span><span class=p>:])</span>
<span class=k>def</span> <span class=nf>atom</span><span class=p>(</span><span class=n>x</span><span class=p>):</span> <span class=k>return</span> <span class=s2>&#34;t&#34;</span> <span class=k>if</span> <span class=nb>type</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>!=</span> <span class=nb>type</span><span class=p>([])</span> <span class=ow>or</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=k>else</span> <span class=p>[]</span>
<span class=k>def</span> <span class=nf>apply</span><span class=p>(</span><span class=n>f</span><span class=p>,</span> <span class=n>args</span><span class=p>,</span> <span class=n>L</span><span class=p>):</span>
    <span class=k>if</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;atom&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>atom</span><span class=p>(</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
    <span class=k>elif</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;car&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span>
    <span class=k>elif</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;cdr&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>1</span><span class=p>:]</span>
    <span class=k>elif</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;cons&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=p>[</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span> <span class=o>+</span> <span class=n>args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=k>elif</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;eq&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=s2>&#34;t&#34;</span> <span class=k>if</span> <span class=n>atom</span><span class=p>(</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=ow>and</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=k>else</span> <span class=p>[]</span>
    <span class=k>elif</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;+&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=k>elif</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;-&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=n>args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=k>elif</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;*&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=k>elif</span> <span class=n>f</span> <span class=o>==</span> <span class=s2>&#34;/&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>/</span> <span class=n>args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=k>elif</span> <span class=n>f</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=s2>&#34;lambda&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=nb>eval</span><span class=p>(</span><span class=n>f</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>pairlis</span><span class=p>(</span><span class=n>f</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>args</span><span class=p>,</span> <span class=n>L</span><span class=p>))</span>
    <span class=k>else</span><span class=p>:</span> <span class=k>return</span> <span class=nb>apply</span><span class=p>(</span><span class=nb>eval</span><span class=p>(</span><span class=n>f</span><span class=p>,</span> <span class=n>L</span><span class=p>),</span> <span class=n>args</span><span class=p>,</span> <span class=n>L</span><span class=p>)</span>
<span class=k>def</span> <span class=nf>evcon</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>L</span><span class=p>):</span> <span class=k>return</span> <span class=p>[]</span> <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=k>else</span> <span class=nb>eval</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>1</span><span class=p>],</span> <span class=n>L</span><span class=p>)</span> <span class=k>if</span> <span class=nb>eval</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>],</span> <span class=n>L</span><span class=p>)</span> <span class=k>else</span> <span class=n>evcon</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=n>L</span><span class=p>)</span>
<span class=k>def</span> <span class=nf>evlis</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>L</span><span class=p>):</span> <span class=k>return</span> <span class=p>[</span><span class=nb>eval</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>L</span><span class=p>)]</span> <span class=o>+</span> <span class=n>evlis</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=n>L</span><span class=p>)</span> <span class=k>if</span> <span class=n>x</span> <span class=k>else</span> <span class=p>[]</span>
<span class=k>def</span> <span class=nf>eval</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>L</span><span class=p>):</span>
    <span class=k>if</span> <span class=n>x</span> <span class=o>==</span> <span class=s2>&#34;nil&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=p>[]</span>
    <span class=k>elif</span> <span class=n>x</span> <span class=o>==</span> <span class=s2>&#34;t&#34;</span> <span class=ow>or</span> <span class=nb>type</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>==</span> <span class=nb>int</span><span class=p>:</span> <span class=k>return</span> <span class=n>x</span>
    <span class=k>elif</span> <span class=nb>type</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>==</span> <span class=nb>str</span><span class=p>:</span> <span class=k>return</span> <span class=n>assoc</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>L</span><span class=p>)</span>
    <span class=k>elif</span> <span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=s2>&#34;quote&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=k>elif</span> <span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=s2>&#34;cond&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=n>evcon</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=n>L</span><span class=p>)</span>
    <span class=k>elif</span> <span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=s2>&#34;label&#34;</span><span class=p>:</span> <span class=n>L</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=p>[</span><span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>x</span><span class=p>[</span><span class=mi>2</span><span class=p>]]);</span> <span class=k>return</span> <span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=k>else</span><span class=p>:</span> <span class=k>return</span> <span class=nb>apply</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>evlis</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=n>L</span><span class=p>),</span> <span class=n>L</span><span class=p>)</span>

<span class=n>G</span> <span class=o>=</span> <span class=p>[]</span>
<span class=p>[</span><span class=k>print</span><span class=p>(</span><span class=nb>eval</span><span class=p>(</span><span class=n>parse</span><span class=p>(</span><span class=n>lex</span><span class=p>(</span><span class=n>line</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;;&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)[</span><span class=mi>0</span><span class=p>])),</span> <span class=n>G</span><span class=p>))</span> <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>sys</span><span class=o>.</span><span class=n>stdin</span> <span class=k>if</span> <span class=n>line</span><span class=o>.</span><span class=n>strip</span><span class=p>()]</span>
</code></pre></div><p>Out test factorial program (due to parsing limitation all top-level S-expressions must be one-liners):</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>(label fac (lambda (x) (cond ((eq x 0) 1) (1 (* x (fac (- x 1)))))))
(fac 1)
(fac 2)
(fac 3)
(fac 4)
(fac 5)
(fac 6)
(fac 7)
(fac 8)
(fac 9)
(fac 10)
</code></pre></div><p>It calculates factorials for each number from 1 to 10, and does it correctly!</p><p>For inspiration you may try yourself in implementing a Lisp in another language that has no garbage collector (which is an important part of a Lisp machine). Or implement a proper subset of Scheme, there are good implementations such as <a href=https://github.com/zpl-c/tinyscheme>TinyScheme</a> or <a href=https://github.com/melvinzhang/bit-scheme>Bit Scheme</a> to refer to.</p><p>In the next chapter we give further into the world of mathematics and look at the array processing languages, stay tuned!</p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href=https://github.com/zserge>Github</a>, <a href=https://mastodon.social/@zserge>Mastodon</a>, <a href=https://twitter.com/zsergo>Twitter</a> or subscribe via <a href=/rss.xml>rss</a>.</p><p class=date style=text-align:right><em>Sep 12, 2024</em></p><p>See also:
<a href=/posts/langs-mouse/>Tiny Great Languages: MOUSE</a> and <a href=/posts/>more</a>.</p></div><footer><p>&copy;2012&ndash;2023 &#183;
<a class=h-card rel=me href=https://zserge.com/>Serge Zaitsev</a> &#183;
<a href=mailto:hello@zserge.com rel=me>hello@zserge.com</a> &#183;
<a href=https://mastodon.social/@zserge rel=me>@zserge@mastodon.social</a></p></footer><script>new Image().src='https://nullitics.com/file.gif?u='+encodeURI(location.href)+'&r='+encodeURI(document.referrer)+'&d='+screen.width</script><noscript><img src=https://nullitics.com/file.gif></noscript></body></html>