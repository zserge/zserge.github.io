<!doctype html><html lang=en><head><meta charset=utf-8><title>Let&#39;s write a tiny chess engine in Go</title><meta name=description content="How to write a simple chess playing program in one day with a few lines of code"><meta name=author content="Serge Zaitsev"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel="shortcut icon" type=image/png href=/favicon.png><link rel=alternate type=application/rss+xml title=RSS href=/rss.xml><link rel=canonical href=https://zserge.com/posts/carnatus/><meta property=og:title content="Let's write a tiny chess engine in Go"><meta property=og:type content=article><meta property=og:url content=https://zserge.com/posts/carnatus/><meta property=og:image content=https://zserge.com/logo.png><meta property=og:description content="How to write a simple chess playing program in one day with a few lines of code"><meta property=og:locale content=en_US><meta name=twitter:card content="How to write a simple chess playing program in one day with a few lines of code"><meta name=twitter:site content=@zsergo><link href=/styles.css rel=stylesheet type=text/css><link rel="shortcut icon" href=/favicon.ico></head><body><header><nav><a class=logo href=/>Z</a></nav><div class=empty></div><nav><section><a href=/about/>about</a>
<a href=/posts/>posts</a></section><section><a href=https://twitter.com/zsergo>@me</a>
<a href=https://github.com/zserge>&lt;/&gt;me</a></section></nav></header><div id=content><h1>Let&#39;s write a tiny chess engine in Go</h1><p>In this article we will try to understand how chess engines work by porting the <a href=https://github.com/thomasahle/sunfish>sunfish</a> chess engine to Go. Sunfish is notable for its simplicity and small size, while still being capable of playing decent chess. Go is also known as a simple and highly readable language, so I hope the two of them could make a great couple.</p><p>To build a chess engine one has to decide on three important topics:</p><ul><li>How to represent the chess board (squares, pieces, valid moves).</li><li>How to evaluate the board (who is likely to win).</li><li>How to perform a search for the optimal move.</li></ul><p>The code snippets in this post are simplified and contain only most important parts of code. You may find the full code of the engine at <a href=https://github.com/zserge/carnatus>https://github.com/zserge/carnatus</a> (the name comes from latin species name of Gopher rockfish).</p><h2 id=squares-and-pieces>Squares and pieces</h2><p>It is important to find a convenient and memory-efficient board representation, because during the optimal move search thousands of boards would be kept in memory.</p><p>A board is typically represented as an array of squares. We would add some padding around the typical 8x8 board so that invalid piece moves would end up in this padding area. This allows us to avoid boundary checks and simplifies code a lot.</p><p>We will be using a linear array. The longest move distance that a chess piece can move is a knight move by 2 squares. Of course, other sliding pieces can move over longer distances, but such moves would be evaluated step by step, and board boundaries would be found sooner.</p><p>So, we need a 2 square padding around the board. We could create a 12x12 board, but as long as we represent it as a linear array - we only need 12x10 board, because the rightmost padding square from the previous row could also be used as the leftmost padding of the next row (× = padding):</p><pre><code>××××××××××
××××××××××
×........×
×........×
×........×
×........×
×........×
×........×
×........×
×........×
××××××××××
××××××××××
</code></pre><p>In our notation &ldquo;a1&rdquo; would be 9×10+1=91, and &ldquo;a8&rdquo; would be &ldquo;2×10+1&rdquo;=21.</p><p>Each cell in the board array would represent a playing piece, an empty square or padding. We could use numerical constants for those values, but to make it easier to debug - let&rsquo;s use human readable characters. Uppercase and lowercase letters would be pieces, white space would be padding and dots would be empty squares:</p><pre><code>          |
          |
 RNBQKBNR |
 PPPPPPPP |
 ........ |
 ........ |
 ........ | &lt;- this looks like a real chess board
 ........ |
 ........ |
 ........ |
 pppppppp |
 rnbkqbnr |
          |
          |
</code></pre><p>We can finally start writing code:</p><pre><code class=language-go>type Piece byte
func (p Piece) Value() int { ... }
func (p Piece) Ours() bool { ... }
func (p Piece) Flip() Piece { ... }

type Board [120]piece
func (b Board) Flip() Board { ... }

type Square int
func (s Square) Flip() Square { ... }
</code></pre><p>Pieces have values. We need those to estimate board positions and understand who is winning. Typically, a pawn = 100, knight = 280, bishop = 320, rook = 479, queen = 929 and king is some enormously large number that would be greater than 8 queens (pawns turned into queens) + pairs of knights, bishops and rooks. If we have all this wealth but lose the king - the estimation would still show that we will lose.</p><p>Each type has a Flip() method that returns the same value after the board is flipped before the opponent&rsquo;s move. For pieces this inverts the case of the piece symbol. For squares it returns 119-s (counting from the other end of the board). For whole boards is copies all pieces from the squares in the reverse order, flipping their case.</p><h2 id=move-generator>Move generator</h2><p>We have the building blocks and can now start thinking about the game position. Position is the board with pieces and some additional game state, such as en-passant square, king-passant square and castling options. If we wanted to simplify our chess game - we could probably just reuse the Board type, but here we will create a separate Position type, responsible for board moves and value estimation.</p><p>What is a move? It&rsquo;s a tuple of two squares - the square where the piece was before the move and the square where the piece has moved to. And position is a chess board with score, castling rules for each player and en-passant/king-passant squares. Both types also have a Flip() method for opponent&rsquo;s moves.</p><pre><code class=language-go>type Move struct {
  from Square
  to   Square
}
func (m Move) Flip() Move { ... }

type Position struct {
  board Board   // current board
  score int     // board score, the higher the better
  wc    [2]bool // white castling possibilities
  bc    [2]bool // black castling possibilities
  ep    Square  // en-passant square where pawn can be captured
  kp    Square  // king passent during castling, where kind can be captured
}
func (p Position) Flip() Position { ... }
</code></pre><p>We can now write our first big method - valid moves generator. We only care about the white pieces, because to play black we will be flipping the board and making the white move again.</p><p>To generate all valid moves we need to:</p><ul><li>Make a list of single-step moves in each direction for each piece</li><li>Iterate over all squares ignoring non-white pieces</li><li>For each white piece move into each valid direction</li><li>If a piece is not a crawling piece (not a pawn, nor a knight, nor a king) - keep moving until we meet an obstacle, such as opponent pieces or board padding.</li></ul><p>This is a simplified code that does not care about en-passant and castling. You may find the full implementation on <a href=https://github.com/zserge/carnatus>Github</a>, it&rsquo;s not much different.</p><p>To make direction arithmetics more readable we will be using directional constants N/E/S/W:</p><pre><code class=language-go>const N, E, S, W = -10, 1, 10, -1

var directions = map[Piece][]Square{
  'P': {N, N + N, N + W, N + E},
  'N': {N + N + E, E + N + E, E + S + E, S + S + E, S + S + W, W + S + W, W + N + W, N + N + W},
  'B': {N + E, S + E, S + W, N + W},
  'R': {N, E, S, W},
  'Q': {N, E, S, W, N + E, S + E, S + W, N + W},
  'K': {N, E, S, W, N + E, S + E, S + W, N + W},
}

func (pos Position) Moves() (moves []Move) {
  for index, p := range pos.board {
    if !p.ours() {
      continue
    }
    i := Square(index)
    for _, d := range directions[p] {
      for j := i + d; ; j = j + d {
        q := pos.board[j]
        if q == ' ' || (q != '.' &amp;&amp; q.ours()) {
          break
        }
        if p == 'P' {
          if (d == N || d == N+N) &amp;&amp; q != '.' {
            break
          }
          if d == N+N &amp;&amp; (i &lt; A1+N || pos.board[i+N] != '.') {
            break
          }
        }
        moves = append(moves, Move{from: i, to: j})
        if p == 'P' || p == 'N' || p == 'K' || (q != ' ' &amp;&amp; q != '.' &amp;&amp; !q.ours()) {
          break
        }
      }
    }
  }
  return moves
}
</code></pre><p>Yes, that&rsquo;s all the chess rules we need to consider to make valid moves. The next step would be to apply a move to the position to create the new game position. Without considering en-passant, pawn promotion and castling the method would look like this:</p><pre><code class=language-go>func (pos Position) Move(m Move) (np Position) {
  np = pos
  np.board[m.to] = pos.board[m.from]
  np.board[m.from] = '.'
  return np.Flip()
}
</code></pre><p>It simply moves the piece, mark the previous square as empty and flips the board. The full method implementation can be found on <a href=https://github.com/zserge/carnatus>Github</a>, it handles all special pawn and king moves correctly.</p><p>At this point we can play chess human-vs-human by controlling and making valid moves only. Or we can make a dumb chess engine that makes random moves until it loses.</p><p>But how to tell that we are losing?</p><h2 id=board-estimation>Board estimation</h2><p>Every board position has a score. Initially, the score is zero since both players are equal. When a move is made - it changes the score of the board, depending on what pieces were captured and how the pieces changed their positions on board.</p><p>In the simplest case, we can just count the pieces on board and sum up their values (minus the pieces of the opponent). This would tell us when the king is lost due to a checkmate. But this is a very poor estimation.</p><p>A much better, and surprisingly simple approach is to use <a href=https://www.chessprogramming.org/Piece-Square_Tables>piece-square tables (PST)</a>. For each piece we create a table, same size as our board, where for each square a matching value is assigned. These values are empirical, so I have simply stolen the PST values from sunfish engine.</p><p>In fact, better chess engines change the PST tables during the game because the
values of the pieces change over time (i.e. pawns get more valuable towards the
end of the game). But we will keep our engine simple.</p><p>To estimate the position after the move we need to:</p><ul><li>take current position score</li><li>subtract PST value of a piece being moved</li><li>add a new PST value</li><li>add piece value of a captured piece, if any</li></ul><p>Additionally, we need to adjust PST rook values during castling and pawn value during promotion or en-passant capture. But in this article I will omit that:</p><pre><code class=language-go>var pst = map[Piece][120]int{
  'P': { ... },
  'N': { ... },
  'B': { ... },
  'R': { ... },
  'Q': { ... },
  'K': { .... },
}

func (pos Position) value(m Move) int {
  i, j := m.from, m.to
  p, q := Piece(pos.board[i]), Piece(pos.board[j])
  // Adjust PST for the moving piece
  score := pst[p][j] - pst[p][i]
  if q != '.' &amp;&amp; q != ' ' &amp;&amp; !q.ours() {
    // Adjsut PST for captured piece
    score += pst[q.Flip()][j.Flip()]
  }
  return score
}
</code></pre><p>Now we can make a slightly better engine that chooses the best available move instead of a valid random one.</p><p>But real chess engines look deeper and analyze a tree of possible moves from
each side to find the best move in the longest perspective.</p><h2 id=search-algorithm>Search algorithm</h2><p>For toy chess engines the most popular search algorithm is depth-first search that starts from root and goes down to the given depth limit, iterating all possible moves before backtracking. For each possible move the value of the position is calculated using <a href=https://en.wikipedia.org/wiki/Minimax#Minimax_algorithm_with_alternate_moves>minimax</a> algorithm with <a href=https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning>alpha-beta pruning</a>.</p><p>Minimax is a rule used to minimize the worst-case potential loss - a player considers all of the best opponent moves, and selects the move such that the opponent&rsquo;s best strategy gives a score as large as possible.</p><p>Naive minimax would be too slow for chess as it would require iterating too many moves in depth to find a good one.</p><p>Alpha-beta pruning is used to speed up minimax by removing nodes not worth consider. An intuition behind A/B pruning is the following. Imagine you are playing chess and found a really good move A. You keep looking at the board and found an even better move B. But you look deeper and see that after move B the opponent will force checkmate you in a few moves. You will no longer consider move B at all and will not waste time on investigating other possible outcomes of move B.</p><p>Both minimax rule and A/B pruning are important to understand how chess engines work. Sunfish engine uses an improved <a href=http://people.csail.mit.edu/plaat/mtdf.html>MDF(f)</a> search algorithm, which is also a variant of a minimax algorithm with pruning.</p><p>In our engine we will gradually increase the search depth and call MDF(f) algorithm to find lower and upper bounds of the optimal score. The MDF(f) algorithm will be using A/B pruning iterations with transposition cache.</p><p>Transposition cache is a cache where for each board position we remember the depth, the score and the move that led us into this position. Later, when a new position is considered - it is first looked up in the transposition table.</p><p>I will not be posting the code of the search algorithm here, it&rsquo;s really just a few lines of recursive search, but you can always find the full sources of the chess engine on <a href=https://github.com/zserge/carnatus>github</a>.</p><h2 id=what-s-next>What&rsquo;s next</h2><p>If you are interested in small chess engines, I strongly recommend playing with sunfish. Also, sunfish was based on <a href=https://home.hccnet.nl/h.g.muller/max-src2.html>Micromax engine</a>, which has a wonderful documentation by his author, definitely worth reading.</p><p><img src=/images/chess.gif alt=chess></p><p>As for the current engine in Go - I&rsquo;ve added a tiny UCI protocol implementation so that one could use it with PyChess UI. It&rsquo;s still probably full of bugs and potential improvements, but it was an interesting path - from early thoughts about chess engine design to the real playable computer chess program.</p><p>Yes, it&rsquo;s weak, but it plays real chess!</p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href=https://github.com/zserge>Github</a>, <a href=https://twitter.com/zsergo>Twitter</a> or subscribe via <a href=/rss.xml>rss</a>.</p><p class=date style=text-align:right><em>Mar 21, 2020</em></p></div><footer><p>&copy;2012&ndash;2019 &middot;
<a href=https://zserge.com>Serge Zaitsev</a> &middot;
<a href=mailto:zaitsev.serge@gmail.com>zaitsev.serge@gmail.com</a></p></footer><script src=https://ajax.googleapis.com/ajax/libs/webfont/1.6.16/webfont.js></script><script>WebFontConfig={google:{families:['PT Serif','Roboto','Roboto Mono']}};(function(d){var wf=d.createElement('script'),s=d.scripts[0];wf.src='https://ajax.googleapis.com/ajax/libs/webfont/1.6.16/webfont.js';s.parentNode.insertBefore(wf,s);})(document);</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-33644825-1','zserge.com');ga('send','pageview');</script></body></html>