<!doctype html><html lang=en><head><meta charset=utf-8><title>Java agent - Bond or Smith?</title><meta name=description content="Writing a toy Java agent to monitor and modify the behavior of Java classes in runtime."><meta name=author content="Serge Zaitsev"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=data:,><link rel="shortcut icon" sizes=32x32 href=/favicon.png><link rel="shortcut icon" sizes=192x192 href=/favicon-192x192.png><link rel=apple-touch-icon href=/favicon-192x192.png><link rel=alternate type=application/rss+xml title=RSS href=/rss.xml><link rel=canonical href=https://zserge.com/posts/javaagent/><meta property="og:title" content="Java agent - Bond or Smith?"><meta property="og:type" content="article"><meta property="og:url" content="https://zserge.com/posts/javaagent/"><meta property="og:image" content="https://zserge.com/logo.png"><meta property="og:description" content="Writing a toy Java agent to monitor and modify the behavior of Java classes in runtime."><meta property="og:locale" content="en_US"><meta name=twitter:card content="Writing a toy Java agent to monitor and modify the behavior of Java classes in runtime."><meta name=twitter:site content="@zsergo"><style type=text/css>body{padding:1rem;margin:auto;max-width:46rem;font-family:pt serif,Georgia,Cambria,times new roman,Times,serif;line-height:1.5;font-size:20px;color:rgba(0,0,0,.87);-webkit-font-smoothing:antialiased;font-weight:300}nav{display:flex;justify-content:space-between;align-items:center;margin:1em 0 3em}nav ul,nav li{display:inline-block;list-style:none;margin:0 0 0 .5rem;padding:0}nav ul{margin-right:1rem}.logo{background-color:rgba(0,0,0,.87);color:#fff;min-width:48px;min-height:48px;font-size:28px;border-radius:2px;display:flex;justify-content:center;align-items:center}.logo:hover{color:#fff}h1,h2{line-height:1.2;font-family:roboto,system-ui,segoe ui,Helvetica,Arial,sans-serif;font-weight:400;text-transform:uppercase;margin:1.34em 0 0}h1{font-size:1.95em}h2{font-size:1.25em;border-bottom:2px solid rgba(0,0,0,.87)}h1 a{color:rgba(0,0,0,.87)}p{margin:.67em 0 1em}a{color:#0076df;text-decoration:none;word-break:break-word}a:hover{color:rgba(0,0,0,.87)}ul,ol{list-style-position:outside;margin-left:1em}img{display:block;margin-left:auto;margin-right:auto;max-width:100%}pre,code{font-family:roboto mono,SFMono-Regular,Consolas,liberation mono,Menlo,monospace;font-weight:400;font-size:18px;color:rgba(0,0,0,.6);background:#eee}code{padding:.2rem .4rem;font-size:14px;border-radius:2px}pre{overflow-y:auto;line-height:20px;border-radius:2px;padding:1em}pre code{font-size:14px;padding:0;color:rgba(0,0,0,.87)}footer{font-size:12px}@media(prefers-color-scheme:dark){.logo{color:#444;background-color:#e4e4e4}.logo:hover{color:#444}body,h1 a,h2 a{background-color:#444;color:#e4e4e4}pre,pre code{background:#333;color:#e4e4e4}h2{border-bottom:1px solid #e4e4e4}code{color:#aaa;background:#333}a{color:#e39777}a:hover{color:#e4e4e4}img{filter:grayscale(30%)}}.hl{display:block;width:100%;background-color:#ffc}.ow,.gh,.gp,.gs,.gu,.nt,.nn,.ne,.ni,.nc,.kr,.kn,.kd,.kc,.k{font-weight:700}.c,.ch,.cm,.c1,.cs,.ge{color:#777}</style><link rel="shortcut icon" href=/favicon.ico></head><body><header><nav><a class=logo href=/>Z</a><ul><li><a href=/about/>about</a></li><li><a href=/posts/>posts</a></li><li><a href=https://twitter.com/zsergo rel=me>@me</a></li><li><a href=https://github.com/zserge rel=me>&lt;/>me</a></li></ul></nav></header><div id=content><h1>Java agent - Bond or Smith?</h1><p>The previous post about <a href=/posts/jvm>JVM</a> turned out to be well-received, so I would like to uncover another fun topic related to JVM - Java agents. Although not everyone gets a chance to write custom Java agents in his career, they are still a wonderful field to explore and open an endless way to customize JVM behavior.</p><p>Java agents are special in the way that JVM allows them to do much more than a regular Java app is allowed to: they can instrument or profile code, hot-swap classes, patch methods, etc. This article will focus on pure Java agents, but it&rsquo;s worth mentioning that there are also JNI agents that are completely different and can do even more.</p><h2 id=our-first-agent>Our first agent</h2><p>Each agent has two possible entry points - <code>premain</code> and <code>agentmain</code> methods. They both have the same signature and take an argument string and an instrument object. The only difference between them is that <code>premain</code> is called when the agent is loaded before JVM starts and <code>agentmain</code> is called when the agent is attached to the running JVM later. We will be using <code>premain</code>:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kn>package</span> <span class=nn>com.github.zserge.toyjavaagent</span><span class=o>;</span>

<span class=kn>import</span> <span class=nn>java.lang.instrument.Instrumentation</span><span class=o>;</span>

<span class=kd>public</span> <span class=kd>class</span> <span class=nc>ToyAgent</span> <span class=o>{</span>
  <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>premain</span><span class=o>(</span><span class=n>String</span> <span class=n>args</span><span class=o>,</span> <span class=n>Instrumentation</span> <span class=n>inst</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Agent says hello.&#34;</span><span class=o>);</span>
  <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><p>Agents are bundled and loaded as JAR files with a special <code>manifest.mf</code>, pointing to a class which is an entry point. We will be using gradle to build our agent, and the <code>build.gradle</code> would look like this:</p><div class=highlight><pre class=chroma><code class=language-groovy data-lang=groovy><span class=n>plugins</span> <span class=o>{</span>
  <span class=n>id</span> <span class=s1>&#39;java&#39;</span>
<span class=o>}</span>

<span class=n>repositories</span> <span class=o>{</span>
  <span class=n>mavenCentral</span><span class=o>()</span>
<span class=o>}</span>

<span class=n>dependencies</span> <span class=o>{</span>
  <span class=n>compile</span> <span class=nl>group:</span> <span class=s1>&#39;org.ow2.asm&#39;</span><span class=o>,</span> <span class=nl>name:</span> <span class=s1>&#39;asm&#39;</span><span class=o>,</span> <span class=nl>version:</span> <span class=s1>&#39;8.0.1&#39;</span>
  <span class=n>testImplementation</span> <span class=s1>&#39;org.junit.jupiter:junit-jupiter-api:5.3.1&#39;</span>
  <span class=n>testRuntimeOnly</span> <span class=s1>&#39;org.junit.jupiter:junit-jupiter-engine:5.3.1&#39;</span>
<span class=o>}</span>

<span class=n>jar</span> <span class=o>{</span>
  <span class=n>from</span> <span class=o>{</span> <span class=n>configurations</span><span class=o>.</span><span class=na>compile</span><span class=o>.</span><span class=na>collect</span> <span class=o>{</span> <span class=n>it</span><span class=o>.</span><span class=na>isDirectory</span><span class=o>()</span> <span class=o>?</span> <span class=n>it</span> <span class=o>:</span> <span class=n>zipTree</span><span class=o>(</span><span class=n>it</span><span class=o>)</span> <span class=o>}</span> <span class=o>}</span>
  <span class=n>manifest</span> <span class=o>{</span>
    <span class=n>attributes</span> <span class=s1>&#39;Implementation-Title&#39;</span><span class=o>:</span> <span class=s1>&#39;toy-agent&#39;</span><span class=o>,</span>
               <span class=s1>&#39;Implementation-version&#39;</span><span class=o>:</span> <span class=s1>&#39;1.0&#39;</span><span class=o>,</span>
               <span class=s1>&#39;Premain-Class&#39;</span><span class=o>:</span> <span class=s1>&#39;com.github.zserge.toyjavaagent.ToyAgent&#39;</span><span class=o>,</span>
               <span class=s1>&#39;Can-Retransform-Classes&#39;</span><span class=o>:</span> <span class=s1>&#39;true&#39;</span>
  <span class=o>}</span>
<span class=o>}</span>

<span class=n>test</span> <span class=o>{</span>
  <span class=n>useJUnitPlatform</span><span class=o>()</span>
  <span class=n>jvmArgs</span> <span class=s1>&#39;-javaagent:&#39;</span> <span class=o>+</span> <span class=n>jar</span><span class=o>.</span><span class=na>archivePath</span>
<span class=o>}</span>
</code></pre></div><p>As you can see, java agents are not so different from regular java libraries. I have added <a href=https://asm.ow2.io/>ASM</a> dependency here because we will be messing up with Java bytecode later. JUnit5 is used for testing and the goal of this article is to see what our agent can do to our test classes. That is why in the test section we prepend <code>-javaagent</code> command line option so that our test code runner would load our agent.</p><p>The <code>jar</code> section requires the manifest to be created and it should tell the JVM where our main agent class is located (<code>ToyAgent</code>) and what our agent is allowed to do (for example, retransform or redefine classes).</p><p>In the src/test/java let&rsquo;s create a simple Example.java class that will be our guinea pig:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kn>import</span> <span class=nn>org.junit.jupiter.api.Test</span><span class=o>;</span>
<span class=kn>import static</span> <span class=nn>org.junit.jupiter.api.Assertions.assertEquals</span><span class=o>;</span>

<span class=kd>public</span> <span class=kd>class</span> <span class=nc>Example</span> <span class=o>{</span>
  <span class=kd>public</span> <span class=n>String</span> <span class=nf>getAgentName</span><span class=o>()</span> <span class=o>{</span>
    <span class=k>return</span> <span class=s>&#34;Bond&#34;</span><span class=o>;</span>
  <span class=o>}</span>
  <span class=kd>public</span> <span class=kt>int</span> <span class=nf>meaningOfLife</span><span class=o>()</span> <span class=o>{</span>
    <span class=k>return</span> <span class=n>42</span><span class=o>;</span>
  <span class=o>}</span>
  <span class=nd>@Test</span>
  <span class=kd>public</span> <span class=kt>void</span> <span class=nf>testAgent</span><span class=o>()</span> <span class=o>{</span>
    <span class=n>assertEquals</span><span class=o>(</span><span class=n>42</span><span class=o>,</span> <span class=n>meaningOfLife</span><span class=o>());</span>
    <span class=n>assertEquals</span><span class=o>(</span><span class=s>&#34;Smith&#34;</span><span class=o>,</span> <span class=n>getAgentName</span><span class=o>());</span>
  <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><p>If all goes well - you should see &ldquo;Agent says hello.&rdquo; output before the test fails because obviously, Smith is not Bond.</p><h2 id=messing-up-with-jvm>Messing up with JVM</h2><p>Not impressed? Let&rsquo;s fix the test by making <code>getAgentName()</code> return &ldquo;Smith&rdquo; without modifying test sources. It should be possible with Instrumentation API to a certain extent, but loading and patching class bytecode manually would be too obscure, so let&rsquo;s use ASM library instead. ASM is a very powerful tool to analyze and modify java classes in runtime, it&rsquo;s used by Gradle, Groovy, Kotlin, and even OpenJDK itself.</p><p>Let&rsquo;s add a class transformer that prints all loaded classes:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>premain</span><span class=o>(</span><span class=n>String</span> <span class=n>args</span><span class=o>,</span> <span class=n>Instrumentation</span> <span class=n>inst</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
  <span class=n>inst</span><span class=o>.</span><span class=na>addTransformer</span><span class=o>(</span><span class=k>new</span> <span class=n>ClassFileTransformer</span><span class=o>()</span> <span class=o>{</span>
      <span class=nd>@Override</span>
      <span class=kd>public</span> <span class=kt>byte</span><span class=o>[]</span> <span class=nf>transform</span><span class=o>(</span><span class=n>ClassLoader</span> <span class=n>loader</span><span class=o>,</span>
          <span class=n>String</span> <span class=n>name</span><span class=o>,</span> <span class=n>Class</span><span class=o>&lt;?&gt;</span> <span class=n>c</span><span class=o>,</span> <span class=n>ProtectionDomain</span> <span class=n>pd</span><span class=o>,</span>
          <span class=kt>byte</span><span class=o>[]</span> <span class=n>bytecode</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>IllegalClassFormatException</span> <span class=o>{</span>
        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;class &#34;</span> <span class=o>+</span> <span class=n>name</span><span class=o>);</span>
        <span class=k>return</span> <span class=n>bytecode</span><span class=o>;</span>
      <span class=o>}</span>
    <span class=o>});</span>
<span class=o>}</span>
</code></pre></div><p>If we run the test once again - we will see a big list of class names, and there will be &ldquo;Example&rdquo; among them. This is our test class and we will have to dive deeper, for example to visit and print all its methods:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>premain</span><span class=o>(</span><span class=n>String</span> <span class=n>args</span><span class=o>,</span> <span class=n>Instrumentation</span> <span class=n>inst</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
  <span class=n>inst</span><span class=o>.</span><span class=na>addTransformer</span><span class=o>(</span><span class=k>new</span> <span class=n>ClassFileTransformer</span><span class=o>()</span> <span class=o>{</span>
    <span class=nd>@Override</span>
    <span class=kd>public</span> <span class=kt>byte</span><span class=o>[]</span> <span class=nf>transform</span><span class=o>(</span><span class=n>ClassLoader</span> <span class=n>loader</span><span class=o>,</span>
        <span class=n>String</span> <span class=n>name</span><span class=o>,</span> <span class=n>Class</span><span class=o>&lt;?&gt;</span> <span class=n>c</span><span class=o>,</span> <span class=n>ProtectionDomain</span> <span class=n>pd</span><span class=o>,</span>
        <span class=kt>byte</span><span class=o>[]</span> <span class=n>bytecode</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>IllegalClassFormatException</span> <span class=o>{</span>
      <span class=k>if</span> <span class=o>(!</span><span class=n>name</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=s>&#34;Example&#34;</span><span class=o>))</span> <span class=o>{</span>
        <span class=c1>// Return original bytecode for other classes
</span><span class=c1></span>        <span class=k>return</span> <span class=n>bytecode</span><span class=o>;</span>
      <span class=o>}</span>
      <span class=c1>// Read Example class bytecode
</span><span class=c1></span>      <span class=n>ClassReader</span> <span class=n>cr</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ClassReader</span><span class=o>(</span><span class=n>bytecode</span><span class=o>);</span>
      <span class=n>ClassWriter</span> <span class=n>cw</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ClassWriter</span><span class=o>(</span><span class=n>ClassWriter</span><span class=o>.</span><span class=na>COMPUTE_FRAMES</span><span class=o>);</span>
      <span class=n>cr</span><span class=o>.</span><span class=na>accept</span><span class=o>(</span><span class=k>new</span> <span class=n>ClassVisitor</span><span class=o>(</span><span class=n>Opcodes</span><span class=o>.</span><span class=na>ASM5</span><span class=o>,</span> <span class=n>cw</span><span class=o>)</span> <span class=o>{</span>
        <span class=nd>@Override</span>
        <span class=kd>public</span> <span class=n>MethodVisitor</span> <span class=nf>visitMethod</span><span class=o>(</span><span class=kt>int</span> <span class=n>access</span><span class=o>,</span>
            <span class=n>String</span> <span class=n>methodName</span><span class=o>,</span> <span class=n>String</span> <span class=n>desc</span><span class=o>,</span>
            <span class=n>String</span> <span class=n>signature</span><span class=o>,</span> <span class=n>String</span><span class=o>[]</span> <span class=n>exceptions</span><span class=o>)</span> <span class=o>{</span>
          <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;visit: &#34;</span> <span class=o>+</span> <span class=n>name</span> <span class=o>+</span> <span class=s>&#34; &#34;</span> <span class=o>+</span> <span class=n>methodName</span><span class=o>);</span>
          <span class=k>return</span> <span class=kd>super</span><span class=o>.</span><span class=na>visitMethod</span><span class=o>(</span><span class=n>access</span><span class=o>,</span> <span class=n>methodName</span><span class=o>,</span> <span class=n>desc</span><span class=o>,</span>
              <span class=n>signature</span><span class=o>,</span> <span class=n>exceptions</span><span class=o>);</span>
        <span class=o>}</span>
      <span class=o>}</span>
    <span class=o>}</span>
  <span class=o>});</span>
<span class=o>}</span>
</code></pre></div><p>Running this would print out four methods of the Example class: &lt;init>, getAgentName, meaningOfLife, and testAgent.</p><h2 id=patching-bytecode>Patching bytecode</h2><p>If we want to modify the method - we would have to create a custom method visitor. In the method visitor, we go to the code section and insert the following instructions: LDC and ARETURN. LDC is used to push a string literal on top of the stack, and ARETURN is used to return the object from the top of the stack. Together they will change the getAgentName method to return &ldquo;Smith&rdquo; instead of &ldquo;Bond&rdquo;:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>MethodVisitor</span> <span class=n>v</span> <span class=o>=</span> <span class=n>cv</span><span class=o>.</span><span class=na>visitMethod</span><span class=o>(</span><span class=n>access</span><span class=o>,</span> <span class=n>methodName</span><span class=o>,</span> <span class=n>desc</span><span class=o>,</span> <span class=n>signature</span><span class=o>,</span> <span class=n>exceptions</span><span class=o>);</span>
<span class=n>v</span><span class=o>.</span><span class=na>visitCode</span><span class=o>();</span>
<span class=n>v</span><span class=o>.</span><span class=na>visitLdcInsn</span><span class=o>(</span><span class=s>&#34;Smith&#34;</span><span class=o>);</span>
<span class=n>v</span><span class=o>.</span><span class=na>visitInsn</span><span class=o>(</span><span class=n>Opcodes</span><span class=o>.</span><span class=na>ARETURN</span><span class=o>);</span>
<span class=n>v</span><span class=o>.</span><span class=na>visitEnd</span><span class=o>();</span>
<span class=k>return</span> <span class=n>v</span><span class=o>;</span>
</code></pre></div><p>Now, if we run the tests - we will see them passing, although in the source code the method still returns &ldquo;Bond&rdquo;. So, yes, agents can be evil and should be used with care.</p><p>Of course, we can go even further and do something useful, like tracing every single method as it is called. To achieve this we will need to insert something like:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Agent intercepted: &#34;</span> <span class=o>+</span> <span class=n>methodName</span><span class=o>);</span>
</code></pre></div><p>Or, in the terms of JVM instructions get &ldquo;out&rdquo; field, load constant string on stack and call &ldquo;println&rdquo; method:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>GETSTATIC     java/lang/System, out, Ljava/io/PrintStream;
LDC           &#34;Agent intercepted: ...&#34;
INVOKEVIRTUAL java/io/PrintStream, &#34;println&#34;, &#34;(Ljava/lang/String;)V&#34;
</code></pre></div><p>With ASM library our method visitor would be modified like this:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>v</span><span class=o>.</span><span class=na>visitFieldInsn</span><span class=o>(</span>
    <span class=n>Opcodes</span><span class=o>.</span><span class=na>GETSTATIC</span><span class=o>,</span> <span class=s>&#34;java/lang/System&#34;</span><span class=o>,</span> <span class=s>&#34;out&#34;</span><span class=o>,</span> <span class=s>&#34;Ljava/io/PrintStream;&#34;</span><span class=o>);</span>
<span class=n>v</span><span class=o>.</span><span class=na>visitLdcInsn</span><span class=o>(</span><span class=s>&#34;Agent intercepted:&#34;</span> <span class=o>+</span> <span class=n>method</span><span class=o>);</span>
<span class=n>v</span><span class=o>.</span><span class=na>visitMethodInsn</span><span class=o>(</span><span class=n>Opcodes</span><span class=o>.</span><span class=na>INVOKEVIRTUAL</span><span class=o>,</span> <span class=s>&#34;java/io/PrintStream&#34;</span><span class=o>,</span> <span class=s>&#34;println&#34;</span><span class=o>,</span>
    <span class=s>&#34;(Ljava/lang/String;)V&#34;</span><span class=o>,</span> <span class=kc>false</span><span class=o>);</span>
</code></pre></div><p>Running the test now shows that execution starts with &lt;init> which is an instance initialization (a constructor), the testAgent() is called, which calls meaningOfLife() and getAgentName().</p><p>The full code of our toy agent can be found on <a href=https://github.com/zserge/toy-java-agent>github</a>.</p><p>It can be further extended to measure the time spent on each method and get a basic profiler. Or to modify methods to restrict certain behavior, i.e. don&rsquo;t let executing certain commands via Runtime.execute. Another popular use case for java agents is to hide JVM code for proprietary tooling - Instana and NewRelic use java agents to monitor the code inside the JVM. Instana SDK comes only with a stub implementation of all the public classes, and the actual bytecode is loaded only in runtime, which makes it harder to debug, but on the other hand, makes reverse engineering significantly harder.</p><p>So, agents can be good and agents can be evil. But knowing and understanding how they work is never a bad thing.</p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href=https://github.com/zserge>Github</a>, <a href=https://twitter.com/zsergo>Twitter</a> or subscribe via <a href=/rss.xml>rss</a>.</p><p class=date style=text-align:right><em>Jun 06, 2020</em></p><p>See also:
<a href=/posts/jvm/>How to write a (toy) JVM</a> and <a href=/posts/>more</a>.</p></div><footer><p>&copy;2012&ndash;2021 &#183;
<a href=https://zserge.com>Serge Zaitsev</a> &#183;
<a href=mailto:hello@zserge.com rel=me>hello@zserge.com</a></p></footer><script>(function(e,t,n,i,s,a,c){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)};a=t.createElement(i);c=t.getElementsByTagName(i)[0];a.async=true;a.src=s;c.parentNode.insertBefore(a,c)})(window,document,"galite","script","https://cdn.jsdelivr.net/npm/ga-lite@2/dist/ga-lite.min.js");galite('create','UA-33644825-1','auto');galite('send','pageview');</script><script>new Image().src='https://nullitics.com/file.gif?u='+encodeURI(location.href)+'&r='+encodeURI(document.referrer)+'&d='+screen.width</script><noscript><img src=https://nullitics.com/file.gif></noscript></body></html>