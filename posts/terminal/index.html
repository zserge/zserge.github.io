<!doctype html><html lang=en><head><meta charset=utf-8><title>How to configure zsh</title><meta name=description content="A brief tutorial on how to make your terminal environment look modern but is still remain very minimal and performant."><meta name=author content="Serge Zaitsev"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=data:,><link rel="shortcut icon" sizes=32x32 href=/favicon.png><link rel="shortcut icon" sizes=192x192 href=/favicon-192x192.png><link rel=apple-touch-icon href=/favicon-192x192.png><link rel=alternate type=application/rss+xml title=RSS href=/rss.xml><link rel=canonical href=https://zserge.com/posts/terminal/><meta property="og:title" content="How to configure zsh"><meta property="og:type" content="article"><meta property="og:url" content="https://zserge.com/posts/terminal/"><meta property="og:image" content="https://zserge.com/logo.png"><meta property="og:description" content="A brief tutorial on how to make your terminal environment look modern but is still remain very minimal and performant."><meta property="og:locale" content="en_US"><meta name=twitter:card content="A brief tutorial on how to make your terminal environment look modern but is still remain very minimal and performant."><meta name=twitter:site content="@zsergo"><style type=text/css>body{padding:1rem;margin:auto;max-width:46rem;font-family:pt serif,Georgia,Cambria,times new roman,Times,serif;line-height:1.5;font-size:20px;color:rgba(0,0,0,.87);-webkit-font-smoothing:antialiased;font-weight:300}nav{display:flex;justify-content:space-between;align-items:center;margin:1em 0 3em}nav ul,nav li{display:inline-block;list-style:none;margin:0 0 0 .5rem;padding:0}nav ul{margin-right:1rem}.logo{background-color:rgba(0,0,0,.87);color:#fff;min-width:48px;min-height:48px;font-size:28px;border-radius:2px;display:flex;justify-content:center;align-items:center}.logo:hover{color:#fff}h1,h2{line-height:1.2;font-family:roboto,system-ui,segoe ui,Helvetica,Arial,sans-serif;font-weight:400;text-transform:uppercase;margin:1.34em 0 0}h1{font-size:1.95em}h2{font-size:1.25em;border-bottom:2px solid rgba(0,0,0,.87)}h1 a{color:rgba(0,0,0,.87)}p{margin:.67em 0 1em}a{color:#0076df;text-decoration:none;word-break:break-word}a:hover{color:rgba(0,0,0,.87)}ul,ol{list-style-position:outside;margin-left:1em}img{display:block;margin-left:auto;margin-right:auto;max-width:100%}pre,code{font-family:roboto mono,SFMono-Regular,Consolas,liberation mono,Menlo,monospace;font-weight:400;font-size:18px;color:rgba(0,0,0,.6);background:#eee}code{padding:.2rem .4rem;font-size:14px;border-radius:2px}pre{overflow-y:auto;line-height:20px;border-radius:2px;padding:1em}pre code{font-size:14px;padding:0;color:rgba(0,0,0,.87)}footer{font-size:12px}@media(prefers-color-scheme:dark){.logo{color:#444;background-color:#e4e4e4}.logo:hover{color:#444}body,h1 a,h2 a{background-color:#444;color:#e4e4e4}pre,pre code{background:#333;color:#e4e4e4}h2{border-bottom:1px solid #e4e4e4}code{color:#aaa;background:#333}a{color:#e39777}a:hover{color:#e4e4e4}img{filter:grayscale(30%)}}.hl{display:block;width:100%;background-color:#ffc}.ow,.gh,.gp,.gs,.gu,.nt,.nn,.ne,.ni,.nc,.kr,.kn,.kd,.kc,.k{font-weight:700}.c,.ch,.cm,.c1,.cs,.ge{color:#777}</style><link rel="shortcut icon" href=/favicon.ico></head><body><header><nav><a class=logo href=/>Z</a><ul><li><a href=/about/>about</a></li><li><a href=/posts/>posts</a></li><li><a href=https://mastodon.social/@zserge rel=me>@me</a></li><li><a href=https://github.com/zserge rel=me>&lt;/>me</a></li></ul></nav></header><div id=content><h1>How to configure zsh</h1><p>Over the years of using Linux as my primary and only OS I had to embrace some
unavoidable facts. First, things tend to change and complex things tend to
break. Second, reinventing the wheel almost never pays off. And finally, it&rsquo;s
not that hard to make a new habit and sometimes it&rsquo;s better than adjusting your
workstation to your &ldquo;intuitive&rdquo; understanding that may change very soon.</p><p>So years ago I decided to only use the most common software and only the very
minimal personalized configuration on top of it.</p><p>I mostly need two applications, no matter what OS or desktop environment I run</p><ul><li>a terminal and a web browser.</li></ul><h2 id=terminal>Terminal</h2><p>This is the only GUI app you actually need if you work as a developer. Whether
you edit sources, debug, read Hacker News, answer your emails, chat, listen to
music - most of the time you will be staring into this utterly boring window of
your terminal. So let&rsquo;s make it work fast and look good.</p><p>In terms of <a href=https://lwn.net/Articles/751763/>performance</a> there are two primary choices here: <a href=http://invisible-island.net/xterm/>xterm</a> and
<a href=https://st.suckless.org/>st</a>. Both are very small and lightweight, <code>xterm</code> comes with X server by
default, <code>st</code> needs to be compiled manually, but since you are a developer that
should not scare you.</p><p>I will go with <code>xterm</code> here, but I have also been using <code>st</code> for many years and
have absolutely no regrets about it.</p><p>As for the visual aesthetics, there&rsquo;s not much UI in the terminal - it&rsquo;s a
rectangle with monospace text after all. You can adjust colors and you can
adjust the font.</p><p>Adjusting colors is now easier than ever. There is a special <a href=https://terminal.sexy>web
page</a> where you can find a ready-to-use color scheme, see it in
action and copy the configuration into <code>~/.Xresources</code>. I ended up using
&ldquo;Eighties&rdquo; theme, and it seems to be popular these days. Solarized or Molokai
are also good alternatives.</p><p>On Ubuntu there might be a catch that generated configuration snippet uses
<code>*.color0</code> wildcard, while the way Ubuntu loads <code>.Xresources</code> requires you to
replace it with <code>XTerm.vt100.color0</code>. Fortunately, this can be easily done in
almost any text editor.</p><p>For the fonts I find Roboto Mono and Ubuntu Mono fairly good, but you may have
a different taste.</p><p>My resulting <code>.Xresources</code> looks like this (it only tweaks font rendering, sets
font and colors, and allows Alt key to be used in Tmux or vim shortcuts):</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>Xft.rgba: rgb
XTerm.termName: xterm-256color
XTerm.vt100.faceName: Roboto Mono Regular:size=10
XTerm.vt100.metaSendsEscape: true
XTerm.vt100.foreground:   #d3d0c8
XTerm.vt100.background:   #2d2d2d
XTerm.vt100.cursorColor:  #d3d0c8
XTerm.vt100.color0:       #2d2d2d
XTerm.vt100.color8:       #747369
XTerm.vt100.color1:       #f2777a
XTerm.vt100.color9:       #f2777a
XTerm.vt100.color2:       #99cc99
XTerm.vt100.color10:      #99cc99
XTerm.vt100.color3:       #ffcc66
XTerm.vt100.color11:      #ffcc66
XTerm.vt100.color4:       #6699cc
XTerm.vt100.color12:      #6699cc
XTerm.vt100.color5:       #cc99cc
XTerm.vt100.color13:      #cc99cc
XTerm.vt100.color6:       #66cccc
XTerm.vt100.color14:      #66cccc
XTerm.vt100.color7:       #d3d0c8
XTerm.vt100.color15:      #f2f0ec
</code></pre></div><p>To make xterm my default terminal that is launched on Ctrl+Alt+T I had to run:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>gsettings set org.gnome.desktop.default-applications.terminal exec &#39;xterm&#39;
</code></pre></div><p>I also have made the following <code>~/.local/share/applications/xterm.desktop</code> file
to replace the unbearable XTerm icon:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>[Desktop Entry]
Name=xterm
Comment=Use the command line
Exec=/usr/bin/xterm
Icon=utilities-terminal
Type=Application
Categories=GNOME;GTK;Utility;TerminalEmulator;
StartupNotify=true
OnlyShowIn=GNOME;Unity;
Keywords=Run;
Actions=New

[Desktop Action New]
Name=New Terminal
Exec=/usr/bin/xterm
OnlyShowIn=Unity
</code></pre></div><p>Reboot (or log out + log in) to apply the new configuration and your terminal
is good to do.</p><h2 id=zsh>zsh</h2><p>UNIX Shell is my primary user interface to everything. And despite <code>fish</code> is
really cool and modern, or <code>rc</code> is so simple and nicely implemented, I tend to
stick to Bash or Zsh.</p><p>I&rsquo;m still looking at backporting my zsh config to bash, but at the moment I&rsquo;m a
Zsh user. Zsh is more user-friendly and more advanced, but it&rsquo;s never the
default shell and it also can be slow. For example, there is a wonderful
<a href=http://ohmyz.sh/>oh-my-zsh</a> project that allows you to build zsh config from the pieces, but
it&rsquo;s not uncommon when the shell start up time raises to 3 seconds or even
slower.</p><p>I try to keep my <code>.zshrc</code> as small as possible. I am using only 3 zsh modules</p><ul><li>autocompletion, colors and VCS info:</li></ul><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>autoload -U compinit colors vcs_info
colors
compinit
</code></pre></div><p>Then I set up general zsh options and history:</p><p>I like when my shell keeps a lot of history. I also want to remember only one
line for each command and ignore certain commands that I prefix with a
whitespace (Bash can do it, too, so I&rsquo;d better make a habit to put a whitespace
than set up complex shell rules for that). Finally, I want zsh to correct my
typos.</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash><span class=c1># Report command running time if it is more than 3 seconds</span>
<span class=nv>REPORTTIME</span><span class=o>=</span><span class=m>3</span>
<span class=c1># Keep a lot of history</span>
<span class=nv>HISTFILE</span><span class=o>=</span>~/.zhistory
<span class=nv>HISTSIZE</span><span class=o>=</span><span class=m>5000</span>
<span class=nv>SAVEHIST</span><span class=o>=</span><span class=m>5000</span>
<span class=c1># Add commands to history as they are entered, don&#39;t wait for shell to exit</span>
setopt INC_APPEND_HISTORY
<span class=c1># Also remember command start time and duration</span>
setopt EXTENDED_HISTORY
<span class=c1># Do not keep duplicate commands in history</span>
setopt HIST_IGNORE_ALL_DUPS
<span class=c1># Do not remember commands that start with a whitespace</span>
setopt HIST_IGNORE_SPACE
<span class=c1># Correct spelling of all arguments in the command line</span>
setopt CORRECT_ALL
<span class=c1># Enable autocompletion</span>
zstyle <span class=s1>&#39;:completion:*&#39;</span> completer _complete _correct _approximate 
</code></pre></div><p>The next thing to set up is shell prompt.</p><h2 id=propmt>propmt</h2><p>Shell prompt should be concise and informative. I believe that colors and
unicode symbols are the way to go.</p><p>A good example for inspiration are <a href=https://github.com/sindresorhus/pure>pure</a> and <a href=https://github.com/geometry-zsh/geometry>geometry</a> themes.</p><p>I wanted my prompt to display:</p><ul><li>current working directory</li><li>superuser flag</li><li>whether last command exit status was zero or non</li><li>vi mode (I use vim keybindings in the shell)</li><li>git branch, staged and unstaged files (only if directory is a git repo)</li></ul><div class=highlight><pre class=chroma><code class=language-zsh data-lang=zsh>zstyle <span class=s1>&#39;:vcs_info:*&#39;</span> stagedstr <span class=s1>&#39;%F{green}●%f &#39;</span>
zstyle <span class=s1>&#39;:vcs_info:*&#39;</span> unstagedstr <span class=s1>&#39;%F{yellow}●%f &#39;</span>
zstyle <span class=s1>&#39;:vcs_info:git:*&#39;</span> check-for-changes <span class=nb>true</span>
zstyle <span class=s1>&#39;:vcs_info:git*&#39;</span> formats <span class=s2>&#34;%F{blue}%b%f %u%c&#34;</span>

_setup_ps1<span class=o>()</span> <span class=o>{</span>
  vcs_info
  <span class=nv>GLYPH</span><span class=o>=</span><span class=s2>&#34;▲&#34;</span>
  <span class=o>[</span> <span class=s2>&#34;x</span><span class=nv>$KEYMAP</span><span class=s2>&#34;</span> <span class=o>=</span> <span class=s2>&#34;xvicmd&#34;</span> <span class=o>]</span> <span class=o>&amp;&amp;</span> <span class=nv>GLYPH</span><span class=o>=</span><span class=s2>&#34;▼&#34;</span>
  <span class=nv>PS1</span><span class=o>=</span><span class=s2>&#34; %(?.%F{blue}.%F{red})</span><span class=nv>$GLYPH</span><span class=s2>%f %(1j.%F{cyan}[%j]%f .)%F{blue}%~%f %(!.%F{red}#%f .)&#34;</span>
  <span class=nv>RPROMPT</span><span class=o>=</span><span class=s2>&#34;</span><span class=nv>$vcs_info_msg_0_</span><span class=s2>&#34;</span>
<span class=o>}</span>
_setup_ps1

<span class=c1># Vi mode</span>
zle-keymap-select <span class=o>()</span> <span class=o>{</span>
 _setup_ps1
  zle reset-prompt
<span class=o>}</span>
zle -N zle-keymap-select
zle-line-init <span class=o>()</span> <span class=o>{</span>
  zle -K viins
<span class=o>}</span>
zle -N zle-line-init
bindkey -v
</code></pre></div><p>I use vcsinfo module to provide information about git repos (as well as hg,
svn, csv as a bonus). I use <code>bindkey -v</code> to enable vi editing mode. I dropped
in a few functions to start with insert mode by default and to re-evaluate
prompt on each command.</p><p>This gives me a very minimal prompt that looks like this:</p><p><img src=/images/xterm.png alt=xterm></p><h2 id=minor-notes>minor notes</h2><p>I also have a few more lines in my zshrc that bind/fix common keys for
home/end/delete. And I also added one and only alias to have colored output in <code>ls</code>:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash><span class=c1># Common emacs bindings for vi mode</span>
bindkey <span class=s1>&#39;\e[3~&#39;</span>   delete-char
bindkey <span class=s1>&#39;^A&#39;</span>      beginning-of-line
bindkey <span class=s1>&#39;^E&#39;</span>      end-of-line
bindkey <span class=s1>&#39;^R&#39;</span>      history-incremental-pattern-search-backward
<span class=c1># Tmux home/end</span>
bindkey <span class=s1>&#39;\e[1~&#39;</span>      beginning-of-line
bindkey <span class=s1>&#39;\e[4~&#39;</span>      end-of-line
<span class=c1># Urxvt</span>
bindkey <span class=s1>&#39;\e[7~&#39;</span>      beginning-of-line
bindkey <span class=s1>&#39;\e[8~&#39;</span>      end-of-line
<span class=c1># user-friendly command output</span>
<span class=nb>export</span> <span class=nv>CLICOLOR</span><span class=o>=</span><span class=m>1</span>
ls --color<span class=o>=</span>auto <span class=p>&amp;</span>&gt; /dev/null <span class=o>&amp;&amp;</span> <span class=nb>alias</span> <span class=nv>ls</span><span class=o>=</span><span class=s1>&#39;ls --color=auto&#39;</span>
</code></pre></div><p>You can see the full contents of zshrc here:
<a href=https://gist.github.com/zserge/1a315df99f5e7aed36d6ef0852eb18f1>https://gist.github.com/zserge/1a315df99f5e7aed36d6ef0852eb18f1</a></p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href=https://github.com/zserge>Github</a>, <a href=https://mastodon.social/@zserge>Mastodon</a>, <a href=https://twitter.com/zsergo>Twitter</a> or subscribe via <a href=/rss.xml>rss</a>.</p><p class=date style=text-align:right><em>May 07, 2018</em></p></div><footer><p>&copy;2012&ndash;2025 &#183;
<a class=h-card rel=me href=https://zserge.com/>Serge Zaitsev</a> &#183;
<a href=mailto:hello@zserge.com rel=me>hello@zserge.com</a> &#183;
<a href=https://mastodon.social/@zserge rel=me>@zserge@mastodon.social</a></p></footer><script>new Image().src='https://nullitics.com/file.gif?u='+encodeURI(location.href)+'&r='+encodeURI(document.referrer)+'&d='+screen.width</script><noscript><img src=https://nullitics.com/file.gif></noscript></body></html>