<!doctype html><html lang=en><head><meta charset=utf-8><title>Ray tracer for those who skipped the math class</title><meta name=description content="A tiny ray tracer, only useful for people who never written one themselves, but would like to. It lacks features, but provides a foundation to build your own, featureful ray tracer upon."><meta name=author content="Serge Zaitsev"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=data:,><link rel="shortcut icon" sizes=32x32 href=/favicon.png><link rel="shortcut icon" sizes=192x192 href=/favicon-192x192.png><link rel=apple-touch-icon href=/favicon-192x192.png><link rel=alternate type=application/rss+xml title=RSS href=/rss.xml><link rel=canonical href=https://zserge.com/posts/raytracer/><meta property="og:title" content="Ray tracer for those who skipped the math class"><meta property="og:type" content="article"><meta property="og:url" content="https://zserge.com/posts/raytracer/"><meta property="og:image" content="https://zserge.com/logo.png"><meta property="og:description" content="A tiny ray tracer, only useful for people who never written one themselves, but would like to. It lacks features, but provides a foundation to build your own, featureful ray tracer upon."><meta property="og:locale" content="en_US"><meta name=twitter:card content="A tiny ray tracer, only useful for people who never written one themselves, but would like to. It lacks features, but provides a foundation to build your own, featureful ray tracer upon."><meta name=twitter:site content="@zsergo"><style type=text/css>body{padding:1rem;margin:auto;max-width:46rem;font-family:pt serif,Georgia,Cambria,times new roman,Times,serif;line-height:1.5;font-size:20px;color:rgba(0,0,0,.87);-webkit-font-smoothing:antialiased;font-weight:300}nav{display:flex;justify-content:space-between;align-items:center;margin:1em 0 3em}nav ul,nav li{display:inline-block;list-style:none;margin:0 0 0 .5rem;padding:0}nav ul{margin-right:1rem}.logo{background-color:rgba(0,0,0,.87);color:#fff;min-width:48px;min-height:48px;font-size:28px;border-radius:2px;display:flex;justify-content:center;align-items:center}.logo:hover{color:#fff}h1,h2{line-height:1.2;font-family:roboto,system-ui,segoe ui,Helvetica,Arial,sans-serif;font-weight:400;text-transform:uppercase;margin:1.34em 0 0}h1{font-size:1.95em}h2{font-size:1.25em;border-bottom:2px solid rgba(0,0,0,.87)}h1 a{color:rgba(0,0,0,.87)}p{margin:.67em 0 1em}a{color:#0076df;text-decoration:none;word-break:break-word}a:hover{color:rgba(0,0,0,.87)}ul,ol{list-style-position:outside;margin-left:1em}img{display:block;margin-left:auto;margin-right:auto;max-width:100%}pre,code{font-family:roboto mono,SFMono-Regular,Consolas,liberation mono,Menlo,monospace;font-weight:400;font-size:18px;color:rgba(0,0,0,.6);background:#eee}code{padding:.2rem .4rem;font-size:14px;border-radius:2px}pre{overflow-y:auto;line-height:20px;border-radius:2px;padding:1em}pre code{font-size:14px;padding:0;color:rgba(0,0,0,.87)}footer{font-size:12px}@media(prefers-color-scheme:dark){.logo{color:#444;background-color:#e4e4e4}.logo:hover{color:#444}body,h1 a,h2 a{background-color:#444;color:#e4e4e4}pre,pre code{background:#333;color:#e4e4e4}h2{border-bottom:1px solid #e4e4e4}code{color:#aaa;background:#333}a{color:#e39777}a:hover{color:#e4e4e4}img{filter:grayscale(30%)}}.hl{display:block;width:100%;background-color:#ffc}.ow,.gh,.gp,.gs,.gu,.nt,.nn,.ne,.ni,.nc,.kr,.kn,.kd,.kc,.k{font-weight:700}.c,.ch,.cm,.c1,.cs,.ge{color:#777}</style><link rel="shortcut icon" href=/favicon.ico></head><body><header><nav><a class=logo href=/>Z</a><ul><li><a href=/about/>about</a></li><li><a href=/posts/>posts</a></li><li><a href=https://twitter.com/zsergo rel=me>@me</a></li><li><a href=https://github.com/zserge rel=me>&lt;/>me</a></li></ul></nav></header><div id=content><h1>Ray tracer for those who skipped the math class</h1><p>There is a strong belief that every programmer in their life must write a ray tracer. But unlike many other programming exercises, ray tracers often require some mathematical background. Even those who were good at math back in the school days - might hesitate to dust off the rust from their brains to only write a pointless (although, very cool) toy program.</p><p>For those who don&rsquo;t know what I&rsquo;m talking about - <a href=https://en.wikipedia.org/wiki/Ray_tracing_(graphics)>ray tracer</a> is an app that renders 3-dimensional objects, lights, reflections, all done by tracing the rays of light through the world of objects, shapes, and materials. There is even a popular challenge - writing a <a href=https://fabiensanglard.net/revisiting_the_businesscard_raytracer/index.html>&ldquo;business card&rdquo; ray tracer</a>, a small one, with the features you like, implemented in your own language of choice.</p><p>So let&rsquo;s walk through it together, there will be almost no mathematical formulas, but there will be illustrations and around 100 lines of primitive code. No prior knowledge of computer graphics or OpenGL is required.</p><h2 id=vectors>Vectors</h2><p>The core of the ray tracer is vector arithmetics. From the programming perspective, a 3-dimensional vector is just a tuple of 3 elements - x, y, and z. It is often represented visually as an arrow, which might be confusing, because vectors in our ray tracer serve multiple purposes - they describe points in 3D space, they describe directions, they even might describe RGB colors or material properties, but we&rsquo;ll restrain from this.</p><p><img src=/images/raytracer/vector.png alt=vector></p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>struct</span> <span class=nc>Vec</span> <span class=p>{</span>
  <span class=kt>float</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span><span class=p>;</span>
  <span class=n>Vec</span><span class=p>(</span><span class=kt>float</span> <span class=n>vx</span><span class=p>,</span> <span class=kt>float</span> <span class=n>vy</span><span class=p>,</span> <span class=kt>float</span> <span class=n>vz</span><span class=p>)</span> <span class=o>:</span> <span class=n>x</span><span class=p>(</span><span class=n>vx</span><span class=p>),</span> <span class=n>y</span><span class=p>(</span><span class=n>vy</span><span class=p>),</span> <span class=n>z</span><span class=p>(</span><span class=n>vz</span><span class=p>)</span> <span class=p>{}</span>
<span class=p>};</span>

<span class=n>Vec</span> <span class=n>v</span> <span class=o>=</span> <span class=n>Vec</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span> <span class=c1>// The vector on the picture above
</span></code></pre></div><p>What can we do with vectors? The easiest operation is multiplication by a number. You can think of it as &ldquo;making the vector n times longer&rdquo;. In programming terms for vector A that would mean: &ldquo;multiply A.x, A.y and A.z by n&rdquo;.</p><p>Adding two vectors A and B is also not that hard. Imagine putting them one after another and connecting the start of the first vector with the end of the second one. Or, in programming terms: &ldquo;add A.x with B.x, add A.y with B.y, add A.z with B.z&rdquo;.</p><p><img src=/images/raytracer/operations.png alt="vector operations"></p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>struct</span> <span class=nc>Vec</span> <span class=p>{</span>
  <span class=kt>float</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span><span class=p>;</span>
  <span class=n>Vec</span><span class=p>(</span><span class=kt>float</span> <span class=n>vx</span><span class=p>,</span> <span class=kt>float</span> <span class=n>vy</span><span class=p>,</span> <span class=kt>float</span> <span class=n>vz</span><span class=p>)</span> <span class=o>:</span> <span class=n>x</span><span class=p>(</span><span class=n>vx</span><span class=p>),</span> <span class=n>y</span><span class=p>(</span><span class=n>vy</span><span class=p>),</span> <span class=n>z</span><span class=p>(</span><span class=n>vz</span><span class=p>)</span> <span class=p>{}</span>
  <span class=n>Vec</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=n>Vec</span> <span class=n>vec</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=p>{</span><span class=n>x</span> <span class=o>+</span> <span class=n>vec</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span> <span class=o>+</span> <span class=n>vec</span><span class=p>.</span><span class=n>y</span><span class=p>,</span> <span class=n>z</span> <span class=o>+</span> <span class=n>vec</span><span class=p>.</span><span class=n>z</span><span class=p>};</span> <span class=p>}</span>
  <span class=n>Vec</span> <span class=k>operator</span><span class=o>-</span><span class=p>(</span><span class=n>Vec</span> <span class=n>vec</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=p>{</span><span class=n>x</span> <span class=o>-</span> <span class=n>vec</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span> <span class=o>-</span> <span class=n>vec</span><span class=p>.</span><span class=n>y</span><span class=p>,</span> <span class=n>z</span> <span class=o>-</span> <span class=n>vec</span><span class=p>.</span><span class=n>z</span><span class=p>};</span> <span class=p>}</span>
  <span class=n>Vec</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=kt>float</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=p>{</span><span class=n>x</span> <span class=o>*</span> <span class=n>n</span><span class=p>,</span> <span class=n>y</span> <span class=o>*</span> <span class=n>n</span><span class=p>,</span> <span class=n>z</span> <span class=o>*</span> <span class=n>n</span><span class=p>};</span> <span class=p>}</span>
<span class=p>};</span>
</code></pre></div><p>Minus operation A-B is no different from adding two vectors (it&rsquo;s the same as <code>A×(B*(-1))</code>), but can make the code more readable.</p><p>Three more operations &ndash; and we have enough knowledge about vectors to build a ray tracer.</p><p>Dot product. It tells you what amount of one vector goes in the direction of another. Or a &ldquo;projection&rdquo; of the first vector onto the second. The result is not a vector, but a single number, a length of the &ldquo;projection&rdquo; multiplied by the length of the second vector. The formula is much simpler than it sounds, just multiply all the coordinates in pairs and add them:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// dot product
</span><span class=c1></span><span class=kt>float</span> <span class=k>operator</span><span class=o>%</span><span class=p>(</span><span class=n>Vec</span> <span class=n>vec</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>vec</span><span class=p>.</span><span class=n>x</span> <span class=o>+</span> <span class=n>y</span> <span class=o>*</span> <span class=n>vec</span><span class=p>.</span><span class=n>y</span> <span class=o>+</span> <span class=n>z</span> <span class=o>*</span> <span class=n>vec</span><span class=p>.</span><span class=n>z</span><span class=p>;</span> <span class=p>}</span>
</code></pre></div><p>Now, what would be the dot product of vector on itself? Right, squared length (magnitude) of the vector. So we can now add a method to calculate vector own length:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>float</span> <span class=nf>length</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>sqrtf</span><span class=p>(</span><span class=o>*</span><span class=k>this</span> <span class=o>%</span> <span class=o>*</span><span class=k>this</span><span class=p>);</span> <span class=p>}</span>
</code></pre></div><p>Finally, we can divide the vector by its length and get a vector with the same &ldquo;direction&rdquo; but the length of 1, known as a unit vector:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>Vec</span> <span class=nf>unit</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>Vec</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=mi>1</span> <span class=o>/</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>length</span><span class=p>());</span> <span class=p>}</span>
</code></pre></div><p>And we are done with vectors.</p><h2 id=spheres>Spheres</h2><p>Vectors are only the underlying math. On the high level we will be operating with objects in a three-dimensional world. To keep things simple, all objects will be spheres. It would be still possible to implement &ldquo;walls&rdquo; using the spheres of a very large radius.</p><p>A sphere is typically defined by a center <code>C</code> and a radius <code>r</code>. The only thing we need to do with the spheres is to find how they intersect with the given ray of light.</p><p>Rays of light would be represented by a couple of vectors: the point of origin (where xyz would be the coordinates) and the direction (where xyz would be the unit vector pointing the ray).</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>struct</span> <span class=nc>Sphere</span> <span class=p>{</span>
  <span class=n>Vec</span> <span class=n>center</span><span class=p>;</span>
  <span class=kt>float</span> <span class=n>radius</span><span class=p>;</span>
  <span class=kt>float</span> <span class=nf>intersect</span><span class=p>(</span><span class=n>Vec</span> <span class=n>origin</span><span class=p>,</span> <span class=n>Vec</span> <span class=n>direction</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Return distance from the ray&#39;s origin to the intersection, or NAN if there is none.
</span><span class=c1></span>  <span class=p>}</span>
<span class=p>};</span>
</code></pre></div><p>Ray-sphere intersection requires doing some math with some variable substitution. If this get boring - feel free to skip to the final formula or code, but I&rsquo;ll try to keep things simple.</p><p>A sphere, by definition, is a set of points that are all at the same distance <code>r</code> from the center <code>C</code>. In other words, any point <code>S</code> belonging to the sphere satisfies the following equation:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>(S - C).length() = r
// or, squared, using dot product:
(S - C)·(S - C) = r²
</code></pre></div><p>Ray, as mentioned above is a set of points located along the same line, so linear equation fits here:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>Ray = O + tD, where &#34;t&#34; increases the points get further from the origin of the ray.
</code></pre></div><p>So, if the intersection point <code>I</code> belongs to both, the sphere and the ray, it should satisfy:</p><p><img src=/images/raytracer/sphere.png alt=intersection></p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>((O + tD) - C)·((O - tD) - C) = r²
// ...or
((O - C) + tD)·((O - C) - tD) = r²
// introduce some helper alias:
let P = O - C
(P + tD)·(P - tD) = r²
// ...explanded:
t²(D·D) + 2t(P·D) + P·P - r² = 0
// Looks like a square equation (ax²+bx+c=0)!
// ...where coefficients are:
let a = D·D
let b = 2(P·D)
let c = P·P-r²
// And the solution is, as in a typical square equation:
t = (-b ± √(b²-4ac)) / 2a
</code></pre></div><p>The ± sign there means that (assuming that a≠0) there would be two intersection points, one at the &ldquo;front&rdquo; of the sphere and another at the &ldquo;back&rdquo; after the ray &ldquo;pierced&rdquo; the sphere.</p><p>Now, maybe source code would be more eloquent:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>float</span> <span class=nf>intersect</span><span class=p>(</span><span class=n>Vec</span> <span class=n>origin</span><span class=p>,</span> <span class=n>Vec</span> <span class=n>direction</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// p = O-C
</span><span class=c1></span>  <span class=n>Vec</span> <span class=n>p</span> <span class=o>=</span> <span class=n>origin</span> <span class=o>-</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>center</span><span class=p>;</span>
  <span class=c1>// a = D·D
</span><span class=c1></span>  <span class=kt>float</span> <span class=n>a</span> <span class=o>=</span> <span class=n>direction</span> <span class=o>%</span> <span class=n>direction</span><span class=p>;</span>
  <span class=c1>// b = 2(P·D)
</span><span class=c1></span>  <span class=kt>float</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=p>(</span><span class=n>p</span> <span class=o>%</span> <span class=n>direction</span><span class=p>);</span>
  <span class=c1>// c = P·P - r²
</span><span class=c1></span>  <span class=kt>float</span> <span class=n>c</span> <span class=o>=</span> <span class=p>(</span><span class=n>p</span> <span class=o>%</span> <span class=n>p</span><span class=p>)</span> <span class=o>-</span> <span class=p>(</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>radius</span> <span class=o>*</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>radius</span><span class=p>);</span>
  <span class=c1>// d = b²-4ac
</span><span class=c1></span>  <span class=kt>float</span> <span class=n>d</span> <span class=o>=</span> <span class=n>b</span> <span class=o>*</span> <span class=n>b</span> <span class=o>-</span> <span class=mi>4</span> <span class=o>*</span> <span class=n>a</span> <span class=o>*</span> <span class=n>c</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>d</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Negative square? There is no intersection!
</span><span class=c1></span>    <span class=k>return</span> <span class=n>NAN</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=kt>float</span> <span class=n>sqd</span> <span class=o>=</span> <span class=n>sqrtf</span><span class=p>(</span><span class=n>d</span><span class=p>);</span>
  <span class=c1>// First try the closest point on ray
</span><span class=c1></span>  <span class=kt>float</span> <span class=n>distance</span> <span class=o>=</span> <span class=p>(</span><span class=o>-</span><span class=n>b</span> <span class=o>-</span> <span class=n>sqd</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=mf>2.f</span> <span class=o>*</span> <span class=n>a</span><span class=p>);</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>distance</span> <span class=o>&gt;</span> <span class=mf>.1f</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>distance</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=c1>// If not - try the one further away (i.e. ray originates inside a large sphere and hits the back)
</span><span class=c1></span>  <span class=n>distance</span> <span class=o>=</span> <span class=p>(</span><span class=o>-</span><span class=n>b</span> <span class=o>+</span> <span class=n>sqd</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=mf>2.f</span> <span class=o>*</span> <span class=n>a</span><span class=p>);</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>distance</span> <span class=o>&gt;</span> <span class=mf>.1f</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>distance</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=c1>// No intersection!
</span><span class=c1></span>  <span class=k>return</span> <span class=n>NAN</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p><em>Keep in mind that it&rsquo;s not the only approach to find intersection points. There is also a so-called &ldquo;geometric solution&rdquo;, but I leave it to the reader to google up.</em></p><p>We did the hardest part of the ray tracer. Now we need to construct the world and apply this method to all the spheres there.</p><h2 id=world>World</h2><p>To leave our ray tracer uncomplicated, our world would consist of two collections, spheres and lights. We also introduce one additional field to the Sphere type - color. Here I will keep in monochrome, not only it looks more dramatic, but also simplifies the calculations a bit and leaves you some space for improvement:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>struct</span> <span class=nc>Sphere</span> <span class=p>{</span>
  <span class=p>...</span>
  <span class=kt>float</span> <span class=n>color</span><span class=p>;</span> <span class=c1>// 0 = black, 1 = white
</span><span class=c1></span>  <span class=p>...</span>
<span class=p>};</span>

<span class=k>struct</span> <span class=nc>World</span> <span class=p>{</span>
  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Sphere</span><span class=o>&gt;</span> <span class=n>spheres</span><span class=p>;</span>
  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Sphere</span><span class=o>&gt;</span> <span class=n>lights</span><span class=p>;</span>
<span class=p>};</span>

<span class=n>World</span> <span class=n>world</span> <span class=o>=</span> <span class=p>{</span>
  <span class=p>{</span> <span class=c1>// spheres
</span><span class=c1></span>    <span class=p>{{</span><span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1000</span><span class=p>,</span> <span class=mi>0</span><span class=p>},</span> <span class=mf>0.001</span><span class=p>,</span> <span class=mi>1000</span><span class=p>},</span> <span class=c1>// large dark plane, the &#34;ground&#34;
</span><span class=c1></span>    <span class=p>{{</span><span class=o>-</span><span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>2</span><span class=p>},</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span> <span class=c1>// white sphere on the left
</span><span class=c1></span>    <span class=p>{{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>},</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span> <span class=c1>// grey sphere in the center
</span><span class=c1></span>    <span class=p>{{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>},</span> <span class=mf>0.1</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span> <span class=c1>// dark sphere on the right
</span><span class=c1></span>  <span class=p>},</span>
  <span class=p>{</span> <span class=c1>// three directional lights of various brightness
</span><span class=c1></span>    <span class=p>{{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>0</span><span class=p>},</span> <span class=mf>.4</span><span class=p>,</span> <span class=mi>0</span><span class=p>},</span>
    <span class=p>{{</span><span class=mi>100</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>200</span><span class=p>},</span> <span class=mf>.5</span><span class=p>,</span> <span class=mi>0</span><span class=p>},</span>
    <span class=p>{{</span><span class=o>-</span><span class=mi>100</span><span class=p>,</span> <span class=mi>300</span><span class=p>,</span> <span class=mi>100</span><span class=p>},</span> <span class=mf>.1</span><span class=p>,</span> <span class=mi>0</span><span class=p>},</span>
  <span class=p>},</span>
<span class=p>};</span>
</code></pre></div><p>Bear with me, we are only two functions away from the end result.</p><p>We need to render the scene somehow. Again, I won&rsquo;t talk about graphics formats or UI frameworks here, so we will render it using good old ASCII graphics. We need to set the point of view, say {0,1,5} - in the middle, slightly above the ground, in front of the spheres. Then for each &ldquo;pixel&rdquo; we should calculate the ray direction unit vector, that would originate from the point-of-view and hit the pixel as if it was on some invisible screen between the point-of-view and the world. If the screen is W×H pixels and put H pixels away from the point-of-view, the could iterate the rays like:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>void</span> <span class=nf>render</span><span class=p>(</span><span class=n>World</span> <span class=n>world</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>,</span> <span class=kt>int</span> <span class=n>height</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>y</span> <span class=o>&lt;</span> <span class=n>height</span><span class=p>;</span> <span class=n>y</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>width</span><span class=p>;</span> <span class=n>x</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>Vec</span> <span class=n>direction</span> <span class=o>=</span> <span class=n>Vec</span><span class=p>(</span><span class=n>x</span> <span class=o>-</span> <span class=n>width</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>height</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>-</span> <span class=n>y</span><span class=p>,</span> <span class=o>-</span><span class=n>height</span><span class=p>).</span><span class=n>unit</span><span class=p>();</span>
      <span class=c1>// c would be the color of the pixel
</span><span class=c1></span>      <span class=kt>float</span> <span class=n>c</span> <span class=o>=</span> <span class=n>trace</span><span class=p>(</span><span class=n>world</span><span class=p>,</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>5</span><span class=p>},</span> <span class=n>direction</span><span class=p>);</span>
      <span class=c1>// find the suitable ASCII symbol &#34;density&#34; from 0 to 10
</span><span class=c1></span>      <span class=kt>char</span> <span class=n>pixel</span> <span class=o>=</span> <span class=s>&#34; .:-=+*#%@$&#34;</span><span class=p>[(</span><span class=kt>int</span><span class=p>)(</span><span class=n>c</span> <span class=o>*</span> <span class=mi>10</span><span class=p>)];</span>
      <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>pixel</span> <span class=o>&lt;&lt;</span> <span class=n>pixel</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h2 id=tracing-rays>Tracing rays</h2><p>The final and the most interesting step, implementing the trace() function. That&rsquo;s the most annoying thing about ray tracers - you can only see them working (or not working) after all the core parts are implemented. So, please be patient.</p><p>First, it should loop over all the spheres and find the nearest intersection of them all (if one sphere appears in front of the other - it would be the nearest ray intersection).</p><p>Here&rsquo;s our first attempt:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>float</span> <span class=nf>trace</span><span class=p>(</span><span class=n>World</span> <span class=n>world</span><span class=p>,</span> <span class=n>Vec</span> <span class=n>origin</span><span class=p>,</span> <span class=n>Vec</span> <span class=n>direction</span><span class=p>)</span> <span class=p>{</span>
  <span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>       <span class=c1>// nearest sphere index
</span><span class=c1></span>  <span class=kt>float</span> <span class=n>distance</span> <span class=o>=</span> <span class=n>NAN</span><span class=p>;</span> <span class=c1>// nearest sphere distance
</span><span class=c1></span>
  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>world</span><span class=p>.</span><span class=n>spheres</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Loop over every sphere, find nearest non-NAN intersection
</span><span class=c1></span>    <span class=kt>float</span> <span class=n>d</span> <span class=o>=</span> <span class=n>world</span><span class=p>.</span><span class=n>spheres</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>intersect</span><span class=p>(</span><span class=n>origin</span><span class=p>,</span> <span class=n>direction</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>std</span><span class=o>::</span><span class=n>isnan</span><span class=p>(</span><span class=n>d</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>d</span> <span class=o>&lt;</span> <span class=n>distance</span><span class=p>))</span> <span class=p>{</span>
      <span class=n>distance</span> <span class=o>=</span> <span class=n>d</span><span class=p>;</span>
      <span class=n>index</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>h</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// If no intersection: return black color
</span><span class=c1></span>  <span class=p>}</span>
  <span class=c1>// If there is a sphere - return white color
</span><span class=c1></span>  <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>And, here are our first results!</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>






                                      $$$$$$
                                  $$$$$$$$$$$$$$        $$$$$$
                      $$$$$$$$  $$$$$$$$$$$$$$$$$$  $$$$$$$$$$$$
                    $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
                    $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
                  $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
                    $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
</code></pre></div><p>Impressive, aren&rsquo;t they? Well, some people see a lot of dollars here, but I see three spheres put on top of the large &ldquo;ground&rdquo; sphere. All painted white. The pixels that do not belong to the spheres are black. Baby steps.</p><p>Now, let&rsquo;s paint our spheres the right color: <code>return world.spheres[h].color</code> instead of <code>return 1</code>:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>


                                      ++++++
                                  ++++++++++++++        ......
                      $$$$$$$$  ++++++++++++++++++  ............
                    $$$$$$$$$$$$++++++++++++++++++................
                    $$$$$$$$$$++++++++++++++++++++++..............
                  $$$$$$$$$$$$++++++++++++++++++++++................
                    $$$$$$$$$$++++++++++++++++++++++..............
                    $$$$$$$$$$$$++++++++++++++++++................
                      $$$$$$$$  ++++++++++++++++++  ............
                                  ++++++++++++++        ......
                                      ++++++



</code></pre></div><p>Much better! White on the left, grey in the middle, dark on the right. The ground sphere is all black. So is the sky, but that&rsquo;s a different topic.</p><p>Let&rsquo;s trace the lights. We should iterate through all the lights in the scene, for each light - iterate through all spheres, and&mldr; do what? For each light we need to calculate its contributions:</p><ul><li>Find a point of intersection P for the point-of-view ray and the nearest sphere.</li><li>Find the normal N to that point of intersection: <code>(P-C).unit()</code>.</li><li>Find direction D from each light origin L to the point of intersection P: <code>(L-P).unit()</code></li><li>Find if there any shadowing sphere, that intersects the ray originating at P with direction D.</li><li>If there is shadow - return a dimmed color of the sphere (return 10% of the original sphere brightness)</li><li>If there is no shadow and the point P is not hidden from light - find out the contribution and combine it with the current pixel color.</li></ul><p>In C++ that would be:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>float trace(World world, Vec origin, Vec direction) {
  ...
  // we have `distance` to the nearest sphere intersecting the point-of-view ray
  ...
  Vec p = origin + direction * distance;
  Vec n = (p - world.spheres[h].center).unit();
  float c = world.spheres[h].color * 0.1f;
  for (auto light : world.lights) {
    Vec l = (light.center - p).unit();
    int shadow = 0;
    for (auto sphere : world.spheres) {
      if (!std::isnan(sphere.intersect(p, l))) {
        shadow = 1;
      }
    }
    if (!shadow) {
      // Try:
      return world.spheres[h].color;
      // Or try:
      return world.spheres[h].color * light.color;
    }
  }
  return c;
}
</code></pre></div><p>Whether we return just sphere color, or sphere color adjusted by the light - we still get bad results, looking nothing like 3D. Light contribution depends a lot on the angle between the light and the sphere normal. If the angle is almost 90° - the light beams brightly, if the angle is close to zero - the light ray looks dimmer. This is where vector dot point operator helps us:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>float</span> <span class=n>diffuse</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=mf>0.f</span><span class=p>,</span> <span class=p>(</span><span class=n>l</span> <span class=o>%</span> <span class=n>n</span><span class=p>)</span> <span class=o>*</span> <span class=mf>0.7f</span><span class=p>);</span>
<span class=kt>float</span> <span class=n>specular</span> <span class=o>=</span> <span class=n>powf</span><span class=p>(</span><span class=n>fmax</span><span class=p>(</span><span class=mf>0.f</span><span class=p>,</span> <span class=p>(</span><span class=n>l</span> <span class=o>%</span> <span class=n>n</span><span class=p>)),</span> <span class=mf>70.f</span><span class=p>)</span> <span class=o>*</span> <span class=mf>0.4f</span><span class=p>;</span>
<span class=n>c</span> <span class=o>=</span> <span class=n>c</span> <span class=o>+</span> <span class=n>world</span><span class=p>.</span><span class=n>spheres</span><span class=p>[</span><span class=n>h</span><span class=p>].</span><span class=n>color</span> <span class=o>*</span> <span class=n>light</span><span class=p>.</span><span class=n>color</span> <span class=o>*</span> <span class=n>diffuse</span> <span class=o>+</span> <span class=n>specular</span><span class=p>;</span>
</code></pre></div><p>Coefficients are purely random, but the picture looks very different now in my terminal:</p><p><img src=/images/raytracer/ascii.png alt=final-ascii></p><h2 id=bonus>Bonus</h2><p>There is a special old graphics format, that people seem to use exclusively in ray tracers these days - PGM/PNM/PPM. It&rsquo;s a text format where each pixel is store as a decimal number. Now, as we are comfortable with ray tracer internals - we can play around with graphics output:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// Very similar to our render() function above, but export PGM format
</span><span class=c1>// Each pixel is a number, where 0 is black and 255 is white.
</span><span class=c1></span><span class=kt>void</span> <span class=nf>render_pgm</span><span class=p>(</span><span class=n>World</span> <span class=n>world</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>filename</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>,</span> <span class=kt>int</span> <span class=n>height</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>std</span><span class=o>::</span><span class=n>ofstream</span> <span class=n>f</span><span class=p>(</span><span class=n>filename</span><span class=p>);</span>
  <span class=n>f</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;P2&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>width</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>height</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; 255&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>y</span> <span class=o>&lt;</span> <span class=n>height</span><span class=p>;</span> <span class=n>y</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>width</span><span class=p>;</span> <span class=n>x</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
      <span class=kt>float</span> <span class=n>c</span> <span class=o>=</span> <span class=n>trace</span><span class=p>(</span><span class=n>world</span><span class=p>,</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>5</span><span class=p>},</span>
                      <span class=n>Vec</span><span class=p>(</span><span class=n>x</span> <span class=o>-</span> <span class=n>width</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>height</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>-</span> <span class=n>y</span><span class=p>,</span> <span class=o>-</span><span class=n>height</span><span class=p>).</span><span class=n>unit</span><span class=p>());</span>
      <span class=n>f</span> <span class=o>&lt;&lt;</span> <span class=p>((</span><span class=kt>int</span><span class=p>)(</span><span class=n>c</span> <span class=o>*</span> <span class=mi>255</span><span class=p>))</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>Another little trick to add is the sky. Rather than returning constant black - we can return a grey gradient, that gets lighter as it goes down:</p><p><img src=/images/raytracer/final.pgm.png alt=final-pgm></p><p>The full code is available on GitHub: <a href=https://gist.github.com/zserge/d22d7b226dd9989f00b1ff8d16e01e0c>https://gist.github.com/zserge/d22d7b226dd9989f00b1ff8d16e01e0c</a></p><p>Ray tracer itself is ~80 lines of code, rendering functions are ~10 lines each - it would be easy to read and understand.</p><p>We can also experiment with stereo pictures, rendering the same scene from slightly different points of view. Or add RGB colors to the objects. Or cast shadows differently, but casting a few random rays and filtering the results. Or add materials with different diffusion/reflection and other properties. Or handle more shapes - cylinders, cones, cubes. I hope I shed some light on the basics and you would be able to write your own, much more powerful and beautiful ray tracer!</p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href=https://github.com/zserge>Github</a>, <a href=https://twitter.com/zsergo>Twitter</a> or subscribe via <a href=/rss.xml>rss</a>.</p><p class=date style=text-align:right><em>Apr 22, 2021</em></p><p>See also:
<a href=/posts/better-c-benchmark/>A "Better C" Benchmark</a> and <a href=/posts/>more</a>.</p></div><footer><p>&copy;2012&ndash;2021 &#183;
<a class=h-card rel=me href=https://zserge.com/>Serge Zaitsev</a> &#183;
<a href=mailto:hello@zserge.com rel=me>hello@zserge.com</a></p></footer><script>(function(e,t,n,i,s,a,c){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)};a=t.createElement(i);c=t.getElementsByTagName(i)[0];a.async=true;a.src=s;c.parentNode.insertBefore(a,c)})(window,document,"galite","script","https://cdn.jsdelivr.net/npm/ga-lite@2/dist/ga-lite.min.js");galite('create','UA-33644825-1','auto');galite('send','pageview');</script><script>new Image().src='https://nullitics.com/file.gif?u='+encodeURI(location.href)+'&r='+encodeURI(document.referrer)+'&d='+screen.width</script><noscript><img src=https://nullitics.com/file.gif></noscript></body></html>