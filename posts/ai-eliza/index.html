<!doctype html><html lang=en><head><meta charset=utf-8><title>AI or ain't: Eliza</title><meta name=description content="Explore the intriguing history of Eliza, a pioneering chatbot, and learn how to implement a basic version in Go, unraveling the roots of conversational AI."><meta name=author content="Serge Zaitsev"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=data:,><link rel="shortcut icon" sizes=32x32 href=/favicon.png><link rel="shortcut icon" sizes=192x192 href=/favicon-192x192.png><link rel=apple-touch-icon href=/favicon-192x192.png><link rel=alternate type=application/rss+xml title=RSS href=/rss.xml><link rel=canonical href=https://zserge.com/posts/ai-eliza/><meta property="og:title" content="AI or ain't: Eliza"><meta property="og:type" content="article"><meta property="og:url" content="https://zserge.com/posts/ai-eliza/"><meta property="og:image" content="https://zserge.com/logo.png"><meta property="og:description" content="Explore the intriguing history of Eliza, a pioneering chatbot, and learn how to implement a basic version in Go, unraveling the roots of conversational AI."><meta property="og:locale" content="en_US"><meta name=twitter:card content="Explore the intriguing history of Eliza, a pioneering chatbot, and learn how to implement a basic version in Go, unraveling the roots of conversational AI."><meta name=twitter:site content="@zsergo"><style type=text/css>body{padding:1rem;margin:auto;max-width:46rem;font-family:pt serif,Georgia,Cambria,times new roman,Times,serif;line-height:1.5;font-size:20px;color:rgba(0,0,0,.87);-webkit-font-smoothing:antialiased;font-weight:300}nav{display:flex;justify-content:space-between;align-items:center;margin:1em 0 3em}nav ul,nav li{display:inline-block;list-style:none;margin:0 0 0 .5rem;padding:0}nav ul{margin-right:1rem}.logo{background-color:rgba(0,0,0,.87);color:#fff;min-width:48px;min-height:48px;font-size:28px;border-radius:2px;display:flex;justify-content:center;align-items:center}.logo:hover{color:#fff}h1,h2{line-height:1.2;font-family:roboto,system-ui,segoe ui,Helvetica,Arial,sans-serif;font-weight:400;text-transform:uppercase;margin:1.34em 0 0}h1{font-size:1.95em}h2{font-size:1.25em;border-bottom:2px solid rgba(0,0,0,.87)}h1 a{color:rgba(0,0,0,.87)}p{margin:.67em 0 1em}a{color:#0076df;text-decoration:none;word-break:break-word}a:hover{color:rgba(0,0,0,.87)}ul,ol{list-style-position:outside;margin-left:1em}img{display:block;margin-left:auto;margin-right:auto;max-width:100%}pre,code{font-family:roboto mono,SFMono-Regular,Consolas,liberation mono,Menlo,monospace;font-weight:400;font-size:18px;color:rgba(0,0,0,.6);background:#eee}code{padding:.2rem .4rem;font-size:14px;border-radius:2px}pre{overflow-y:auto;line-height:20px;border-radius:2px;padding:1em}pre code{font-size:14px;padding:0;color:rgba(0,0,0,.87)}footer{font-size:12px}@media(prefers-color-scheme:dark){.logo{color:#444;background-color:#e4e4e4}.logo:hover{color:#444}body,h1 a,h2 a{background-color:#444;color:#e4e4e4}pre,pre code{background:#333;color:#e4e4e4}h2{border-bottom:1px solid #e4e4e4}code{color:#aaa;background:#333}a{color:#e39777}a:hover{color:#e4e4e4}img{filter:grayscale(30%)}}.hl{display:block;width:100%;background-color:#ffc}.ow,.gh,.gp,.gs,.gu,.nt,.nn,.ne,.ni,.nc,.kr,.kn,.kd,.kc,.k{font-weight:700}.c,.ch,.cm,.c1,.cs,.ge{color:#777}</style><link rel="shortcut icon" href=/favicon.ico></head><body><header><nav><a class=logo href=/>Z</a><ul><li><a href=/about/>about</a></li><li><a href=/posts/>posts</a></li><li><a href=https://mastodon.social/@zserge rel=me>@me</a></li><li><a href=https://github.com/zserge rel=me>&lt;/>me</a></li></ul></nav></header><div id=content><h1>AI or ain't: Eliza</h1><p>In the year 2023, AI took center stage in the media, stirring up discussions about whether it was mere hype or real progress.</p><p>However, the concept of <a href=https://en.wikipedia.org/wiki/Extraterrestrial_intelligence>non-human intelligence</a> isn&rsquo;t a recent fascination; it has been a dream since ancient times. As we learned more about how neurons communicate through electronic pulses in our brains, it seemed plausible to simulate our &ldquo;intelligence&rdquo; with similar electronic circuits. The term &ldquo;machine intelligence&rdquo; was coined in the 1950s, around the same time the <a href=https://en.wikipedia.org/wiki/Turing_test>Turing test</a> was introduced.</p><p>This test (also known as the &ldquo;imitation game&rdquo;) suggests that AI can be considered genuinely intelligent if a human can&rsquo;t tell whether they&rsquo;re interacting with another human or a machine. Picture an interrogator in a room, chatting through a text interface, asking questions, and trying to figure out if their conversational partner is human or not. If the person talking to the computer believes it&rsquo;s a human, even though it&rsquo;s a machine, that signifies the machine is genuinely artificially intelligent.</p><h2 id=eliza>Eliza</h2><p>One of the first computer programs that successfully passed the Turing test was <a href>Eliza</a>. Created in 1966 by <a href=https://web.stanford.edu/class/cs124/p36-weizenabaum.pdf>Joseph Weizenbaum</a>, Eliza skillfully emulated the speech patterns of a psychotherapist in its conversations. Interestingly, Eliza still <a href=https://arstechnica.com/information-technology/2023/12/real-humans-appeared-human-63-of-the-time-in-recent-turing-test-ai-study/>outperforms ChatGPT-3.5</a> in certain Turing test variations.</p><p>Eliza demonstrates how even the simplest algorithm can be just sufficient to appear intelligent. Let&rsquo;s imagine a program that constantly prints &ldquo;Hello, user!&rdquo; when it starts. We can hardly consider it intelligent and a user will quickly start to suspect it&rsquo;s just a hardcoded behaviour.</p><p>Now, imagine a program printing a random greeting from a predefined list. It will take more attempts to unveil its artificiality, but as soon as the interrogator starts asking questions, such a bot would appear too inadequate in comparison to human interaction.</p><h2 id=how-eliza-works>How Eliza works</h2><p>Let&rsquo;s recreate Eliza just the way it worked 57 years ago. I&rsquo;ll share some <a href=https://github.com/zserge/aint/tree/main/eliza>Go code</a>, but you can easily adapt it to the other programming languages.</p><p>We start with a basic chatbot interface:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>response</span><span class=p>(</span><span class=nx>input</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>output</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=s>&#34;I&#39;m not sure I understand you fully&#34;</span>
<span class=p>}</span>
<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;How do you do.  Please tell me your problem.&#34;</span><span class=p>)</span>
    <span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Goodbye.  It was nice talking to you.&#34;</span><span class=p>)</span>
    <span class=nx>scanner</span> <span class=o>:=</span> <span class=nx>bufio</span><span class=p>.</span><span class=nf>NewScanner</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Stdin</span><span class=p>)</span>
    <span class=k>for</span> <span class=nx>scanner</span><span class=p>.</span><span class=nf>Scan</span><span class=p>()</span> <span class=p>{</span>
        <span class=nx>reply</span> <span class=o>:=</span> <span class=nf>respond</span><span class=p>(</span><span class=nx>scanner</span><span class=p>.</span><span class=nf>Text</span><span class=p>())</span>
        <span class=k>if</span> <span class=nx>reply</span> <span class=o>==</span> <span class=s>&#34;&#34;</span> <span class=p>{</span> <span class=c1>// no reply = end of conversation
</span><span class=c1></span>            <span class=k>break</span>
        <span class=p>}</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>reply</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>Here, we&rsquo;re reading text from stdin line by line and sending each line to the <code>response()</code> function. This function&rsquo;s job is to handle what the user says, find a suitable reply, and send it back.</p><p>Currently, our Eliza is pretty brainless; it doesn&rsquo;t really understand anything the user says and can&rsquo;t wrap up a conversation properly. So, let&rsquo;s give it a bit more intelligence by introducing some stop words to help Eliza bid a proper goodbye.</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>quit</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;bye&#34;</span><span class=p>,</span> <span class=s>&#34;goodbye&#34;</span><span class=p>,</span> <span class=s>&#34;done&#34;</span><span class=p>,</span> <span class=s>&#34;exit&#34;</span><span class=p>,</span> <span class=s>&#34;quit&#34;</span><span class=p>}</span>

<span class=kd>func</span> <span class=nf>respond</span><span class=p>(</span><span class=nx>input</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
  <span class=nx>q</span> <span class=o>:=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>ToLower</span><span class=p>(</span><span class=nx>strings</span><span class=p>.</span><span class=nf>TrimSpace</span><span class=p>(</span><span class=nx>input</span><span class=p>))</span>
  <span class=k>if</span> <span class=nf>contains</span><span class=p>(</span><span class=nx>q</span><span class=p>,</span> <span class=nx>quit</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=s>&#34;&#34;</span>
  <span class=p>}</span>
  <span class=o>...</span>
<span class=p>}</span>

<span class=c1>// &gt; How do you do.  Please tell me your problem.
</span><span class=c1>// : Bye
</span><span class=c1>// &gt; Goodbye.  It was nice talking to you.
</span></code></pre></div><h2 id=knowledge-base>Knowledge base</h2><p>To enhance Eliza&rsquo;s conversational skills, we need to implant some knowledge into its brain. In our case knowledge will be stored in a very structured and oranised manner &ndash; as a sorted list of keywords, each accompanied with a set of possible transformation rules.</p><p>Transformation rules are predefined instructions and patterns to help Eliza modify and respond to specific user inputs. Each transformation rule consist of a pattern to match (decomposition) and instructions on how to reassemble the reply.</p><p>Here&rsquo;s a simple rule example:</p><div class=highlight><pre class=chroma><code class=language-yaml data-lang=yaml><span class=nt>keyword</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;sorry&#34;</span><span class=w>
</span><span class=w></span><span class=nt>rules</span><span class=p>:</span><span class=w>
</span><span class=w></span>- <span class=nt>match</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;*&#34;</span><span class=w>
</span><span class=w>  </span><span class=nt>reasmb</span><span class=p>:</span><span class=w>
</span><span class=w>  </span>- <span class=l>Please don&#39;t apologise.</span><span class=w>
</span><span class=w>  </span>- <span class=l>Apologies are not necessary.</span><span class=w>
</span><span class=w>  </span>- <span class=l>I&#39;ve told you that apologies are not required.</span><span class=w>
</span><span class=w>  </span>- <span class=l>It did not bother me.  Please continue.</span><span class=w>
</span></code></pre></div><p>This rule is triggered when the user input contains the word &ldquo;sorry&rdquo;. Pattern is a wildcard (<code>*</code>) that matches all input text. Reassembly rules are just static strings and any of them can be returned as a possible reply:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>&gt; How do you do.  Please tell me your problem.
: Oh sorry
&gt; Please don&#39;t apologise.
</code></pre></div><p>More complicated examples would use reassembly rules that include parts of the user input:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>keyword: &#34;you&#34;
rules:
- match: &#34;* you * me&#34;
  reasmb:
  - &#34;What makes you think I (2) you ?&#34;
  - &#34;You like to think I (2) you -- don&#39;t you ?&#34;
  - &#34;Really, I (2) you ?&#34;
- match: &#34;* you are *&#34;
  - &#34;What makes you think I am (2) ?&#34;
</code></pre></div><p>Consider user input <em>&ldquo;I suspect you are a bot&rdquo;</em>. Eliza will detect the keyword <code>you</code> in the input and will start looking for matching patterns belonging to that keyword.</p><p>The first pattern <code>* you * me</code> will not match the input, but the second one will. Given the input <em>&ldquo;I suspect you are a bot&rdquo;</em> and pattern <code>* you are *</code> the first wildcard would hold <code>I suspect</code> and the second wildcard would hold <code>a bot</code>. Now, the reassembly rule would replace <code>(2)</code> placehodler with the contents of the second wildcard replying with <em>&ldquo;What makes you think I am a bot?"</em>.</p><p>Similarly for the input <em>&ldquo;I think you might dislike me&rdquo;</em> the reply could be <em>&ldquo;Really, I might dislike you?"</em>.</p><h1 id=synonyms>Synonyms</h1><p>To avoid duplication of the rules, Eliza uses synonym groups in its patterns. For example, category <code>belief</code> may include words like &ldquo;belief&rdquo;, &ldquo;feel&rdquo;, &ldquo;think&rdquo;, &ldquo;believe&rdquo;, &ldquo;wish&rdquo; etc. Then in a pattern it becomes possible to refer to the whole category instead of individual words:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>keyword: &#34;i&#34;
rules:
- match: &#34;* i /belief i *&#34;
  reasmb:
  - &#34;Do you really think so ?&#34;,
  - &#34;But you are not sure you (2).&#34;,
  - &#34;Do you really doubt you (2) ?&#34;),
</code></pre></div><p>Here for the input <em>&ldquo;I feel I am talking to a bot&rdquo;</em> the reply could be <em>&ldquo;But you are not sure you are talking to the bot&rdquo;</em>.</p><p>You might wonder how &ldquo;I am&rdquo; turned into &ldquo;you are&rdquo;. Eliza has a list of preprocessing and postprocessing rules. Preprocessing helps to convert &ldquo;I&rsquo;m&rdquo; into &ldquo;I am&rdquo; or fix some common typos. Postprocessing helps to invert the pronouns and verbs, i.e. &ldquo;am → are&rdquo;, &ldquo;your → my&rdquo;, &ldquo;myself → yourself&rdquo; etc.</p><p>Another trick Eliza uses to handle synonyms is a &ldquo;goto&rdquo; reassembly rule. For the given keyword some transformation rules might redirect Eliza to a different (related) keyword:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>keyword: &#34;apologise&#34;
rules:
- match: &#34;*&#34;
  reasmb:
  - &#34;=sorry&#34;
keyword: &#34;can&#34;
rules:
- match: &#34;* can you *&#34;
  reasmb:
  - &#34;You believe I can (2) don&#39;t you ?&#34;
  - &#34;=what&#34;
keyword: &#34;what&#34;
rules:
- match: &#34;*&#34;
  reamb:
  - &#34;Why do you ask ?&#34;
  - &#34;Does that question interest you ?&#34;
</code></pre></div><p>Here keyword &ldquo;apologise&rdquo; is treated just as if it was &ldquo;sorry&rdquo;. For the keyword &ldquo;can&rdquo; the first reply would be <em>&ldquo;You believe I can&mldr;"</em> and the second attempt would navigate Eliza to a generic reply.</p><p>Finally, there is one last feature that Eliza employed to simulate intelligence: memorisation. Some transformation rules would ask Eliza to store replies in a memory stack. Later, when no suitable reply could be found these previous replies are popped from memory and reused:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>&gt; How do you do.  Please tell me your problem.
: My chatbot is misbehaving
&gt; Lets discuss further why your chatbot is misbehaving.
: It pretends being intelligent while it&#39;s not
&gt; Lets discuss further why your chatbot is misbehaving.
: See?
&gt; Please go on.
</code></pre></div><p>Here the first reply about chatbot misbehaving is memorised and repeated when Eliza is out of suitable replies.</p><p>And that&rsquo;s all Eliza does. Knowledge base can be represented directly with Go code, but you can also store Eliza &ldquo;scripts&rdquo; as JSON or YAML files and parse those on startup:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>Keyword</span> <span class=kd>struct</span> <span class=p>{</span>
  <span class=nx>Word</span>   <span class=kt>string</span>
  <span class=nx>Rank</span>   <span class=kt>int</span>
  <span class=nx>Decomp</span> <span class=p>[]</span><span class=nx>Decomp</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>Decomp</span> <span class=kd>struct</span> <span class=p>{</span>
  <span class=nx>Match</span>  <span class=kt>string</span>
  <span class=nx>Save</span>   <span class=kt>bool</span>
  <span class=nx>Reasmb</span> <span class=p>[]</span><span class=kt>string</span>
<span class=p>}</span>

<span class=kd>var</span> <span class=nx>keywords</span> <span class=p>=</span> <span class=p>[]</span><span class=nx>Keyword</span><span class=p>{</span>
  <span class=p>{</span>
    <span class=s>&#34;sorry&#34;</span><span class=p>,</span> <span class=c1>// keyword
</span><span class=c1></span>    <span class=mi>0</span><span class=p>,</span>       <span class=c1>// rank to sort the keywords
</span><span class=c1></span>    <span class=p>[]</span><span class=nx>Decomp</span><span class=p>{</span>
      <span class=nx>Decomp</span><span class=p>{</span><span class=s>&#34;*&#34;</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span>
        <span class=p>[]</span><span class=kt>string</span><span class=p>{</span>
          <span class=s>&#34;Please don&#39;t apologise.&#34;</span><span class=p>,</span>
          <span class=s>&#34;Apologies are not necessary.&#34;</span><span class=p>,</span>
          <span class=o>...</span>
        <span class=p>},</span>
      <span class=p>},</span>
    <span class=p>},</span>
  <span class=p>},</span>
  <span class=o>...</span>
<span class=p>}</span>

<span class=kd>var</span> <span class=p>(</span>
  <span class=nx>pre</span> <span class=p>=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span>
    <span class=s>&#34;dont&#34;</span><span class=p>:</span>       <span class=s>&#34;don&#39;t&#34;</span><span class=p>,</span>
     <span class=o>...</span>
  <span class=p>}</span>
    <span class=nx>post</span> <span class=p>=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span>
    <span class=s>&#34;am&#34;</span><span class=p>:</span>       <span class=s>&#34;are&#34;</span><span class=p>,</span>
    <span class=s>&#34;your&#34;</span><span class=p>:</span>     <span class=s>&#34;my&#34;</span><span class=p>,</span>
    <span class=o>...</span>
  <span class=p>}</span>
  <span class=nx>quit</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;bye&#34;</span><span class=p>,</span> <span class=s>&#34;goodbye&#34;</span><span class=p>,</span> <span class=s>&#34;done&#34;</span><span class=p>,</span> <span class=s>&#34;exit&#34;</span><span class=p>,</span> <span class=s>&#34;quit&#34;</span><span class=p>}</span>
  <span class=nx>syn</span>  <span class=p>=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=kt>string</span><span class=p>{</span>
    <span class=s>&#34;be&#34;</span><span class=p>:</span>       <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;be&#34;</span><span class=p>,</span> <span class=s>&#34;am&#34;</span><span class=p>,</span> <span class=s>&#34;is&#34;</span><span class=p>,</span> <span class=s>&#34;are&#34;</span><span class=p>,</span> <span class=s>&#34;was&#34;</span><span class=p>},</span>
    <span class=s>&#34;belief&#34;</span><span class=p>:</span>   <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;belief&#34;</span><span class=p>,</span> <span class=s>&#34;feel&#34;</span><span class=p>,</span> <span class=s>&#34;think&#34;</span><span class=p>,</span> <span class=s>&#34;believe&#34;</span><span class=p>,</span> <span class=s>&#34;wish&#34;</span><span class=p>},</span>
    <span class=o>...</span>
  <span class=p>}</span>
  <span class=nx>fallback</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span>
    <span class=s>&#34;I&#39;m not sure I understand you fully.&#34;</span><span class=p>,</span>
    <span class=s>&#34;Please go on.&#34;</span><span class=p>,</span>
    <span class=o>...</span>
  <span class=p>}</span>
<span class=p>)</span>
</code></pre></div><p>All of Eliza state can be stored in two variables: an index, pointing to the next available decomposition for each rule, and a memory of the latest stored replies:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=p>(</span>
  <span class=nx>index</span> <span class=p>=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>{}</span>
  <span class=nx>mem</span>   <span class=p>[]</span><span class=kt>string</span>
<span class=p>)</span>
</code></pre></div><p>Complete Eliza code is no more than three functions: a helper to pre/postprocess text, a pattern matching algorithm and a top-level response function to handle the rest of Eliza&rsquo;s logic:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>replace</span><span class=p>(</span><span class=nx>words</span> <span class=p>[]</span><span class=kt>string</span><span class=p>,</span> <span class=nx>mapping</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>res</span> <span class=p>[]</span><span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>w</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>words</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nx>s</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>mapping</span><span class=p>[</span><span class=nx>w</span><span class=p>];</span> <span class=nx>ok</span> <span class=p>{</span>
      <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>Fields</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=o>...</span><span class=p>)</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>w</span><span class=p>)</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=nx>res</span>
<span class=p>}</span>

<span class=nf>replace</span><span class=p>(</span><span class=nx>strings</span><span class=p>.</span><span class=nf>Fields</span><span class=p>(</span><span class=s>&#34;i think you&#39;re a machine&#34;</span><span class=p>},</span> <span class=nx>pre</span><span class=p>)</span>
<span class=c1>// -&gt; [&#34;i&#34;, &#34;think&#34;, &#34;you&#34;, &#34;are&#34;, &#34;a&#34;, &#34;computer&#34;]
</span><span class=c1></span><span class=nf>replace</span><span class=p>(</span><span class=nf>replace</span><span class=p>(</span><span class=nx>strings</span><span class=p>.</span><span class=nf>Fields</span><span class=p>(</span><span class=s>&#34;i think you&#39;re a machine&#34;</span><span class=p>},</span> <span class=nx>pre</span><span class=p>),</span> <span class=nx>post</span><span class=p>)</span>
<span class=c1>// -&gt; [&#34;you&#34;, &#34;think&#34;, &#34;i&#34;, &#34;am&#34;, &#34;a&#34;, &#34;computer&#34;]
</span></code></pre></div><p>Pattern matching can be implemented in a number of ways. The obvious one would be to use regular expressions, but that&rsquo;s too high-level for Eliza. Another option would be to implement <a href=https://benhoyt.com/writings/rob-pike-regex/>a 35-line tiny matcher</a> by <a href=https://en.wikipedia.org/wiki/Rob_Pike>Rob Pike</a>.</p><p>But since our text is already split into tokens we can build a similar recursive matcher that operates on words rather than characters:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>match</span><span class=p>(</span><span class=nx>pat</span><span class=p>,</span> <span class=nx>words</span> <span class=p>[]</span><span class=kt>string</span><span class=p>)</span> <span class=p>([]</span><span class=kt>string</span><span class=p>,</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>pat</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>words</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
    <span class=c1>// Both, pattern and text are empty: match!
</span><span class=c1></span>    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>true</span>
  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>pat</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>words</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>pat</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>1</span> <span class=o>||</span> <span class=nx>pat</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>!=</span> <span class=s>&#34;*&#34;</span><span class=p>))</span> <span class=p>{</span>
    <span class=c1>// Pattern is empty but some words left, or
</span><span class=c1></span>    <span class=c1>// Words are empty but pattern has some text left: no match!
</span><span class=c1></span>    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>false</span>
  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>pat</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=s>&#34;*&#34;</span> <span class=p>{</span>
    <span class=c1>// Wildcard: be greedy, as long as the &#34;tails&#34; match!
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>words</span><span class=p>);</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span> <span class=p>{</span>
      <span class=k>if</span> <span class=nx>m</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nf>match</span><span class=p>(</span><span class=nx>pat</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=nx>words</span><span class=p>[</span><span class=nx>i</span><span class=p>:]);</span> <span class=nx>ok</span> <span class=p>{</span>
        <span class=nx>g</span> <span class=o>:=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nf>replace</span><span class=p>(</span><span class=nx>words</span><span class=p>[:</span><span class=nx>i</span><span class=p>],</span> <span class=nx>post</span><span class=p>),</span> <span class=s>&#34; &#34;</span><span class=p>)</span>
        <span class=k>return</span> <span class=nb>append</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=nx>g</span><span class=p>},</span> <span class=nx>m</span><span class=o>...</span><span class=p>),</span> <span class=kc>true</span>
      <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>false</span>
  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>HasPrefix</span><span class=p>(</span><span class=nx>pat</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=s>&#34;/&#34;</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Synonym: compare to one of the words in that category
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>slices</span><span class=p>.</span><span class=nf>Contains</span><span class=p>(</span><span class=nx>syn</span><span class=p>[</span><span class=nx>pat</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>1</span><span class=p>:]],</span> <span class=nx>words</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=p>{</span>
      <span class=k>if</span> <span class=nx>m</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nf>match</span><span class=p>(</span><span class=nx>pat</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=nx>words</span><span class=p>[</span><span class=mi>1</span><span class=p>:]);</span> <span class=nx>ok</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nb>append</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=nx>words</span><span class=p>[</span><span class=mi>0</span><span class=p>]},</span> <span class=nx>m</span><span class=o>...</span><span class=p>),</span> <span class=kc>true</span>
      <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>false</span>
  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>pat</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>!=</span> <span class=nx>words</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>{</span>
    <span class=c1>// Literal word in pattern does not match the text: no match!
</span><span class=c1></span>    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>false</span>
  <span class=p>}</span>
  <span class=c1>// Seems to match so far, compare the rest!
</span><span class=c1></span>  <span class=k>return</span> <span class=nf>match</span><span class=p>(</span><span class=nx>pat</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=nx>words</span><span class=p>[</span><span class=mi>1</span><span class=p>:])</span>
<span class=p>}</span>

<span class=c1>//
</span><span class=c1>// func split(s) []string { ... }
</span><span class=c1>//
</span><span class=c1>// match(split(&#34;&#34;), split(&#34;&#34;)) -&gt; true
</span><span class=c1>// match(split(&#34;foo&#34;), split(&#34;foo&#34;)) -&gt; true
</span><span class=c1>// match(split(&#34;foo&#34;), split(&#34;bar&#34;)) -&gt; false
</span><span class=c1>// match(split(&#34;foo&#34;), split(&#34;bar&#34;)) -&gt; false
</span><span class=c1>// match(split(&#34;a * b&#34;), split(&#34;a b c d e b&#34;)) -&gt; true (1)=&#34;b c d e&#34;
</span><span class=c1>// match(split(* a * b *), split(&#34;a b c&#34;)) -&gt; true (1)=&#34;&#34;, (2)=&#34;&#34;, (3)=&#34;c&#34;
</span></code></pre></div><p>After having all the knowledge encoded and these utility functions written we can now build the rest of Eliza&rsquo;s brain:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>respond</span><span class=p>(</span><span class=nx>q</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
  <span class=nx>q</span> <span class=p>=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>ToLower</span><span class=p>(</span><span class=nx>strings</span><span class=p>.</span><span class=nf>TrimSpace</span><span class=p>(</span><span class=nx>q</span><span class=p>))</span>
  <span class=c1>// Handle stop words
</span><span class=c1></span>  <span class=k>if</span> <span class=nx>slices</span><span class=p>.</span><span class=nf>Contains</span><span class=p>(</span><span class=nx>quit</span><span class=p>,</span> <span class=nx>q</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=s>&#34;&#34;</span>
  <span class=p>}</span>
  <span class=c1>// Split into words and preprocess
</span><span class=c1></span>  <span class=nx>words</span> <span class=o>:=</span> <span class=nf>replace</span><span class=p>(</span><span class=nx>strings</span><span class=p>.</span><span class=nf>Fields</span><span class=p>(</span><span class=nx>q</span><span class=p>),</span> <span class=nx>pre</span><span class=p>)</span>
  <span class=c1>// Find a keyword
</span><span class=c1></span>  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>k</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>keywords</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nx>slices</span><span class=p>.</span><span class=nf>Contains</span><span class=p>(</span><span class=nx>words</span><span class=p>,</span> <span class=nx>k</span><span class=p>.</span><span class=nx>Word</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>nextKey</span><span class=p>:</span>
      <span class=c1>// Find matching transformation rule
</span><span class=c1></span>      <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>d</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>k</span><span class=p>.</span><span class=nx>Decomp</span> <span class=p>{</span>
        <span class=k>if</span> <span class=nx>m</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nf>match</span><span class=p>(</span><span class=nx>strings</span><span class=p>.</span><span class=nf>Fields</span><span class=p>(</span><span class=nx>d</span><span class=p>.</span><span class=nx>Match</span><span class=p>),</span> <span class=nx>words</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
          <span class=c1>// Choose the next reassembly
</span><span class=c1></span>          <span class=nx>id</span> <span class=o>:=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;%s:%d&#34;</span><span class=p>,</span> <span class=nx>k</span><span class=p>.</span><span class=nx>Word</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
          <span class=nx>reply</span> <span class=o>:=</span> <span class=nx>d</span><span class=p>.</span><span class=nx>Reasmb</span><span class=p>[</span><span class=nx>index</span><span class=p>[</span><span class=nx>id</span><span class=p>]]</span>
          <span class=nx>index</span><span class=p>[</span><span class=nx>id</span><span class=p>]</span> <span class=p>=</span> <span class=p>(</span><span class=nx>index</span><span class=p>[</span><span class=nx>id</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=nb>len</span><span class=p>(</span><span class=nx>d</span><span class=p>.</span><span class=nx>Reasmb</span><span class=p>)</span>
          <span class=c1>// Handle &#34;goto&#34; rules
</span><span class=c1></span>          <span class=k>if</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>HasPrefix</span><span class=p>(</span><span class=nx>reply</span><span class=p>,</span> <span class=s>&#34;=&#34;</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>nextk</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>keywords</span> <span class=p>{</span>
              <span class=k>if</span> <span class=nx>nextk</span><span class=p>.</span><span class=nx>Word</span> <span class=o>==</span> <span class=nx>reply</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span> <span class=p>{</span>
                <span class=nx>k</span> <span class=p>=</span> <span class=nx>nextk</span>
                <span class=k>goto</span> <span class=nx>nextKey</span>
              <span class=p>}</span>
            <span class=p>}</span>
          <span class=p>}</span>
          <span class=c1>// Replace placeholders with phrases from user input
</span><span class=c1></span>          <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>s</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>m</span> <span class=p>{</span>
            <span class=nx>reply</span> <span class=p>=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>ReplaceAll</span><span class=p>(</span><span class=nx>reply</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;(%d)&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>),</span> <span class=nx>s</span><span class=p>)</span>
          <span class=p>}</span>
          <span class=c1>// Memorise the reply, if needed
</span><span class=c1></span>          <span class=k>if</span> <span class=nx>d</span><span class=p>.</span><span class=nx>Save</span> <span class=p>{</span>
            <span class=nx>mem</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>mem</span><span class=p>,</span> <span class=nx>reply</span><span class=p>)</span>
          <span class=p>}</span>
          <span class=k>return</span> <span class=nx>reply</span>
        <span class=p>}</span>
      <span class=p>}</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=c1>// Try to use memory before admitting that we don&#39;t have a clue what a user is talking about
</span><span class=c1></span>  <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>mem</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
    <span class=nx>reply</span> <span class=o>:=</span> <span class=nx>mem</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>mem</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
    <span class=nx>mem</span> <span class=p>=</span> <span class=nx>mem</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>mem</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
    <span class=k>return</span> <span class=nx>reply</span>
  <span class=p>}</span>
  <span class=nx>index</span><span class=p>[</span><span class=s>&#34;fallback&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=p>(</span><span class=nx>index</span><span class=p>[</span><span class=s>&#34;fallback&#34;</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=nb>len</span><span class=p>(</span><span class=nx>fallback</span><span class=p>)</span>
  <span class=k>return</span> <span class=nx>fallback</span><span class=p>[</span><span class=nx>index</span><span class=p>[</span><span class=s>&#34;fallback&#34;</span><span class=p>]]</span>
<span class=p>}</span>
</code></pre></div><p>Full sources are available <a href=https://github.com/zserge/aint/tree/main/eliza/>on GitHub</a> and you can play around with one of Eliza implementations <a href=https://www.masswerk.at/elizabot/>online</a> to take a Turing test yourself.</p><h1 id=ai>AI?</h1><p>Clearly, Eliza is not an AI. But it&rsquo;s been a huge success and caused many people treat it as a human. Being empathetic to its users and reflecting their language back to them, Eliza seems to be very understanding. Also it doesn&rsquo;t tend to reveal much about itself, making it harder to discover that it&rsquo;s merely a short list of hardcoded phrases. Silence is golden, indeed.</p><p>Next part: <a href=/posts/ai-markov/>Markov Chains</a></p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href=https://github.com/zserge>Github</a>, <a href=https://mastodon.social/@zserge>Mastodon</a>, <a href=https://twitter.com/zsergo>Twitter</a> or subscribe via <a href=/rss.xml>rss</a>.</p><p class=date style=text-align:right><em>Jan 01, 2024</em></p></div><footer><p>&copy;2012&ndash;2025 &#183;
<a class=h-card rel=me href=https://zserge.com/>Serge Zaitsev</a> &#183;
<a href=mailto:hello@zserge.com rel=me>hello@zserge.com</a> &#183;
<a href=https://mastodon.social/@zserge rel=me>@zserge@mastodon.social</a></p></footer><script>new Image().src='https://nullitics.com/file.gif?u='+encodeURI(location.href)+'&r='+encodeURI(document.referrer)+'&d='+screen.width</script><noscript><img src=https://nullitics.com/file.gif></noscript></body></html>