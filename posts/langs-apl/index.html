<!doctype html><html lang=en><head><meta charset=utf-8><title>Tiny Great Languages: APL</title><meta name=description content="Hey, life ← {⊃1 ⍵ ∨.∧ 3 4 = +/ +⌿ ¯1 0 1 ∘.⊖ ¯1 0 1 ⌽¨ ⊂⍵} and no, your browser encoding is correct, it's just 'A Game of Life' in APL."><meta name=author content="Serge Zaitsev"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=data:,><link rel="shortcut icon" sizes=32x32 href=/favicon.png><link rel="shortcut icon" sizes=192x192 href=/favicon-192x192.png><link rel=apple-touch-icon href=/favicon-192x192.png><link rel=alternate type=application/rss+xml title=RSS href=/rss.xml><link rel=canonical href=https://zserge.com/posts/langs-apl/><meta property="og:title" content="Tiny Great Languages: APL"><meta property="og:type" content="article"><meta property="og:url" content="https://zserge.com/posts/langs-apl/"><meta property="og:image" content="https://zserge.com/logo.png"><meta property="og:description" content="Hey, life ← {⊃1 ⍵ ∨.∧ 3 4 = +/ +⌿ ¯1 0 1 ∘.⊖ ¯1 0 1 ⌽¨ ⊂⍵} and no, your browser encoding is correct, it's just 'A Game of Life' in APL."><meta property="og:locale" content="en_US"><meta name=twitter:card content="Hey, life ← {⊃1 ⍵ ∨.∧ 3 4 = +/ +⌿ ¯1 0 1 ∘.⊖ ¯1 0 1 ⌽¨ ⊂⍵} and no, your browser encoding is correct, it's just 'A Game of Life' in APL."><meta name=twitter:site content="@zsergo"><style type=text/css>body{padding:1rem;margin:auto;max-width:46rem;font-family:pt serif,Georgia,Cambria,times new roman,Times,serif;line-height:1.5;font-size:20px;color:rgba(0,0,0,.87);-webkit-font-smoothing:antialiased;font-weight:300}nav{display:flex;justify-content:space-between;align-items:center;margin:1em 0 3em}nav ul,nav li{display:inline-block;list-style:none;margin:0 0 0 .5rem;padding:0}nav ul{margin-right:1rem}.logo{background-color:rgba(0,0,0,.87);color:#fff;min-width:48px;min-height:48px;font-size:28px;border-radius:2px;display:flex;justify-content:center;align-items:center}.logo:hover{color:#fff}h1,h2{line-height:1.2;font-family:roboto,system-ui,segoe ui,Helvetica,Arial,sans-serif;font-weight:400;text-transform:uppercase;margin:1.34em 0 0}h1{font-size:1.95em}h2{font-size:1.25em;border-bottom:2px solid rgba(0,0,0,.87)}h1 a{color:rgba(0,0,0,.87)}p{margin:.67em 0 1em}a{color:#0076df;text-decoration:none;word-break:break-word}a:hover{color:rgba(0,0,0,.87)}ul,ol{list-style-position:outside;margin-left:1em}img{display:block;margin-left:auto;margin-right:auto;max-width:100%}pre,code{font-family:roboto mono,SFMono-Regular,Consolas,liberation mono,Menlo,monospace;font-weight:400;font-size:18px;color:rgba(0,0,0,.6);background:#eee}code{padding:.2rem .4rem;font-size:14px;border-radius:2px}pre{overflow-y:auto;line-height:20px;border-radius:2px;padding:1em}pre code{font-size:14px;padding:0;color:rgba(0,0,0,.87)}footer{font-size:12px}@media(prefers-color-scheme:dark){.logo{color:#444;background-color:#e4e4e4}.logo:hover{color:#444}body,h1 a,h2 a{background-color:#444;color:#e4e4e4}pre,pre code{background:#333;color:#e4e4e4}h2{border-bottom:1px solid #e4e4e4}code{color:#aaa;background:#333}a{color:#e39777}a:hover{color:#e4e4e4}img{filter:grayscale(30%)}}.hl{display:block;width:100%;background-color:#ffc}.ow,.gh,.gp,.gs,.gu,.nt,.nn,.ne,.ni,.nc,.kr,.kn,.kd,.kc,.k{font-weight:700}.c,.ch,.cm,.c1,.cs,.ge{color:#777}</style><link rel="shortcut icon" href=/favicon.ico></head><body><header><nav><a class=logo href=/>Z</a><ul><li><a href=/about/>about</a></li><li><a href=/posts/>posts</a></li><li><a href=https://mastodon.social/@zserge rel=me>@me</a></li><li><a href=https://github.com/zserge rel=me>&lt;/>me</a></li></ul></nav></header><div id=content><h1>Tiny Great Languages: APL</h1><p><em>This is part 5 from series &ldquo;Tiny Great Languages&rdquo;.</em></p><ul><li><em>Final code is on <a href=https://github.com/zserge/tinylangs>Github</a>.</em></li><li><em><a href=/posts/langs-asm/>Part 1: Assembly</a>.</em></li><li><em><a href=/posts/langs-basic/>Part 2: BASIC</a>.</em></li><li><em><a href=/posts/langs-mouse/>Part 3: Forth/MOUSE</a>.</em></li><li><em><a href=/posts/langs-lisp/>Part 4: Lisp</a>.</em></li><li><em><a href=/posts/langs-apl/>Part 5: APL/K</a>.</em></li><li><em><a href=/posts/langs-pl0/>Part 6: PL/0</a>.</em></li></ul><p>This would be a controversial language, but it fits perfectly into the 50-lines-of-less code category. Let&rsquo;s talk about <a href>APL</a> family, and specifically &ndash; <a href>K</a>.</p><p>Created by <a href>Arthur Whitney</a> the language is known for its terse and cryptic syntax. But it fixes one &ldquo;issue&rdquo; with APL &ndash; K uses ASCII symbols. It may sound unsurprising, since most programming languages do that, but APL required a special keyboard since most of the language operators were mathematical symbols and Greek letters, such as <code>Pascal←{0~¨⍨a⌽⊃⌽∊¨0,¨¨a∘!¨a←⌽⍳⍵}</code>, which is a program in APL to render Pascal triangle.</p><p>Anyway, K, J, Q, A (these card names, aren&rsquo;t they?) and APL all belong to the family of array programming languages. In such languages the fundamental data type is a multi-dimensional array. Then there are &ldquo;nouns&rdquo;, such as numbers, matrices, variables etc. There are &ldquo;verbs&rdquo;, such as arithmetic operators or matrix functions. Finally, there are &ldquo;adverbs&rdquo; - combinators that apply verbs to nouns in a particular way.</p><h1 id=ksimple>k/simple</h1><p>I previously <a href=/posts/j>deciphered</a> another Arthur&rsquo;s Whitney code snippet that became a foundation of a J programming language. Recently I discovered an even simpler variant of it, well-commented and more useful to our case: build an array processing language that could calculate a factorial.</p><p><a href=https://github.com/kparc/ksimple/>K/simple</a> is a tiny educational K interpreter originally implemented in 25 lines of C code. And by C code I mean this:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>_i(u,10u&gt;x-48?x-48:26u&gt;x-97?r_(U[x-97]):0)
f(e,s z=x;c i=*z++;!*z?u(i):v(i)?x(e(z),Q(x)f[v(i)](x)):x(e(z+1),Q(x)58==*z?U[i-97]=r_(x):_(c f=v(*z);Qd(!f)F[f](u(i),x))))
int main(){c b[99];while(1)if(w((s)32),b[read(0,b,99)-1]=0,*b)58==b[1]?e(b):W(e(b));}
</code></pre></div><p>Somehow the style in which K/J are written is not the traditional C style, but rather APL style applied to C. Well, at kparc they even tried to write their own C-compatible compiler that would support their coding style - <a href=https://github.com/secti6n/kPARC/tree/master/kparc/b>https://github.com/secti6n/kPARC/tree/master/kparc/b</a>. This would allow to write:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>// Code in kparc/b
b[Ii]{h:#x;l:0;while(h&gt;l)$[y&gt;x[i:/l+h];l:i+1;h:i];l}
// Equivalent code in C, in APL style
I b(I*x,I y){I h=x[-1],i,l=0;while(h&gt;l)if(y&gt;x[i=l+h&gt;&gt;1])l=i+1;else h=i;R l;}
</code></pre></div><p>But back to k/simple. The language uses vectors as the only data type. It simplifies things a lot, as one wouldn&rsquo;t have to think about &ldquo;ranks&rdquo; (array dimensions) and in our case makes code easier to read as lists are native to Python.</p><p>The language supports 26 variables, a to z. Original language supported only single-digit numbers 0..9, but that&rsquo;s easy to overcome in Python.</p><p>Here are all the verbs that we need to support:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>┌───┬────────────────┬───────────────┐     
│   │  Monadic       │ Dyadic        │     
│───┼────────────────┼───────────────│     
│ + │  ⊘             │ 2+3→5         │     
│ - │ -3→-3          │ 7-3→4         │     
│ * │  ⊘             │ 3*4→12        │     
│ ! │ !3→[0,1,2]     │ 4!7→3 (7%3)   │     
│ # │ #4,5,6→3       │ 4#3→[3,3,3,3] │     
│ , │ ,3→[3]         │ 1,2,3→[1,2,3] │     
│ @ │ @4,5,6→4       │ a@4→a[4]      │     
│ = │  ⊘             │ 1=2→0         │     
│ ~ │  ⊘             │ 1~2→1         │     
│ &amp; │  ⊘             │ 3&amp;5→1         │     
│ | │ |4,5,6→[6,5,4] │ 3|5→7         │     
└────────────────────────────────────┘     
</code></pre></div><p>A monadic verb operates on a single noun, while dyadic operates on two nouns. You may think of unary and binary operators as an analogy in other programming languages.</p><p>Some of the verbs don&rsquo;t have a monadic variant, they will fail with &ldquo;rank&rdquo; error.</p><p>Dyadic verbs are as follows:</p><ul><li><code>+</code> adds two numbers or adds a number to a vector, or adds two vectors pairwise (they must be of the same length).</li><li><code>-</code>- subtracts two numbers or vectors, <code>a-b</code> is same as <code>a+(-b)</code>.</li><li><code>*</code> multiples two items, just &ldquo;add&rdquo; it can work or numbers and vectors.</li><li><code>!</code> is a modulo operator (note that it&rsquo;s right-to-left, like many things in APL and K). In monadic form <code>!</code> is a &ldquo;iota&rdquo; and returns a sequence of numbers from 0 to its argument.</li><li><code>#</code> repeats the right part a number of times specified in the left part. In monadic form it returns the length of a vector.</li><li><code>,</code> turns a number into a list or keeps adding elements to a list.</li><li><code>@</code> returns n-th element from a list, in monadic form it returns the first element.</li><li><code>=</code> and <code>~</code> are &ldquo;equals&rdquo; and &ldquo;not equals&rdquo; operators.</li><li><code>&</code> and <code>|</code> are bitwise and/or. In monadic form, <code>|</code> reverses the list.</li></ul><p>There are many more operators one can think of to manipulate the lists and there is plenty of ASCII symbols to assign them, but we keep it minimal and close to the original.</p><p>It would be easier to build the language from low-level operations to high-level eval. We can start by defining a primitive to tell atom from a vector (just like in Lisp), and a few monadic verbs:</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=c1>#is atom?</span>
<span class=k>def</span> <span class=nf>a</span><span class=p>(</span><span class=n>x</span><span class=p>):</span> <span class=k>return</span> <span class=nb>type</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>==</span> <span class=nb>int</span>

<span class=c1># a helper to return an error</span>
<span class=k>def</span> <span class=nf>err</span><span class=p>(</span><span class=n>msg</span><span class=o>=</span><span class=s2>&#34;nyi&#34;</span><span class=p>):</span> <span class=k>raise</span> <span class=n>f</span><span class=s2>&#34;error: {msg}&#34;</span>

<span class=c1># negate every element</span>
<span class=k>def</span> <span class=nf>sub</span><span class=p>(</span><span class=n>x</span><span class=p>):</span> <span class=k>return</span> <span class=o>-</span><span class=n>x</span> <span class=k>if</span> <span class=n>a</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=k>else</span> <span class=nb>list</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=k>lambda</span> <span class=n>xi</span><span class=p>:</span> <span class=o>-</span><span class=n>xi</span><span class=p>,</span> <span class=n>x</span><span class=p>))</span>
<span class=n>ou</span> 
<span class=c1># iota 0...x or error</span>
<span class=k>def</span> <span class=nf>iota</span><span class=p>(</span><span class=n>x</span><span class=p>):</span> <span class=k>return</span> <span class=nb>list</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>x</span><span class=p>))</span> <span class=k>if</span> <span class=n>a</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=k>else</span> <span class=n>err</span><span class=p>(</span><span class=s2>&#34;rank/iota&#34;</span><span class=p>)</span>

<span class=c1># len(x) or error</span>
<span class=k>def</span> <span class=nf>rank</span><span class=p>(</span><span class=n>x</span><span class=p>):</span> <span class=k>return</span> <span class=n>err</span><span class=p>(</span><span class=s2>&#34;rank/rank&#34;</span><span class=p>)</span> <span class=k>if</span> <span class=n>a</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=k>else</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>

<span class=c1># x -&gt; [x]</span>
<span class=k>def</span> <span class=nf>cat</span><span class=p>(</span><span class=n>x</span><span class=p>):</span> <span class=k>return</span> <span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=k>if</span> <span class=n>a</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=k>else</span> <span class=n>x</span>

<span class=c1># [abc] -&gt; [cba]</span>
<span class=k>def</span> <span class=nf>rev</span><span class=p>(</span><span class=n>x</span><span class=p>):</span> <span class=k>return</span> <span class=n>err</span><span class=p>(</span><span class=s2>&#34;rank/rev&#34;</span><span class=p>)</span> <span class=k>if</span> <span class=n>a</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=k>else</span> <span class=nb>list</span><span class=p>(</span><span class=nb>reversed</span><span class=p>(</span><span class=n>x</span><span class=p>))</span>
</code></pre></div><p>Dyadic verbs have a lot in common: they can act on two numbers, or on two vectors of the same length, or on a number and a vector. So we can move this logic into a helper function and only pass an operator to it to customise the behaviour:</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>dyad</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>op</span><span class=p>):</span>
    <span class=k>if</span> <span class=n>a</span><span class=p>(</span><span class=n>x</span><span class=p>):</span> <span class=k>return</span> <span class=n>op</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span> <span class=k>if</span> <span class=n>a</span><span class=p>(</span><span class=n>y</span><span class=p>)</span> <span class=k>else</span> <span class=n>dyad</span><span class=p>(</span><span class=n>y</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>op</span><span class=p>)</span>
    <span class=k>elif</span> <span class=n>a</span><span class=p>(</span><span class=n>y</span><span class=p>):</span> <span class=k>return</span> <span class=nb>list</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=k>lambda</span> <span class=n>n</span><span class=p>:</span> <span class=n>op</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>y</span><span class=p>),</span> <span class=n>x</span><span class=p>))</span>
    <span class=k>elif</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>!=</span> <span class=nb>len</span><span class=p>(</span><span class=n>y</span><span class=p>):</span> <span class=n>err</span><span class=p>(</span><span class=s2>&#34;rank/opx&#34;</span><span class=p>)</span>
    <span class=k>else</span><span class=p>:</span> <span class=k>return</span> <span class=nb>list</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=k>lambda</span> <span class=n>n</span><span class=p>:</span> <span class=n>op</span><span class=p>(</span><span class=n>n</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>n</span><span class=p>[</span><span class=mi>1</span><span class=p>]),</span> <span class=nb>zip</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)))</span>
</code></pre></div><p>Here two numbers are processed normally. Two lists are processed with a <code>map</code> and if they differ in length - it&rsquo;s an error. Two cases <code>(num, list)</code> and <code>(list, num)</code> are actually the same case for commutative operators such as <code>+</code> or <code>*</code>, so we can handle one of them only.</p><p>Now we can define some dyadic operators and the rest of the monads:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>def Add(x, y): return dyad(x, y, lambda x, y: x + y)
def And(x, y): return dyad(x, y, lambda x, y: x &amp; y)
def Or(x, y): return dyad(x, y, lambda x, y: x | y)
def Not(x, y): return dyad(x, y, lambda x, y: int(x != y))
def Eq(x, y): return dyad(x, y, lambda x, y: int(x == y))
def Prod(x, y): return dyad(x, y, lambda x, y: x * y)
def Sub(x, y): return Add(x, sub(y))
def Mod(x, y): return err(&#34;rank&#34;) if not a(x) else y % x if a(y) else list(map(lambda y: y % x, y))
def Take(x, y): return err(&#34;rank&#34;) if not a(x) else [y]*x if a(y) else y[:x]
def Cat(x, y): return cat(x) + cat(y)
def At(x, y): return x[y] if a(y) else list(map(lambda y: x[y], y))
def at(x): return At(x, 0)
</code></pre></div><p>Here Add, And, Or, not, Eq, Prod, Sub are all variants of a common dyadic operator logic. Mod only expects the left operator to be an atom and Take either repeats an atom N times (monadic) or fetches the last N elements from a list (dyadic). Cat is joining two lists. At fetches items from the list by index or a list of indices. Monadic &ldquo;at&rdquo; simply returns the first element.</p><p>Finally, we can implement two adverbs: scan ("/") and over (""). Scan is also known as a &ldquo;reduce&rdquo; function: it processes a list with some operator and accumulates the results into a single number. Over does the same but returns a list of intermediate results:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>+/3,7,11 -&gt; 3+7+11 -&gt; 21
+\3,7,11 -&gt; [3, 3+7, 3+7+11] -&gt; [3,10,21]
</code></pre></div><p>In Python they can be implemented as:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>def Over(op, x): return functools.reduce(lambda a, b: op(a, b), x)
def Scan(op, x): return list(itertools.accumulate(x, lambda a, b: op(a, b)))
</code></pre></div><p>And that&rsquo;s the end of our interpreter, we only have to write &ldquo;eval&rdquo; function to apply verbs to nouns and we&rsquo;re done:</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>e</span><span class=p>(</span><span class=n>s</span><span class=p>):</span>
    <span class=n>m</span> <span class=o>=</span> <span class=n>re</span><span class=o>.</span><span class=n>match</span><span class=p>(</span><span class=sa>r</span><span class=s2>&#34;(?P&lt;id&gt;[a-zA-Z]+)|(?P&lt;num&gt;[0-9]+)|(?P&lt;op&gt;[-+!#,@=~&amp;|*])&#34;</span><span class=p>,</span> <span class=n>s</span><span class=p>)</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=n>m</span><span class=p>:</span> <span class=n>err</span><span class=p>(</span><span class=n>f</span><span class=s2>&#34;syntax: {s}&#34;</span><span class=p>)</span>
    <span class=k>elif</span> <span class=n>m</span><span class=o>.</span><span class=n>lastgroup</span> <span class=o>==</span> <span class=s2>&#34;id&#34;</span> <span class=ow>or</span> <span class=n>m</span><span class=o>.</span><span class=n>lastgroup</span> <span class=o>==</span> <span class=s2>&#34;num&#34;</span><span class=p>:</span>
        <span class=n>x</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>s</span><span class=p>[:</span> <span class=n>m</span><span class=o>.</span><span class=n>end</span><span class=p>()])</span> <span class=k>if</span> <span class=n>m</span><span class=o>.</span><span class=n>lastgroup</span> <span class=o>==</span> <span class=s2>&#34;num&#34;</span> <span class=k>else</span> <span class=n>G</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>s</span><span class=p>[:</span> <span class=n>m</span><span class=o>.</span><span class=n>end</span><span class=p>()],</span> <span class=mi>0</span><span class=p>)</span>  <span class=c1># a noun</span>
        <span class=k>if</span> <span class=n>m</span><span class=o>.</span><span class=n>end</span><span class=p>()</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>):</span> <span class=k>return</span> <span class=n>x</span>  <span class=c1># if last in the string: return it</span>
        <span class=k>if</span> <span class=n>s</span><span class=p>[</span><span class=n>m</span><span class=o>.</span><span class=n>end</span><span class=p>()]</span> <span class=o>==</span> <span class=s2>&#34;:&#34;</span><span class=p>:</span>  <span class=c1># if assignment: recursively evaluate the rest and assign a global</span>
            <span class=n>x</span> <span class=o>=</span> <span class=n>e</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>m</span><span class=o>.</span><span class=n>end</span><span class=p>()</span> <span class=o>+</span> <span class=mi>1</span> <span class=p>:])</span>
            <span class=n>G</span><span class=p>[</span><span class=n>s</span><span class=p>[:</span> <span class=n>m</span><span class=o>.</span><span class=n>end</span><span class=p>()]]</span> <span class=o>=</span> <span class=n>x</span>
            <span class=k>return</span> <span class=n>x</span>
        <span class=k>return</span> <span class=n>V</span><span class=p>[</span><span class=n>s</span><span class=p>[</span><span class=n>m</span><span class=o>.</span><span class=n>end</span><span class=p>()]][</span><span class=mi>1</span><span class=p>](</span><span class=n>x</span><span class=p>,</span> <span class=n>e</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>m</span><span class=o>.</span><span class=n>end</span><span class=p>()</span> <span class=o>+</span> <span class=mi>1</span> <span class=p>:]))</span>  <span class=c1># otherwise: apply dyadic function</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=c1># If adverb (scan/over): evaluate the rest and apply verb to the resulting noun</span>
        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>1</span> <span class=ow>and</span> <span class=n>s</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=ow>in</span> <span class=s2>&#34;/</span><span class=se>\\</span><span class=s2>&#34;</span><span class=p>:</span> <span class=k>return</span> <span class=p>(</span><span class=n>Over</span> <span class=k>if</span> <span class=n>s</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=s2>&#34;/&#34;</span> <span class=k>else</span> <span class=n>Scan</span><span class=p>)(</span><span class=n>V</span><span class=p>[</span><span class=n>s</span><span class=p>[</span><span class=mi>0</span><span class=p>]][</span><span class=mi>1</span><span class=p>],</span> <span class=n>e</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=mi>2</span><span class=p>:]))</span>
        <span class=c1># Otherwise: apply a monadic verb to the rest of the expression</span>
        <span class=k>return</span> <span class=n>V</span><span class=p>[</span><span class=n>s</span><span class=p>[</span><span class=mi>0</span><span class=p>]][</span><span class=mi>0</span><span class=p>](</span><span class=n>e</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=mi>1</span><span class=p>:]))</span>

<span class=p>[</span><span class=k>print</span><span class=p>(</span><span class=n>e</span><span class=p>(</span><span class=n>line</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;;&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>strip</span><span class=p>()</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s2>&#34; &#34;</span><span class=p>,</span> <span class=s2>&#34;&#34;</span><span class=p>)))</span> <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>sys</span><span class=o>.</span><span class=n>stdin</span> <span class=k>if</span> <span class=n>line</span><span class=o>.</span><span class=n>strip</span><span class=p>()]</span>
</code></pre></div><p>Parsing happens left-to-right but evaluation happens right-to-left recursively (so <code>2*3+4</code> is actually 24 and not 10). A noun itself is its value, a noun followed by an operator is a dyadic function. A verb without a noun on the left is a monadic verb (unless it&rsquo;s followed by an adverb).</p><p>A special case here is assignment. A variable name followed by <code>:</code> assigns the result to a variable and passes the value on, so <code>1+a:3+4</code> assigns 7 to a and returns 8.</p><p>Now, the glory of array processing languages &ndash; can they calculate a factorial? Yes, in the shortest possible manner:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>*/1+!10    ; 10! =&gt; 3628800
</code></pre></div><p>It&rsquo;s only 7 bytes of code. <code>!10</code> returns a list of numbers 0 to 9. <code>1+!10</code> adds 1 to each of them resulting in a list [1, 2, &mldr;, 10]. Finally <code>*/1+!10</code> applies <code>*</code> verb with <code>scan</code> adverb and returns <code>1*2*3*...*10</code> which is a factorial of 10.</p><p>This language lacks many features such as loops or conditionals or even user input. But it processes arrays of numbers in such an elegant way what no other language can compete with it (well, maybe <code>numpy</code>).</p><p>If you are looking for an inspiration - there is J language with a great manual on how it&rsquo;s implemented, there is oK.js in a few lines of JavaScript, there is ngn/k which is a K interpreter in C and many others. There is even a K dialect for CHIP-8 in only 4 KB of bytecode!</p><p>In the next chapter we will address the most classical and proper (and very much educational) programming language, with procedures and conditionals and loops - Pascal!</p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href=https://github.com/zserge>Github</a>, <a href=https://mastodon.social/@zserge>Mastodon</a>, <a href=https://twitter.com/zsergo>Twitter</a> or subscribe via <a href=/rss.xml>rss</a>.</p><p class=date style=text-align:right><em>Sep 13, 2024</em></p><p>See also:
<a href=/posts/langs-basic/>Tiny Great Languages: BASIC</a> and <a href=/posts/>more</a>.</p></div><footer><p>&copy;2012&ndash;2024 &#183;
<a class=h-card rel=me href=https://zserge.com/>Serge Zaitsev</a> &#183;
<a href=mailto:hello@zserge.com rel=me>hello@zserge.com</a> &#183;
<a href=https://mastodon.social/@zserge rel=me>@zserge@mastodon.social</a></p></footer><script>new Image().src='https://nullitics.com/file.gif?u='+encodeURI(location.href)+'&r='+encodeURI(document.referrer)+'&d='+screen.width</script><noscript><img src=https://nullitics.com/file.gif></noscript></body></html>