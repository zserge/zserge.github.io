<!doctype html><html lang=en><head><meta charset=utf-8><title>What is Git made of?</title><meta name=description content="Build your own tiny Git from scratch to learn the internals of Git version control system."><meta name=author content="Serge Zaitsev"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=data:,><link rel="shortcut icon" sizes=32x32 href=/favicon.png><link rel="shortcut icon" sizes=192x192 href=/favicon-192x192.png><link rel=apple-touch-icon href=/favicon-192x192.png><link rel=alternate type=application/rss+xml title=RSS href=/rss.xml><link rel=canonical href=https://zserge.com/posts/git/><meta property="og:title" content="What is Git made of?"><meta property="og:type" content="article"><meta property="og:url" content="https://zserge.com/posts/git/"><meta property="og:image" content="https://zserge.com/logo.png"><meta property="og:description" content="Build your own tiny Git from scratch to learn the internals of Git version control system."><meta property="og:locale" content="en_US"><meta name=twitter:card content="Build your own tiny Git from scratch to learn the internals of Git version control system."><meta name=twitter:site content="@zsergo"><style type=text/css>body{padding:1rem;margin:auto;max-width:46rem;font-family:pt serif,Georgia,Cambria,times new roman,Times,serif;line-height:1.5;font-size:20px;color:rgba(0,0,0,.87);-webkit-font-smoothing:antialiased;font-weight:300}nav{display:flex;justify-content:space-between;align-items:center;margin:1em 0 3em}nav ul,nav li{display:inline-block;list-style:none;margin:0 0 0 .5rem;padding:0}nav ul{margin-right:1rem}.logo{background-color:rgba(0,0,0,.87);color:#fff;min-width:48px;min-height:48px;font-size:28px;border-radius:2px;display:flex;justify-content:center;align-items:center}.logo:hover{color:#fff}h1,h2{line-height:1.2;font-family:roboto,system-ui,segoe ui,Helvetica,Arial,sans-serif;font-weight:400;text-transform:uppercase;margin:1.34em 0 0}h1{font-size:1.95em}h2{font-size:1.25em;border-bottom:2px solid rgba(0,0,0,.87)}h1 a{color:rgba(0,0,0,.87)}p{margin:.67em 0 1em}a{color:#0076df;text-decoration:none;word-break:break-word}a:hover{color:rgba(0,0,0,.87)}ul,ol{list-style-position:outside;margin-left:1em}img{display:block;margin-left:auto;margin-right:auto;max-width:100%}pre,code{font-family:roboto mono,SFMono-Regular,Consolas,liberation mono,Menlo,monospace;font-weight:400;font-size:18px;color:rgba(0,0,0,.6);background:#eee}code{padding:.2rem .4rem;font-size:14px;border-radius:2px}pre{overflow-y:auto;line-height:20px;border-radius:2px;padding:1em}pre code{font-size:14px;padding:0;color:rgba(0,0,0,.87)}footer{font-size:12px}@media(prefers-color-scheme:dark){.logo{color:#444;background-color:#e4e4e4}.logo:hover{color:#444}body,h1 a,h2 a{background-color:#444;color:#e4e4e4}pre,pre code{background:#333;color:#e4e4e4}h2{border-bottom:1px solid #e4e4e4}code{color:#aaa;background:#333}a{color:#e39777}a:hover{color:#e4e4e4}img{filter:grayscale(30%)}}.hl{display:block;width:100%;background-color:#ffc}.ow,.gh,.gp,.gs,.gu,.nt,.nn,.ne,.ni,.nc,.kr,.kn,.kd,.kc,.k{font-weight:700}.c,.ch,.cm,.c1,.cs,.ge{color:#777}</style><link rel="shortcut icon" href=/favicon.ico></head><body><header><nav><a class=logo href=/>Z</a><ul><li><a href=/about/>about</a></li><li><a href=/posts/>posts</a></li><li><a href=https://mastodon.social/@zserge rel=me>@me</a></li><li><a href=https://github.com/zserge rel=me>&lt;/>me</a></li></ul></nav></header><div id=content><h1>What is Git made of?</h1><p>Git can be confusing. Git can be scary. Git CLI may be the least intuitive tool you have to use on a daily basis.</p><p>But also Git is a wonderfully simple and cleverly designed version control system that definitely deserves its popularity.</p><p>To prove this point I invite you to implement your own tiny Git that would be able to create a local repository, commit a single file to it, view commit logs and checkout a certain revision of that file.</p><p>It won&rsquo;t be more than a couple hundred lines of code, we&rsquo;ll try to keep things as simple as we can. Code examples would be in Go, but any other language is suitable for this tutorial, too.</p><h2 id=git-init>git init</h2><p>What turns an empty <em>directory</em> into an empty Git <em>repository</em>? You probably have noticed that Git stores all its internal data in a hidden directory <code>.git</code>. In fact, there are only a few special files/folder there that have to be created to let Git CLI treat it as a perfectly valid, empty repository:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ mkdir -p .git/objects/info .git/objects/pack .git/refs/heads .git/refs/tags
$ <span class=nb>echo</span> <span class=s2>&#34;ref: refs/heads/main&#34;</span> &gt; .git/HEAD
$ tree .git
.git
├── HEAD
├── objects
│   ├── info
│   └── pack
└── refs
    ├── heads
    └── tags
$ git symbolic-ref --short HEAD 
main
$ git log
fatal: your current branch <span class=s1>&#39;main&#39;</span> does not have any commits yet
</code></pre></div><p>By using a couple of shell commands we&rsquo;ve tricked Git into recognising our empty repository with a single <code>main</code> branch and no commits. But what is stored in these directories we&rsquo;ve created?</p><h2 id=objects>objects</h2><p>Almost everything in Git is stored as an object: every source file that you commit becomes a blob object, every commit itself is an object, tags are objects, too.</p><p>For example, we have committed a <code>file.txt</code> with the contents <code>hello\n</code> (6 bytes). This would create 3 objects: a <em>blob</em> (actual file contents), a <em>tree</em> (a list of file names and permissions), and a <em>commit</em> (a reference to the committed tree with some information about the committer, timestamp etc).</p><p>For every object Git stores its object type (&ldquo;blob&rdquo;, &ldquo;tree&rdquo; or &ldquo;commit&rdquo;) and a length in bytes. So our <code>hello\n</code> content would actually become <code>blob 6\0hello\n</code> object data. Additionally, Git uses compression to save disk space, so our object data will be compressed using zlib algorithm before being written to disk as a special file inside <code>.git/objects</code>.</p><h2 id=hashes>hashes</h2><p>Before we dive into the details of writing objects let&rsquo;s talk about Git hashes.</p><p>Every object is uniquely identified inside a Git repo by the SHA hash of its contents. Originally Git was using SHA-1 hashing algorithm, but recent versions of switched to SHA-256 to reduce hash collisions. However, SHA-1 is still widely used in many modern Git setups, and we&rsquo;ll be using it here as well.</p><p>Let&rsquo;s get back to our <code>file.txt</code> with <code>hello\n</code> content. After being compressed the contents of that blob object could look like this (using a simple python one-liner for zlib compression):</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ python3 -c <span class=s1>&#39;import sys,zlib; sys.stdout.buffer.write(zlib.compress(b&#34;blob 6\0hello\n&#34;,6))&#39;</span> <span class=p>|</span> hexdump -C
<span class=m>00000000</span>  <span class=m>78</span> 9c 4b ca c9 4f <span class=m>52</span> <span class=m>30</span>  <span class=m>63</span> c8 <span class=m>48</span> <span class=nb>cd</span> c9 c9 e7 <span class=m>02</span>  <span class=p>|</span>x.K..OR0c.H.....<span class=p>|</span>
<span class=m>00000010</span>  <span class=m>00</span> 1d c5 <span class=m>04</span> <span class=m>14</span>                                    <span class=p>|</span>.....<span class=p>|</span>
<span class=m>00000015</span>
</code></pre></div><p>In practice various zlib implementations may use different compression levels and settings, so resulting encoded content may look different. However the SHA-1 hash is calculated from the uncompressed raw data of an object and would always be the same:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>printf</span> <span class=s2>&#34;blob 6\0hello\n&#34;</span> <span class=p>|</span> sha1sum
ce013625030ba8dba906f756967f9e9ca394464a  -
</code></pre></div><p>Now let&rsquo;s compare that with Git CLI results in some dummy repo:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ mkdir hello
$ <span class=nb>cd</span> hello
$ git init
$ <span class=nb>echo</span> <span class=s2>&#34;hello&#34;</span> &gt; file.txt
$ git ci -m <span class=s1>&#39;initial commit&#39;</span> file.txt
$ git cat-file blob ce013625
hello
$ hexdump -C .git/objects/ce/013625030ba8dba906f756967f9e9ca394464a
<span class=m>00000000</span>  <span class=m>78</span> <span class=m>01</span> 4b ca c9 4f <span class=m>52</span> <span class=m>30</span>  <span class=m>63</span> c8 <span class=m>48</span> <span class=nb>cd</span> c9 c9 e7 <span class=m>02</span>  <span class=p>|</span>x.K..OR0c.H.....<span class=p>|</span>
<span class=m>00000010</span>  <span class=m>00</span> 1d c5 <span class=m>04</span> <span class=m>14</span>                                    <span class=p>|</span>.....<span class=p>|</span>
<span class=m>00000015</span>
</code></pre></div><p>Git uses a little optimisation when it stores objects: the first two digits of a hash become the subdirectory name and the rest becomes the file name where the compressed object data is stored. Let&rsquo;s reproduce this behaviour:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ mkdir -p .git/objects/3a <span class=c1># first two digits: &#34;3a&#34;</span>
$ <span class=nb>printf</span> <span class=s2>&#34;\x78\x9c\x4b\xca\xc9\x4f\x52\x30\x63\xc8\x48\xcd\xc9\xc9\xe7\x02\x00\x1d\xc5\x04\x14&#34;</span> <span class=se>\
</span><span class=se></span>  &gt; .git/objects/3a/3cca74450ee8a0245e7c564ac9e68f8233b1e8 <span class=c1># rest of the hash</span>
<span class=c1># Now, can Git CLI read our blob?</span>
$ git cat-file blob 3a3cca
hello
</code></pre></div><h2 id=writing-objects>Writing objects</h2><p>First of all let&rsquo;s introduce a <code>Git</code> &ldquo;class&rdquo; that would be a main entry point to work with out repo. We will also need a <code>Hash</code> type that would handle hash encoding/decoding:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>Git</span> <span class=kd>struct</span> <span class=p>{</span>
  <span class=nx>Dir</span>    <span class=kt>string</span> <span class=c1>// where `.git` is located
</span><span class=c1></span>  <span class=nx>Branch</span> <span class=kt>string</span> <span class=c1>// current branch, i.e. &#34;main&#34;
</span><span class=c1></span>  <span class=o>...</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>Hash</span> <span class=p>[]</span><span class=kt>byte</span> <span class=c1>// hashes in Git are presented in hexadecimal form
</span><span class=c1></span>
<span class=kd>func</span> <span class=nf>NewHash</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>Hash</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>dec</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>hex</span><span class=p>.</span><span class=nf>DecodeString</span><span class=p>(</span><span class=nx>strings</span><span class=p>.</span><span class=nf>TrimSpace</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>b</span><span class=p>)))</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=nf>Hash</span><span class=p>(</span><span class=nx>dec</span><span class=p>),</span> <span class=kc>nil</span>
<span class=p>}</span>
<span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=nx>Hash</span><span class=p>)</span> <span class=nf>String</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>hex</span><span class=p>.</span><span class=nf>EncodeToString</span><span class=p>(</span><span class=nx>h</span><span class=p>)</span> <span class=p>}</span>
</code></pre></div><p>Since all of the content in Git should be compressed &ndash; we can start implementing two utility functions that perform compression and decompression:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>zip</span><span class=p>(</span><span class=nx>content</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>b</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>bytes</span><span class=p>.</span><span class=nx>Buffer</span><span class=p>{}</span>
  <span class=nx>zw</span> <span class=o>:=</span> <span class=nx>zlib</span><span class=p>.</span><span class=nf>NewWriter</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>zw</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>content</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>zw</span><span class=p>.</span><span class=nf>Close</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=nx>b</span><span class=p>.</span><span class=nf>Bytes</span><span class=p>(),</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>unzip</span><span class=p>(</span><span class=nx>content</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>zw</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>zlib</span><span class=p>.</span><span class=nf>NewReader</span><span class=p>(</span><span class=nx>bytes</span><span class=p>.</span><span class=nf>NewBuffer</span><span class=p>(</span><span class=nx>content</span><span class=p>))</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>
  <span class=k>defer</span> <span class=nx>zw</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
  <span class=k>return</span> <span class=nx>io</span><span class=p>.</span><span class=nf>ReadAll</span><span class=p>(</span><span class=nx>zw</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>Now we can write a helper method that writes an object into the Git repo:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=c1>// this would be shorter than using fmt.Sprintf all the time, and we would need it a lot
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Git</span><span class=p>)</span> <span class=nf>fmt</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>args</span> <span class=o>...</span><span class=nx>any</span><span class=p>)</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>{</span> <span class=k>return</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=nx>format</span><span class=p>,</span> <span class=nx>args</span><span class=o>...</span><span class=p>))</span> <span class=p>}</span>
<span class=c1>// this writes an object of the given type with the given raw content into .git
</span><span class=c1>//   g := &amp;Git{Dir: &#34;.git&#34;, Branch: &#34;main&#34;}
</span><span class=c1>//   hash, err := g.write(&#34;blob&#34;, []byte(&#34;hello\n&#34;))
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Git</span><span class=p>)</span> <span class=nf>write</span><span class=p>(</span><span class=nx>objType</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>Hash</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>b</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>g</span><span class=p>.</span><span class=nf>fmt</span><span class=p>(</span><span class=s>&#34;%s %d\x00&#34;</span><span class=p>,</span> <span class=nx>objType</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>b</span><span class=p>)),</span> <span class=nx>b</span><span class=o>...</span><span class=p>)</span>
  <span class=nx>bz</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>zip</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>
  <span class=nx>sum</span> <span class=o>:=</span> <span class=nx>sha1</span><span class=p>.</span><span class=nf>Sum</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
  <span class=nx>hash</span> <span class=o>:=</span> <span class=nx>hex</span><span class=p>.</span><span class=nf>EncodeToString</span><span class=p>(</span><span class=nx>sum</span><span class=p>[:])</span>
  <span class=nx>dir</span> <span class=o>:=</span> <span class=nx>filepath</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nx>g</span><span class=p>.</span><span class=nx>Dir</span><span class=p>,</span> <span class=s>&#34;objects&#34;</span><span class=p>,</span> <span class=nx>hash</span><span class=p>[:</span><span class=mi>2</span><span class=p>])</span>
  <span class=nx>obj</span> <span class=o>:=</span> <span class=nx>filepath</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nx>dir</span><span class=p>,</span> <span class=nx>hash</span><span class=p>[</span><span class=mi>2</span><span class=p>:])</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>MkdirAll</span><span class=p>(</span><span class=nx>dir</span><span class=p>,</span> <span class=mo>0755</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=nx>sum</span><span class=p>[:],</span> <span class=nx>os</span><span class=p>.</span><span class=nf>WriteFile</span><span class=p>(</span><span class=nx>obj</span><span class=p>,</span> <span class=nx>bz</span><span class=p>,</span> <span class=mo>0644</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>If we call <code>g.write("blob", []byte("hello\n"))</code> - it would create a blob object with a checksum we&rsquo;ve calculated before, that we could later read by using <code>git cat-file blob &lt;hash></code>.</p><h2 id=initial-commit>Initial commit</h2><p>Time to go further and make our first commit into the new repository. We know that commits refer to a tree object, and tree objects refer to the blob objects they contain. To create a blob object seems to be fairly obvious:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Git</span><span class=p>)</span> <span class=nf>AddBlob</span><span class=p>(</span><span class=nx>data</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>Hash</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=nx>g</span><span class=p>.</span><span class=nf>write</span><span class=p>(</span><span class=s>&#34;blob&#34;</span><span class=p>,</span> <span class=nx>data</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>Tree data consists of the file permissions (like <code>100644</code> for normal files), file names and hashes of their content blob objects. This makes writing a tree object with a single file in it quite easy, too:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Git</span><span class=p>)</span> <span class=nf>AddTree</span><span class=p>(</span><span class=nx>filename</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>filedata</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>Hash</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>hash</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>g</span><span class=p>.</span><span class=nf>AddBlob</span><span class=p>(</span><span class=nx>filedata</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>
  <span class=nx>content</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>g</span><span class=p>.</span><span class=nf>fmt</span><span class=p>(</span><span class=s>&#34;100644 %s\x00&#34;</span><span class=p>,</span> <span class=nx>filename</span><span class=p>),</span> <span class=nx>hash</span><span class=o>...</span><span class=p>)</span>
  <span class=k>return</span> <span class=nx>g</span><span class=p>.</span><span class=nf>write</span><span class=p>(</span><span class=s>&#34;tree&#34;</span><span class=p>,</span> <span class=nx>content</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>Finally the last piece of a puzzle &ndash; the commit object. Commits usually have a tree reference (<code>tree &lt;sha-1 hash></code>), some author and committer information (<code>author John &lt;john@example.com> &lt;time> +0000</code>) and a commit message:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Git</span><span class=p>)</span> <span class=nf>AddCommit</span><span class=p>(</span><span class=nx>filename</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>data</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>parentHash</span> <span class=nx>Hash</span><span class=p>,</span> <span class=nx>msg</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>Hash</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>hash</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>g</span><span class=p>.</span><span class=nf>AddTree</span><span class=p>(</span><span class=nx>filename</span><span class=p>,</span> <span class=nx>data</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>
  <span class=nx>parent</span> <span class=o>:=</span> <span class=s>&#34;&#34;</span>
  <span class=k>if</span> <span class=nx>parentHash</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=nx>parent</span> <span class=p>=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;parent %s\n&#34;</span><span class=p>,</span> <span class=nx>parentHash</span><span class=p>.</span><span class=nf>String</span><span class=p>())</span>
  <span class=p>}</span>
  <span class=nx>t</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Unix</span><span class=p>()</span>
  <span class=nx>content</span> <span class=o>:=</span> <span class=nx>g</span><span class=p>.</span><span class=nf>fmt</span><span class=p>(</span><span class=s>&#34;tree %s\n%sauthor %s &lt;%s&gt; %d +0000\ncommitter %s &lt;%s&gt; %d +0000\n\n%s\n&#34;</span><span class=p>,</span>
    <span class=nx>hash</span><span class=p>,</span> <span class=nx>parent</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>User</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>Email</span><span class=p>,</span> <span class=nx>t</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>User</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>Email</span><span class=p>,</span> <span class=nx>t</span><span class=p>,</span> <span class=nx>msg</span><span class=p>)</span>
  <span class=nx>b</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>g</span><span class=p>.</span><span class=nf>write</span><span class=p>(</span><span class=s>&#34;commit&#34;</span><span class=p>,</span> <span class=nx>content</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nf>SetHead</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Git</span><span class=p>)</span> <span class=nf>SetHead</span><span class=p>(</span><span class=nx>h</span> <span class=nx>Hash</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>os</span><span class=p>.</span><span class=nf>WriteFile</span><span class=p>(</span><span class=nx>filepath</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nx>g</span><span class=p>.</span><span class=nx>Dir</span><span class=p>,</span> <span class=s>&#34;refs&#34;</span><span class=p>,</span> <span class=s>&#34;heads&#34;</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>Branch</span><span class=p>),</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nf>String</span><span class=p>()),</span> <span class=mo>0644</span><span class=p>)</span> <span class=p>}</span>
</code></pre></div><p>At the end of the <code>AddCommit</code> method we set the current branch head to the resulting commit hash.</p><p>Now if we try making a commit using this code - Git CLI would be able to show it in <code>git log</code>. But without a proper <code>parentHash</code> the next <code>AddCommit</code> call would overwrite the previous commit and there will always be only one commit in the history. Let&rsquo;s fix it.</p><h2 id=history>History</h2><p>Commits are chained. To create the second commit we should read the contents of <code>.git/refs/heads/main</code> and use that hash as a <code>parentHash</code> of the new commit:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Git</span><span class=p>)</span> <span class=nf>Head</span><span class=p>()</span> <span class=p>(</span><span class=nx>Hash</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>b</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>ReadFile</span><span class=p>(</span><span class=nx>filepath</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nx>g</span><span class=p>.</span><span class=nx>Dir</span><span class=p>,</span> <span class=s>&#34;refs&#34;</span><span class=p>,</span> <span class=s>&#34;heads&#34;</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>Branch</span><span class=p>))</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=nf>NewHash</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>Now this enables us to read the objects back and iterate from the most latest commit (tip of the branch) to the initial commit (with no parent). Of course, in a &ldquo;real&rdquo; Git repo commits may have more than one parent (i.e. after a merge) but we only consider here a very simple, single-branch single-file repository.</p><p>To read an object by the given hash we shall implement a reverse procedure to our <code>write()</code> method:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Git</span><span class=p>)</span> <span class=nf>read</span><span class=p>(</span><span class=nx>objType</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>hash</span> <span class=nx>Hash</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>h</span> <span class=o>:=</span> <span class=nx>hash</span><span class=p>.</span><span class=nf>String</span><span class=p>()</span>
  <span class=nx>dir</span> <span class=o>:=</span> <span class=nx>filepath</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nx>g</span><span class=p>.</span><span class=nx>Dir</span><span class=p>,</span> <span class=s>&#34;objects&#34;</span><span class=p>,</span> <span class=nx>h</span><span class=p>[:</span><span class=mi>2</span><span class=p>])</span>
  <span class=nx>obj</span> <span class=o>:=</span> <span class=nx>filepath</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nx>dir</span><span class=p>,</span> <span class=nx>h</span><span class=p>[</span><span class=mi>2</span><span class=p>:])</span>
  <span class=nx>b</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>ReadFile</span><span class=p>(</span><span class=nx>obj</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>
  <span class=nx>b</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nf>unzip</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>
  <span class=k>if</span> <span class=p>!</span><span class=nx>bytes</span><span class=p>.</span><span class=nf>HasPrefix</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>objType</span><span class=o>+</span><span class=s>&#34; &#34;</span><span class=p>))</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;not a %s object&#34;</span><span class=p>,</span> <span class=nx>objType</span><span class=p>)</span>
  <span class=p>}</span>
  <span class=nx>n</span> <span class=o>:=</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>IndexByte</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;invalid %s&#34;</span><span class=p>,</span> <span class=nx>objType</span><span class=p>)</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=nx>b</span><span class=p>[</span><span class=nx>n</span><span class=o>+</span><span class=mi>1</span><span class=p>:],</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div><p>We read a file from <code>.git/objects/&lt;first two chars>/&lt;rest of the hash></code>, check the object type, skip object length and return the remaining object content. What&rsquo;s left is to parse different content types to handle blobs, trees and commits.</p><p>Reading blobs is trivial, as there&rsquo;s nothing to parse:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Git</span><span class=p>)</span> <span class=nf>Blob</span><span class=p>(</span><span class=nx>hash</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>g</span><span class=p>.</span><span class=nf>read</span><span class=p>(</span><span class=s>&#34;blob&#34;</span><span class=p>,</span> <span class=nx>hash</span><span class=p>)</span> <span class=p>}</span>
</code></pre></div><p>Reading trees is slightly more complex, if we want to consider multiple files per tree:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>Tree</span> <span class=kd>struct</span> <span class=p>{</span>
  <span class=nx>Blobs</span> <span class=p>[]</span><span class=nx>Blob</span>
  <span class=nx>Hash</span>  <span class=nx>Hash</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>Blob</span> <span class=kd>struct</span> <span class=p>{</span>
  <span class=nx>Name</span> <span class=kt>string</span>
  <span class=nx>Hash</span> <span class=nx>Hash</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Git</span><span class=p>)</span> <span class=nf>Tree</span><span class=p>(</span><span class=nx>hash</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>tree</span> <span class=o>*</span><span class=nx>Tree</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>b</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>g</span><span class=p>.</span><span class=nf>read</span><span class=p>(</span><span class=s>&#34;tree&#34;</span><span class=p>,</span> <span class=nx>hash</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>
  <span class=nx>tree</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>Tree</span><span class=p>{</span><span class=nx>Hash</span><span class=p>:</span> <span class=nx>hash</span><span class=p>}</span>
  <span class=k>for</span> <span class=p>{</span>
    <span class=nx>parts</span> <span class=o>:=</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>SplitN</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{</span><span class=mi>0</span><span class=p>},</span> <span class=mi>2</span><span class=p>)</span>
    <span class=nx>fields</span> <span class=o>:=</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>SplitN</span><span class=p>(</span><span class=nx>parts</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{</span><span class=sc>&#39; &#39;</span><span class=p>},</span> <span class=mi>2</span><span class=p>)</span>
    <span class=nx>tree</span><span class=p>.</span><span class=nx>Blobs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>tree</span><span class=p>.</span><span class=nx>Blobs</span><span class=p>,</span> <span class=nx>Blob</span><span class=p>{</span><span class=nx>Name</span><span class=p>:</span> <span class=nb>string</span><span class=p>(</span><span class=nx>fields</span><span class=p>[</span><span class=mi>1</span><span class=p>]),</span> <span class=nx>Hash</span><span class=p>:</span> <span class=nx>parts</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>:</span><span class=mi>20</span><span class=p>]})</span>
    <span class=nx>b</span> <span class=p>=</span> <span class=nx>parts</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>20</span><span class=p>:]</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>parts</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span> <span class=o>==</span> <span class=mi>20</span> <span class=p>{</span>
      <span class=k>break</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=nx>tree</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div><p>Here we parse tree content in a loop and create blob records. We don&rsquo;t read blobs themselves, but only store their filenames and hashes.</p><p>What&rsquo;s left is to read the commit object by its hash and we would be able to implement <code>git log</code>!</p><p>Commit parser is very similar to the tree parser, it iterates over the content line by line, and depending on the line prefix fulfils the information about the commit:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>Commit</span> <span class=kd>struct</span> <span class=p>{</span>
  <span class=nx>Msg</span>    <span class=kt>string</span>
  <span class=nx>Parent</span> <span class=nx>Hash</span>
  <span class=nx>Tree</span>   <span class=nx>Hash</span>
  <span class=nx>Hash</span>   <span class=nx>Hash</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Git</span><span class=p>)</span> <span class=nf>Commit</span><span class=p>(</span><span class=nx>hash</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>ci</span> <span class=nx>Commit</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>ci</span> <span class=p>=</span> <span class=nx>Commit</span><span class=p>{</span><span class=nx>Hash</span><span class=p>:</span> <span class=nx>hash</span><span class=p>}</span>
  <span class=nx>b</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>g</span><span class=p>.</span><span class=nf>read</span><span class=p>(</span><span class=s>&#34;commit&#34;</span><span class=p>,</span> <span class=nx>hash</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>ci</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>
  <span class=nx>lines</span> <span class=o>:=</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{</span><span class=sc>&#39;\n&#39;</span><span class=p>})</span>
  <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>line</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>lines</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>line</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
      <span class=nx>ci</span><span class=p>.</span><span class=nx>Msg</span> <span class=p>=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>bytes</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nb>append</span><span class=p>(</span><span class=nx>lines</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>:]),</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{</span><span class=sc>&#39;\n&#39;</span><span class=p>}))</span>
      <span class=k>return</span> <span class=nx>ci</span><span class=p>,</span> <span class=kc>nil</span>
    <span class=p>}</span>
    <span class=nx>parts</span> <span class=o>:=</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>SplitN</span><span class=p>(</span><span class=nx>line</span><span class=p>,</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{</span><span class=sc>&#39; &#39;</span><span class=p>},</span> <span class=mi>2</span><span class=p>)</span>
    <span class=k>switch</span> <span class=nb>string</span><span class=p>(</span><span class=nx>parts</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=p>{</span>
    <span class=k>case</span> <span class=s>&#34;tree&#34;</span><span class=p>:</span>
      <span class=nx>ci</span><span class=p>.</span><span class=nx>Tree</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>hex</span><span class=p>.</span><span class=nf>DecodeString</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>parts</span><span class=p>[</span><span class=mi>1</span><span class=p>]))</span>
      <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>ci</span><span class=p>,</span> <span class=nx>err</span>
      <span class=p>}</span>
    <span class=k>case</span> <span class=s>&#34;parent&#34;</span><span class=p>:</span>
      <span class=nx>ci</span><span class=p>.</span><span class=nx>Parent</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>hex</span><span class=p>.</span><span class=nf>DecodeString</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>parts</span><span class=p>[</span><span class=mi>1</span><span class=p>]))</span>
      <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>ci</span><span class=p>,</span> <span class=nx>err</span>
      <span class=p>}</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=nx>ci</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div><p>Despite the simplicity this should work even with complex Git repos, but it will only follow a single branch and will ignore merges. To support multiple parent commits one would have to append parent hashes into the slice.</p><p>Another exercise to try is to implement tags. Tags are similar to <code>heads</code> (branches) &ndash; they are text files inside <code>.git/refs/tags</code> and contain hashes of the tag objects.</p><p>The storage mechanism we&rsquo;ve just implemented is known as &ldquo;loose objects&rdquo;. But there is an alternative, more efficient (and more complex) storage known as &ldquo;packfiles&rdquo;. Pack file is an archive of objects, similar to a tarball, where some objects can be stored as deltas (differences) from another object in the pack. Parsing packfiles is well documented and is not that difficult, but it&rsquo;s time to wrap up our Git story.</p><p>A full example of <code>nanogit.go</code> that implements <code>git init</code>, <code>git commit</code>, <code>git checkout</code>, and <code>git log</code> is available as a <a href=https://gist.github.com/zserge/549317af15bc3aead966df462a7d5216>gist</a>. In under ~300LOC it covers most of the fundamental Git concepts: references, objects, hashes and storage system. With a bit of effort it can be improved to support tags, multiple files, multiple parent commits and eventually end up being a small Git library for the programming language of your interest.</p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href=https://github.com/zserge>Github</a>, <a href=https://mastodon.social/@zserge>Mastodon</a>, <a href=https://twitter.com/zsergo>Twitter</a> or subscribe via <a href=/rss.xml>rss</a>.</p><p class=date style=text-align:right><em>Dec 04, 2022</em></p><p>See also:
<a href=/posts/post-apocalyptic-programming/>Post-apocalyptic programming</a> and <a href=/posts/>more</a>.</p></div><footer><p>&copy;2012&ndash;2024 &#183;
<a class=h-card rel=me href=https://zserge.com/>Serge Zaitsev</a> &#183;
<a href=mailto:hello@zserge.com rel=me>hello@zserge.com</a> &#183;
<a href=https://mastodon.social/@zserge rel=me>@zserge@mastodon.social</a></p></footer><script>new Image().src='https://nullitics.com/file.gif?u='+encodeURI(location.href)+'&r='+encodeURI(document.referrer)+'&d='+screen.width</script><noscript><img src=https://nullitics.com/file.gif></noscript></body></html>