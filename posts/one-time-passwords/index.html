<!doctype html><html lang=en><head><meta charset=utf-8><title>How do One-Time passwords work?</title><meta name=description content="Many of us use one-time passwords (OTP) regularly to log into different services. Most probably rely on Google Authenticator and similar tools. But what about building one by ourselves?"><meta name=author content="Serge Zaitsev"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=data:,><link rel="shortcut icon" sizes=32x32 href=/favicon.png><link rel="shortcut icon" sizes=192x192 href=/favicon-192x192.png><link rel=apple-touch-icon href=/favicon-192x192.png><link rel=alternate type=application/rss+xml title=RSS href=/rss.xml><link rel=canonical href=https://zserge.com/posts/one-time-passwords/><meta property="og:title" content="How do One-Time passwords work?"><meta property="og:type" content="article"><meta property="og:url" content="https://zserge.com/posts/one-time-passwords/"><meta property="og:image" content="https://zserge.com/logo.png"><meta property="og:description" content="Many of us use one-time passwords (OTP) regularly to log into different services. Most probably rely on Google Authenticator and similar tools. But what about building one by ourselves?"><meta property="og:locale" content="en_US"><meta name=twitter:card content="Many of us use one-time passwords (OTP) regularly to log into different services. Most probably rely on Google Authenticator and similar tools. But what about building one by ourselves?"><meta name=twitter:site content="@zsergo"><style type=text/css>body{padding:1rem;margin:auto;max-width:46rem;font-family:pt serif,Georgia,Cambria,times new roman,Times,serif;line-height:1.5;font-size:20px;color:rgba(0,0,0,.87);-webkit-font-smoothing:antialiased;font-weight:300}nav{display:flex;justify-content:space-between;align-items:center;margin:1em 0 3em}nav ul,nav li{display:inline-block;list-style:none;margin:0 0 0 .5rem;padding:0}nav ul{margin-right:1rem}.logo{background-color:rgba(0,0,0,.87);color:#fff;min-width:48px;min-height:48px;font-size:28px;border-radius:2px;display:flex;justify-content:center;align-items:center}.logo:hover{color:#fff}h1,h2{line-height:1.2;font-family:roboto,system-ui,segoe ui,Helvetica,Arial,sans-serif;font-weight:400;text-transform:uppercase;margin:1.34em 0 0}h1{font-size:1.95em}h2{font-size:1.25em;border-bottom:2px solid rgba(0,0,0,.87)}h1 a{color:rgba(0,0,0,.87)}p{margin:.67em 0 1em}a{color:#0076df;text-decoration:none;word-break:break-word}a:hover{color:rgba(0,0,0,.87)}ul,ol{list-style-position:outside;margin-left:1em}img{display:block;margin-left:auto;margin-right:auto;max-width:100%}pre,code{font-family:roboto mono,SFMono-Regular,Consolas,liberation mono,Menlo,monospace;font-weight:400;font-size:18px;color:rgba(0,0,0,.6);background:#eee}code{padding:.2rem .4rem;font-size:14px;border-radius:2px}pre{overflow-y:auto;line-height:20px;border-radius:2px;padding:1em}pre code{font-size:14px;padding:0;color:rgba(0,0,0,.87)}footer{font-size:12px}@media(prefers-color-scheme:dark){.logo{color:#444;background-color:#e4e4e4}.logo:hover{color:#444}body,h1 a,h2 a{background-color:#444;color:#e4e4e4}pre,pre code{background:#333;color:#e4e4e4}h2{border-bottom:1px solid #e4e4e4}code{color:#aaa;background:#333}a{color:#e39777}a:hover{color:#e4e4e4}img{filter:grayscale(30%)}}.hl{display:block;width:100%;background-color:#ffc}.ow,.gh,.gp,.gs,.gu,.nt,.nn,.ne,.ni,.nc,.kr,.kn,.kd,.kc,.k{font-weight:700}.c,.ch,.cm,.c1,.cs,.ge{color:#777}</style><link rel="shortcut icon" href=/favicon.ico></head><body><header><nav><a class=logo href=/>Z</a><ul><li><a href=/about/>about</a></li><li><a href=/posts/>posts</a></li><li><a href=https://twitter.com/zsergo rel=me>@me</a></li><li><a href=https://github.com/zserge rel=me>&lt;/>me</a></li></ul></nav></header><div id=content><h1>How do One-Time passwords work?</h1><p><a href=https://en.wikipedia.org/wiki/One-time_password>One-time passwords</a> (OTP) are short sequences of numbers that authenticate user for a single login. They are often used as an additional layer of security when the 2-factor authorisation is enabled.</p><p>A picture is worth a thousand words, here&rsquo;s what I&rsquo;m talking about:</p><p><img src=/images/otp/google.png alt="google auth"></p><p>How are these numbers generated and can we reproduce them?</p><h2 id=import-the-secret>Import the secret</h2><p>Let&rsquo;s take Google&rsquo;s 2-factor authorization as an example. It all starts with telling the authenticator app the secret key from your account. It is what you get when you scan the QR code during the 2FA setup for your Google account. And luckily there is an option for those who don&rsquo;t have a QR reader:</p><ol><li>Go to &ldquo;Google account&rdquo; - <a href=https://myaccount.google.com/>https://myaccount.google.com/</a></li><li>Go to the &ldquo;Security&rdquo; section in the menu on the left.</li><li>Select the &ldquo;2-Step Verification&rdquo; section.</li><li>You would probably be asked for the password.</li><li>Select the &ldquo;Change Phone&rdquo; item in the &ldquo;Authenticator App&rdquo; section.</li><li>A pop-up should appear asking if you have an Android or iOS device, choose any of those.</li><li>When the QR code appears - select the &ldquo;Can&rsquo;t scan it&rdquo; link below it.</li></ol><p>This should reveal the secret key used for your account OTP generator. Keep it secret.</p><p>If you wonder, the QR there contains a special link, such as <code>otpauth-migration://offline?data=...</code>. Data parameter is a base64-encoded Protobuf message, containing the hashing algorithm (SHA1/256/512 or MD5), number of digits in the OTP (six or eight), OTP type (time-based or HMAC-based), and the actual secret bytes.</p><p>We wouldn&rsquo;t bother with deciphering protobuf here, instead we would just copy the plain text secret that Google offers when you choose &ldquo;Can&rsquo;t scan it&rdquo;. Further on I will be referring to is as <code>$SECRET</code> environment variable.</p><h2 id=hmac-based-passwords>HMAC-based passwords</h2><p>HMAC-based one-time passwords are documented in <a href=https://tools.ietf.org/html/rfc4226>RFC 4226</a>. The algorithm takes as an input:</p><ul><li>A 64-bit counter, a moving factor. Some kind of value that increases over time and is synchronised between the authenticator and the server. Time is a good example, but we will talk about it further.</li><li>A unique shared secret, known for both, server and the authenticator.</li></ul><p>The algorithm itself does the following three steps. It generates a <a href=https://en.wikipedia.org/wiki/HMAC>HMAC-SHA-1</a> value, where secret is the key and counter is the message to be hashed using the key. Then it truncates the 20-byte hash string to a shorter value.</p><p>The truncation is rather uncomplicated, the last byte from the 20-byte string is taken, the lower 4 bits are considered the &ldquo;offset&rdquo;. This makes the offset to be always in the range from 0 to 15.</p><p>Then, the sequential 4 bytes starting from the offset are taken and converted into the 32-bit integer. Finally, the integer is printed as decimal, stripped down to the 6 digits, and that is the requested OTP.</p><p>Here&rsquo;s an example from the RFC to make it clear:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>-------------------------------------------------------------
| Byte Number                                               |
-------------------------------------------------------------
|00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|
-------------------------------------------------------------
| Byte Value                                                |
-------------------------------------------------------------
|1f|86|98|69|0e|02|ca|16|61|85|50|ef|7f|19|da|8e|94|5b|55|5a|
-------------------------------***********----------------++|
</code></pre></div><p>The message above is a HMAC-SHA-1 value, a string of 20 bytes. The last byte is 0x5a. The lower 4 bits are 0xa, or 10 in decimal. This means we should take the bytes 10, 11, 12 and 13 and read them as a 32-bit big-endian integer 0x50ef7f19. In decimal this integer would be 1357872921. The last 6 digits would be &ldquo;872921&rdquo; and that would be the OTP.</p><p>Not that complicated, huh?</p><h2 id=time-based-passwords>Time-based passwords</h2><p>The <a href=https://tools.ietf.org/html/rfc6238>RFC</a> that describes one-time passwords is very brief. It only mentions that the counter value from the HOTP algorithm above would be the time difference between &ldquo;now&rdquo; and some fixed start point (usually 1 Jan 1970), divided by some fixed time interval (often: 30 seconds).</p><p>The rest is handled by the algorithm above.</p><p>Knowing this, we can finally implement time-based OTP (here the code is in Go, but you may use the language of your choice):</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>totp</span><span class=p>(</span><span class=nx>secret</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// Counter is UNIX time in seconds, divided by interval of 30 seconds
</span><span class=c1></span>  <span class=nx>counter</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Unix</span><span class=p>()</span> <span class=o>/</span> <span class=mi>30</span>
  <span class=c1>// Decode Base-32 secret key
</span><span class=c1></span>  <span class=nx>key</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>64</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>base32</span><span class=p>.</span><span class=nx>StdEncoding</span><span class=p>.</span><span class=nf>Decode</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>ToUpper</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>secret</span><span class=p>)));</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=nx>err</span>
  <span class=p>}</span>
  <span class=c1>// Write counter as 8 bytes, big-endian
</span><span class=c1></span>  <span class=nx>b</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>8</span><span class=p>)</span>
  <span class=nx>binary</span><span class=p>.</span><span class=nx>BigEndian</span><span class=p>.</span><span class=nf>PutUint64</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=nb>uint64</span><span class=p>(</span><span class=nx>counter</span><span class=p>))</span>
  <span class=c1>// Calcular HMAC-SHA-1
</span><span class=c1></span>  <span class=nx>mac160</span> <span class=o>:=</span> <span class=nx>hmac</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>sha1</span><span class=p>.</span><span class=nx>New</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
  <span class=nx>mac160</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
  <span class=nx>b</span> <span class=p>=</span> <span class=nx>mac160</span><span class=p>.</span><span class=nf>Sum</span><span class=p>(</span><span class=kc>nil</span><span class=p>)</span>
  <span class=c1>// Find offset, lower 4 bits of the last byte
</span><span class=c1></span>  <span class=nx>offset</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&amp;</span> <span class=mh>0xf</span>
  <span class=c1>// Read 4 bytes from offset as 32-bit integer
</span><span class=c1></span>  <span class=nx>n</span> <span class=o>:=</span> <span class=nx>binary</span><span class=p>.</span><span class=nx>BigEndian</span><span class=p>.</span><span class=nf>Uint32</span><span class=p>(</span><span class=nx>b</span><span class=p>[</span><span class=nx>offset</span> <span class=p>:</span> <span class=nx>offset</span><span class=o>+</span><span class=mi>4</span><span class=p>])</span>
  <span class=c1>// Covert it to decimal
</span><span class=c1></span>  <span class=nx>s</span> <span class=o>:=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;%06d&#34;</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=nx>n</span> <span class=o>&amp;</span> <span class=mh>0x7fffffff</span><span class=p>))</span>
  <span class=c1>// Return last 6 digits
</span><span class=c1></span>  <span class=k>return</span> <span class=nx>s</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=o>-</span><span class=mi>6</span><span class=p>:],</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div><p>That&rsquo;s just 16 lines of code! If you call totp() function passing it your secret key &ndash; you should get a 6-digit number that matches the one in the Google Authenticator:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=nx>otp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>totp</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;SECRET&#34;</span><span class=p>)))</span>
<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
  <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
<span class=p>}</span>
<span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;OTP:&#34;</span><span class=p>,</span> <span class=nx>otp</span><span class=p>)</span>
</code></pre></div><p>Now you can use this little utility to get one-time passwords quickly without reaching for the phone.</p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href=https://github.com/zserge>Github</a>, <a href=https://twitter.com/zsergo>Twitter</a> or subscribe via <a href=/rss.xml>rss</a>.</p><p class=date style=text-align:right><em>Apr 28, 2021</em></p><p>See also:
<a href=/posts/agile-issue-tracker/>my minimalistic agile issue tracker</a> and <a href=/posts/>more</a>.</p></div><footer><p>&copy;2012&ndash;2022 &#183;
<a class=h-card rel=me href=https://zserge.com/>Serge Zaitsev</a> &#183;
<a href=mailto:hello@zserge.com rel=me>hello@zserge.com</a></p></footer><script>(function(e,t,n,i,s,a,c){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)};a=t.createElement(i);c=t.getElementsByTagName(i)[0];a.async=true;a.src=s;c.parentNode.insertBefore(a,c)})(window,document,"galite","script","https://cdn.jsdelivr.net/npm/ga-lite@2/dist/ga-lite.min.js");galite('create','UA-33644825-1','auto');galite('send','pageview');</script><script>new Image().src='https://nullitics.com/file.gif?u='+encodeURI(location.href)+'&r='+encodeURI(document.referrer)+'&d='+screen.width</script><noscript><img src=https://nullitics.com/file.gif></noscript></body></html>