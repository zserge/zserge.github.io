<!doctype html><html lang=en><head><meta charset=utf-8><title>How do ones and zeros sound?</title><meta name=description content="A brief introduction into 1-bit buzzer music, perhaps the most limiting and challenging genre of electronic computer music."><meta name=author content="Serge Zaitsev"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=data:,><link rel="shortcut icon" sizes=32x32 href=/favicon.png><link rel="shortcut icon" sizes=192x192 href=/favicon-192x192.png><link rel=apple-touch-icon href=/favicon-192x192.png><link rel=alternate type=application/rss+xml title=RSS href=/rss.xml><link rel=canonical href=https://zserge.com/posts/1-bit-music/><meta property="og:title" content="How do ones and zeros sound?"><meta property="og:type" content="article"><meta property="og:url" content="https://zserge.com/posts/1-bit-music/"><meta property="og:image" content="https://zserge.com/logo.png"><meta property="og:description" content="A brief introduction into 1-bit buzzer music, perhaps the most limiting and challenging genre of electronic computer music."><meta property="og:locale" content="en_US"><meta name=twitter:card content="A brief introduction into 1-bit buzzer music, perhaps the most limiting and challenging genre of electronic computer music."><meta name=twitter:site content="@zsergo"><style type=text/css>body{padding:1rem;margin:auto;max-width:46rem;font-family:pt serif,Georgia,Cambria,times new roman,Times,serif;line-height:1.5;font-size:20px;color:rgba(0,0,0,.87);-webkit-font-smoothing:antialiased;font-weight:300}nav{display:flex;justify-content:space-between;align-items:center;margin:1em 0 3em}nav ul,nav li{display:inline-block;list-style:none;margin:0 0 0 .5rem;padding:0}nav ul{margin-right:1rem}.logo{background-color:rgba(0,0,0,.87);color:#fff;min-width:48px;min-height:48px;font-size:28px;border-radius:2px;display:flex;justify-content:center;align-items:center}.logo:hover{color:#fff}h1,h2{line-height:1.2;font-family:roboto,system-ui,segoe ui,Helvetica,Arial,sans-serif;font-weight:400;text-transform:uppercase;margin:1.34em 0 0}h1{font-size:1.95em}h2{font-size:1.25em;border-bottom:2px solid rgba(0,0,0,.87)}h1 a{color:rgba(0,0,0,.87)}p{margin:.67em 0 1em}a{color:#0076df;text-decoration:none;word-break:break-word}a:hover{color:rgba(0,0,0,.87)}ul,ol{list-style-position:outside;margin-left:1em}img{display:block;margin-left:auto;margin-right:auto;max-width:100%}pre,code{font-family:roboto mono,SFMono-Regular,Consolas,liberation mono,Menlo,monospace;font-weight:400;font-size:18px;color:rgba(0,0,0,.6);background:#eee}code{padding:.2rem .4rem;font-size:14px;border-radius:2px}pre{overflow-y:auto;line-height:20px;border-radius:2px;padding:1em}pre code{font-size:14px;padding:0;color:rgba(0,0,0,.87)}footer{font-size:12px}@media(prefers-color-scheme:dark){.logo{color:#444;background-color:#e4e4e4}.logo:hover{color:#444}body,h1 a,h2 a{background-color:#444;color:#e4e4e4}pre,pre code{background:#333;color:#e4e4e4}h2{border-bottom:1px solid #e4e4e4}code{color:#aaa;background:#333}a{color:#e39777}a:hover{color:#e4e4e4}img{filter:grayscale(30%)}}.hl{display:block;width:100%;background-color:#ffc}.ow,.gh,.gp,.gs,.gu,.nt,.nn,.ne,.ni,.nc,.kr,.kn,.kd,.kc,.k{font-weight:700}.c,.ch,.cm,.c1,.cs,.ge{color:#777}</style><link rel="shortcut icon" href=/favicon.ico></head><body><header><nav><a class=logo href=/>Z</a><ul><li><a href=/about/>about</a></li><li><a href=/posts/>posts</a></li><li><a href=https://twitter.com/zsergo rel=me>@me</a></li><li><a href=https://github.com/zserge rel=me>&lt;/>me</a></li></ul></nav></header><div id=content><h1>How do ones and zeros sound?</h1><p>1-bit music is probably the most challenging electronic music genre, and definitely not the most mellifluous one. It originated long time ago when the early personal computers had a periodic timer and a connected piezo buzzer rather than a proper sound card with a speaker. We are now used to the electronic music with all the synthesizers, they are used in almost every song we hear. And we hear the songs only because the digital device converts a stream of digital signals into varying amplitude of a nicely constructed magnetic loudspeaker. Complex waveforms, precise pitches, unbelievable effects are all possible because of the high sample rate and sound channel depth.</p><p>1-bit music is nothing like that. You only have two levels of the output signal, and your playback device is incapable of producing much more - it&rsquo;s a thin membrane connected to a piezo crystal, that changes its shape when the voltage is applied to it. Unlike hi-fi magnetic speakers, piezo buzzers are only good at, well, buzzing. To make things worse, the sound circuit only allows configuring a timer to a given frequency flipping the signal level and producing a monotonic square wave.</p><p>Sometimes 1-but audio devices have a buzzer wired up to some GPIO lines and the CPU can control the speaker directly, but there are always certain tricks that can make the square wave music sound more interesting. We are surrounded by dozens of dull 1-bit audio devices, from smoke detectors and toys to greeting cards playing melody when you open them. And it turns out there is the whole subculture around producing 1-bit music.</p><h2 id=1-bit-sound-effects>1-bit sound effects</h2><p>The most obvious effect is to change the frequency of the signal a little bit. Sliding the pitch quickly up or down would create the effects similar to firing the arms in the old games. Oscillating the pitch up and down would create a vibtrato effect.</p><p>The other trick one can do is to change the duty cycle of the square wave. This somewhat affects the perceived volume of the signal and creates slightly different harmonics. People typically choose duty cycles of 50%, 25%, 12.5% etc, otherwise it will sound a bit &ldquo;off tune&rdquo;. Of course, duty cycle can also be modulated, like the pitch, using some low-frequency oscillator.</p><p>One can create different envelopes for both, pitch and duty cycle and that would define some new 1-bit &ldquo;instruments&rdquo;.</p><p><img src=/images/1-bit-sound.png alt="1-bit sound"></p><p>If you are curious how it sounds - you may watch this <a href="https://www.youtube.com/watch?v=fDE_n_OJ8Sc">YouTube video</a>, demonstrating a 1-bit AVR synthesizer. Beware, it may sound too harsh and loud.</p><h2 id=1-bit-composers-at-work>1-bit composers at work</h2><p>You might wonder why I talk about this weird music genre in a programming blog. Composing 1-bit music often starts with choosing (or programming your own) sound engine. It is very different from recording a song in Garage Band. The sound engine (or sound routine) is typically a loop implemented in assembly for the particular platform, that scans the patterns of notes (outer loop) and plays each of them according to the current &ldquo;instrument&rdquo; settings (inner loop).</p><p>The most common platforms for 1-bit music are ZX Spectrum, HP calculators, Arduino boards, old PCs running DOS and similar retro or low-end computers. Squeezing maximum functionality from the sound routine requires lots of skills and understanding of the platform.</p><p>Here I wanted to experiment with &ldquo;fake&rdquo; 1-bit music, for those who might be interested in the topic but not yet ready to buy a computer from the 80s on Ebay. That&rsquo;s why I built <a href=https://github.com/zserge/1bitr>1bitr</a>.</p><p><a href=https://github.com/zserge/1bitr>1bitr</a> is an ultimately minimal, hackable 1-bit music tracker that follows the UNIX way of doing one thing only. It has no UI, assuming that you use your text editor for coding both, music and the sound engine, if you like. It reads notes from stdin, meaning that you may use UNIX shell tools to combine patterns of notes or pre-process them. All it does next is parsing the columns of notes and additional data and passes it to the underlying sound engine. It comes with two very basic engines to start with, but you are free to build your own ones! It also does audio playback on Linux and macOS and supports exporting raw PCM data if you want to post-process your song in a DAW later (yes, 1-bit music does not have to be pure 1-bit, you can compose ambient 1-bit music, or enhance it with effects like filters or reverb).</p><h2 id=sound-engines>Sound engines</h2><p>The most simple sound engine that comes with 1bitr is &ldquo;Zero&rdquo; engine:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=kt>void</span> <span class=nf>engine_0</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>row</span><span class=p>,</span> <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>out</span><span class=p>)(</span><span class=kt>unsigned</span> <span class=kt>char</span><span class=p>))</span> <span class=p>{</span>
  <span class=k>static</span> <span class=kt>int</span> <span class=n>tempo</span> <span class=o>=</span> <span class=n>SAMPLE_RATE</span> <span class=o>/</span> <span class=mi>8</span><span class=p>;</span>
  <span class=kt>int</span> <span class=n>counter</span> <span class=o>=</span> <span class=n>row</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>value</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>row</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span> <span class=p>{</span>
    <span class=n>tempo</span> <span class=o>=</span> <span class=n>row</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=mi>100</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>timer</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>timer</span> <span class=o>&lt;</span> <span class=n>tempo</span><span class=p>;</span> <span class=n>timer</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>--</span><span class=n>counter</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>value</span> <span class=o>=</span> <span class=o>!</span><span class=n>value</span><span class=p>;</span>
      <span class=n>counter</span> <span class=o>=</span> <span class=n>row</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
    <span class=p>}</span>
    <span class=n>out</span><span class=p>(</span><span class=n>value</span><span class=p>);</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>This engine expects two columns of data, the first column would be a note and the second is tempo. If the note is zero - it means silence, if the tempo is zero - it remains unchanged. The engine uses a single counter variable, that starts with a note half-period and counts down until zero. Then it flips the audio output and resets the counter to its initial value to count down the second half of the note. This continues for as long as the note row should play, which is defined by the tempo variable.</p><p>Here is a sample input that plays a C major scale:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>; 0 (for Engine Zero, a single-channel PWM with adjustable tempo)
; Just a boring C-major scale played with Engine 0
C-4 70
D-4
E-4
F-4
G-4
A-4
B-4
C-5
</code></pre></div><p>Running in your shell <code>./1bitr &lt; SCALE.txt</code> should play some beeping sounds.</p><p>This engine has no effects, has a constant 50% duty cycle and is utterly dull and monophonic.</p><h2 id=1-bit-polyphony>1-bit polyphony</h2><p>Adding effects to a single channel is rather straightforward. Counter should count up to the full note period, audio signal is set to zero then the note starts (or the counter resets) and it should be set to one when the counter reaches the duty cycle threshold. Adjusting these two parameters (note period and duty cycle) with some hand-coded algorithms or envelopes would bring us a humble number of effects to make a richer sound.</p><p>But how to overcome the limits of a single audio channel? Well, there is an old trick. So old that is was used by Bach in a number of his works. If we quickly switch between the two interchanging notes - it will sound as if they are playing simultaneously. How quickly? As quickly, as possible. Since 1bitr runs on a modern CPU, the only restriction here is audio sample rate. At the sample rate of 44.1KHz we can toggle between the two audio channels 22050 times per second and it should not be noticeable to a human ear, which is capable of perceiving frequencies up to 20KHz.</p><p>This is what engine &ldquo;One&rdquo; does in 1bitr (check out the sources), but this is not the only way to achieve polyphony. One can use bitwise XOR to combine outputs of the two channels. Although it is much easier to implement, there is one significant limitation - if both channels play the same note they will become muted. But still, worth trying!</p><h2 id=1-bit-samples>1-bit samples</h2><p>Finally, what if you need drums? Drums are nothing like a buzzing oscillator. In 1-bit music there is a concept of &ldquo;interrupting click drums&rdquo;. It means: when a drum should be played &ndash; it plays a short burst of sound (imitating a drum) before the other audio channels do their playback. In other words, drums interrupt audio for a short period of time, and this pause remains unnoticeable to a human ear.</p><p>What kind of sound to play to make it drum-like? First option is white noise. If you randomly play 1 and 0 levels for a few milliseconds - it will sound like a lo-fi hi-hat drum. Kick drums can be simulated with a square wave oscillator, playing a low pitch note, sliding down for a short period of time.</p><p>But nothing stops you from using audio samples in 1-bit music. Of course, one can have pre-defined arrays of ones and zeros and stream them, but that is a waste of space, highly discouraged in 1-bit world. Alternative would be pulse width encoding. We know that in a 1-bit audio sample zero is always followed by one, which is followed by another zero at some point. So instead of having an array of ones and zeros we store an array of intervals between the first 0 and the following 1 and the following 0 and so on. In other words, <code>[23, 5, 3]</code> would mean play 0 for 23 cycles, play 1 for 5 cycles, play 0 for 3 cycles. This approach is used in engine &ldquo;One&rdquo;, as well as many other real-world 1-bit sound engines.</p><h2 id=theres-no-such-thing-as-two>There&rsquo;s no such thing as two</h2><p>I still think that there are more 1-bit musicians than 1-bit music listeners in the world, but the concept is nevertheless, very unusual and exciting. I can imagine using 1-bit instruments as part of the other, more traditional sound tracks. I also miss the days of the tracker music, when composing music for the compouter was simple and fun. If you came up with a new sound engine or some new 1-bit music - please open an issue or a pull request for <a href=https://github.com/zserge/1bitr>1bitr</a> project!</p><p>I shall mention that there are some &ldquo;real&rdquo; 1-bit trackers, such as Beepola or 1tracker, they have GUI and play music through the emulation of the real ZX spectrum sound engines. So if 1bitr is too limiting for your needs - feel free to try those.</p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href=https://github.com/zserge>Github</a>, <a href=https://twitter.com/zsergo>Twitter</a> or subscribe via <a href=/rss.xml>rss</a>.</p><p class=date style=text-align:right><em>Mar 14, 2021</em></p></div><footer><p>&copy;2012&ndash;2021 &#183;
<a href=https://zserge.com>Serge Zaitsev</a> &#183;
<a href=mailto:hello@zserge.com rel=me>hello@zserge.com</a></p></footer><script>(function(e,t,n,i,s,a,c){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)};a=t.createElement(i);c=t.getElementsByTagName(i)[0];a.async=true;a.src=s;c.parentNode.insertBefore(a,c)})(window,document,"galite","script","https://cdn.jsdelivr.net/npm/ga-lite@2/dist/ga-lite.min.js");galite('create','UA-33644825-1','auto');galite('send','pageview');</script><script>new Image().src='https://nullitics.com/file.gif?u='+encodeURI(location.href)+'&r='+encodeURI(document.referrer)+'&d='+screen.width</script><noscript><img src=https://nullitics.com/file.gif></noscript></body></html>