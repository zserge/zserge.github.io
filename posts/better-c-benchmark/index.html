<!doctype html><html lang=en><head><meta charset=utf-8><title>A "Better C" Benchmark</title><meta name=description content="An unusual benchmark for programming languages, designed to replace C. Unlike many other benchmarks, this one measures developer productivity and performance."><meta name=author content="Serge Zaitsev"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=data:,><link rel="shortcut icon" sizes=32x32 href=/favicon.png><link rel="shortcut icon" sizes=192x192 href=/favicon-192x192.png><link rel=apple-touch-icon href=/favicon-192x192.png><link rel=alternate type=application/rss+xml title=RSS href=/rss.xml><link rel=canonical href=https://zserge.com/posts/better-c-benchmark/><meta property="og:title" content="A &#34;Better C&#34; Benchmark"><meta property="og:type" content="article"><meta property="og:url" content="https://zserge.com/posts/better-c-benchmark/"><meta property="og:image" content="https://zserge.com/logo.png"><meta property="og:description" content="An unusual benchmark for programming languages, designed to replace C. Unlike many other benchmarks, this one measures developer productivity and performance."><meta property="og:locale" content="en_US"><meta name=twitter:card content="An unusual benchmark for programming languages, designed to replace C. Unlike many other benchmarks, this one measures developer productivity and performance."><meta name=twitter:site content="@zsergo"><style type=text/css>body{padding:1rem;margin:auto;max-width:46rem;font-family:pt serif,Georgia,Cambria,times new roman,Times,serif;line-height:1.5;font-size:20px;color:rgba(0,0,0,.87);-webkit-font-smoothing:antialiased;font-weight:300}nav{display:flex;justify-content:space-between;align-items:center;margin:1em 0 3em}nav ul,nav li{display:inline-block;list-style:none;margin:0 0 0 .5rem;padding:0}nav ul{margin-right:1rem}.logo{background-color:rgba(0,0,0,.87);color:#fff;min-width:48px;min-height:48px;font-size:28px;border-radius:2px;display:flex;justify-content:center;align-items:center}.logo:hover{color:#fff}h1,h2{line-height:1.2;font-family:roboto,system-ui,segoe ui,Helvetica,Arial,sans-serif;font-weight:400;text-transform:uppercase;margin:1.34em 0 0}h1{font-size:1.95em}h2{font-size:1.25em;border-bottom:2px solid rgba(0,0,0,.87)}h1 a{color:rgba(0,0,0,.87)}p{margin:.67em 0 1em}a{color:#0076df;text-decoration:none;word-break:break-word}a:hover{color:rgba(0,0,0,.87)}ul,ol{list-style-position:outside;margin-left:1em}img{display:block;margin-left:auto;margin-right:auto;max-width:100%}pre,code{font-family:roboto mono,SFMono-Regular,Consolas,liberation mono,Menlo,monospace;font-weight:400;font-size:18px;color:rgba(0,0,0,.6);background:#eee}code{padding:.2rem .4rem;font-size:14px;border-radius:2px}pre{overflow-y:auto;line-height:20px;border-radius:2px;padding:1em}pre code{font-size:14px;padding:0;color:rgba(0,0,0,.87)}footer{font-size:12px}@media(prefers-color-scheme:dark){.logo{color:#444;background-color:#e4e4e4}.logo:hover{color:#444}body,h1 a,h2 a{background-color:#444;color:#e4e4e4}pre,pre code{background:#333;color:#e4e4e4}h2{border-bottom:1px solid #e4e4e4}code{color:#aaa;background:#333}a{color:#e39777}a:hover{color:#e4e4e4}img{filter:grayscale(30%)}}.hl{display:block;width:100%;background-color:#ffc}.ow,.gh,.gp,.gs,.gu,.nt,.nn,.ne,.ni,.nc,.kr,.kn,.kd,.kc,.k{font-weight:700}.c,.ch,.cm,.c1,.cs,.ge{color:#777}</style><link rel="shortcut icon" href=/favicon.ico></head><body><header><nav><a class=logo href=/>Z</a><ul><li><a href=/about/>about</a></li><li><a href=/posts/>posts</a></li><li><a href=https://twitter.com/zsergo>@me</a></li><li><a href=https://github.com/zserge>&lt;/>me</a></li></ul></nav></header><div id=content><h1>A "Better C" Benchmark</h1><p>C is almost 50 years old. A great age for a bottle of wine, not so great for a programming language in the fast-moving industry. Over the past 10 years many new languages have emerged, with different flavours, all trying to become a C replacement to some extent.</p><p>When a new language becomes more or less popular &ndash; developers start writing benchmarks, showing how performant the software in this language is, how much CPU power and how much memory is uses, how big are the binaries and so on.</p><p>Here I would like to carry a little experiment in a different plane - UX of the programming languages, how <em>productive</em> the developer is when using this or that language, how easy it is to use them, what common frustrations there are, how people feel when they read the code. I believe that UX of the programming language is as important as their technical characteristics and it contributes a lot to a success of a language.</p><p>Warning: the rest of the post is very subjective.</p><h2 id=experiment>Experiment</h2><p>Let&rsquo;s write an app that scans all files recursively in the current directory and prints those lines in the files that match a given wildcard. Somethig like <code>ag</code> or <code>grep</code>, but using wildcards rather than regular expressions. Binary files should be ignored.</p><p>I find this problem to be a good exercise, because it shows how to implement a very simple wildcard matching algorithm (which works with pure data such as strings and numbers, no need to learn any libraries or APIs). This algorithm should pass a few very simple tests. Then it requires some very common, yet low-level APIs, such as scanning the directory recursively or reading files line by line. All parts of the problem are very simple, small and well-scoped. I assumed that such utility should be easy to implement in any language, even if there was no previous experience with it.</p><p>I wanted to test how &ldquo;friendly&rdquo; the language is to a regular &ldquo;write-compile-run-debug&rdquo; loop, how easy it is to write tests for the matching algorithm, how easy it is to find required APIs to work with the file system and basic I/O, how friendly is the compiler when pointing out errors, how &ldquo;intuitive&rdquo; is the language and so on.</p><p>My sample size was rather humble - just myself. But to avoid bias you are encouraged to do the same on your own (it should not take too long) and compare the results. After the utility has been written in differnt languages &ndash; I asked my peer developers (~20 people) to read it and tell what it does, what lines are unclear, what feels &ldquo;easier&rdquo; to read and to understand. These developers had no experience with either of the languages, but have been coding a lot in other languages, such as Java, C#, JavaScript, Kotlin, Swift etc.</p><p>The languages I tested here are C++, Go, Rust and Zig. The resulting programs I got are available at <a href=https://github.com/zserge/glob-grep,>https://github.com/zserge/glob-grep,</a> feel free to criticise.</p><h2 id=zig>Zig</h2><p>It all started because I wanted to see what kind of a language Zig is. I never used it, but heard some good feedback. With no previous experience I opened vim and started coding.</p><p>It took me ~1 hour to finish the program. The wildcard matching algorithm (which I knew before, and only had to implement in Zig) took me ~20 minutes. The rest was looking for the APIs to do the directory scanning and the file reading.</p><p>TLDR: great, intuitive little language, poor stdlib and docs.</p><p>What I liked: the language is surprisingly intuitive to a C coder. Feels very simple, the documentation about the <em>language</em> (but not the stdlib) is very clear and friendly.</p><p>Vim integration was also pretty good, for a young language (before I enabled vim plugin - I was annoyed with formatting errors, which are compiler errors).</p><p>I liked the error handling approach. Liked that test harness comes with the language. Even liked that strings are just the arrays of bytes, like in C.</p><p>My first reaction to carrying the allocator around was a shock, but in practice it was not even noticeable. It gives a feel of minimalism that the core of the language is so simple that it does not even use dynamic memory. Again, very close to C.</p><p>I had to read lot of the Zig compiler and stdlib sources while writing this, and the code was very clear and concise.</p><p>What I disliked: the stdlib documentation is terrible. Everything I learned about directory scanning and file I/O &ndash; I got from github search results, which are also pretty scarse.</p><p>Compiler messages are also far from being friendly, but to the one who is familiar with C it&rsquo;s not a big deal.</p><p>The lack of string handling routines in the stdlib was unexpected, to concatenate strings one has to do everything manually - allocate the buffer, put strings there. Or use formatter and an allocator to print both strings side by side and free the buffer afterwards. It&rsquo;s still very different from <code>s1+s2</code>.</p><p>Overall, the core language is simple and I enjoyed it, but the stdlib is even more limited than libc. I hope that this is just a sign of an early age of the language.</p><p>People who read the resulting Zig code actually mentioned that is was the one that made them realise what the program does. It is a bit verbose, but explicit, predictable and easy to understand. Not surprising, as the language was designed with readability in mind (no hidden control flow, no hidden allocations, no macros, no operator overloading, no metaprogramming etc).</p><h2 id=rust>Rust</h2><p>I had a few failed attempts to learn Rust. It took me over 2 hours to finish this program and I felt frustrated after I finished.</p><p>TLDR: complicated.</p><p>What I liked: the compiler messages are nice. The documentation to the language is also good. But that&rsquo;s probably it. At least I didn&rsquo;t have to fight too much with lifetime errors this time. The tooling around the language is modern and nice.</p><p>What I disliked: compiler messages are too verbose and take the whole screen. No, I don&rsquo;t want to run <code>rustc --explain</code> for every mistake. Please, don&rsquo;t punish me. Documentation is also sometimes too verbose. I mean, it&rsquo;s better have more docs than less, but having a TLDR version first would be even better. Same for stdlib, having a brief list of functions and what they do in one sentense would be easier to skim through as a reader. Having <code>&str</code>, <code>Str</code> and <code>[u8]</code> in obviously necessary, but surprises a newcomer.</p><p>Overall, coding in Rust feels like puzzle solving to me. Could be fun and exciting, especially when using Rust as a hobby language, but for most tasks I would rather prefer an &ldquo;ergonomic&rdquo; language that would be a barely noticeable tool.</p><p>People who read the resulting Rust code often raise at least a couple of &ldquo;wtf&rdquo; questions in process. They often complain the syntax is unclear and requires paying attention to details. Also, pattern matching is still an unfamiliar thing to the &ldquo;mainstream&rdquo; developers.</p><h2 id=go>Go</h2><p>This was cheating. I obviously had some previous experience with Go, but nevertheless I wanted to try it in this experiment. It took me ~15 minutes to make my complete &ldquo;glob&rdquo; utility work, just as I expected.</p><p>TLDR: productive, but opinionated.</p><p>What I liked: it feels very productive, docs are amazing to my taste - brief, but useful, one can immediately open the related stdlib function sources and investigate further. From the past experience, while writing the app I already envisoned how to make it multithreaded and boost the performance (simple fan-out).</p><p>What I disliked: too many things are under the hood (buffered I/O, GC). You don&rsquo;t feel like you are in control of everything (like in Zig). Too opinionated &ndash; this was the only language on the list that required me to create 3 separate files to make it work. It is still possible to make silly mistakes, like accidental variable shadowing, or using defer inside a loop.</p><p>People who read the resulting Go code found it clear, some wondered about the inline walker function (which does not have to be inline, they were right). Some wondered about the multiple assignment, i.e. <code>a, b = c, d</code>, which also was not needed there and made things more confusing. Ironically, if I was new to Go - I would have written even more straightforward Go code.</p><h2 id=c>C++</h2><p>Although I have some C experience, I am rather distant from the modern C++, so I decided to give it a try. It took me ~20 minutes to finish, and that was unexpected.</p><p>TLDR: good old &ldquo;frenemy&rdquo;.</p><p>What I liked: feels familiar, like meeting an old friend from the past. I enjoyed the docs, with lots of examles and good readability. I was surprised to see how powerful stdlib is nowadays. Support in text editors and IDEs is also very solid.</p><p>What I disliked: poor tooling &ndash; no build system, no test harness, no linter. We are used to it from the past, but that&rsquo;s not what a modern developer expects. Too powerful &ndash; for this very task C++ felt very productive, but I can imagive myself with a decision paralysis at some point when there are many different ways to do something and all are equally good (or bad).</p><p>People who read the resulting C++ code actually have read C or C++ in the past, at least as part of their university classes. Many complained about the use of <code>::</code>, so I should properly use the namespaces, I guess. Overall, as I don&rsquo;t have a &ldquo;taste&rdquo; in C++ code &ndash; I&rsquo;m sure it could have been written more clearly, but I also see how it could have been written much worse without even noticing.</p><h2 id=other-benchmarks>Other benchmarks</h2><p>All languages produced static executables, all about the same size (2..5MB). The smallest one was Zig, the largest one was Rust. All had about the same performance when scanning through my whole <code>/usr/include</code> file tree. That&rsquo;s why I wanted to highlight that technical characteristics are often not as important as the developer experience.</p><p>I would like to mention separately the build times. I ran the whole build+test+clean loop a hundred of times. Go comes the fastest (as expected), the other three are LLVM-based and are ~3x-4x slower.</p><p>What does it all mean? The results are not surprising and oftel follow the cliches about the languages: Go is simple to read, Rust is complicated, C++ is familiar, Zig looks promising but is too young to judge.</p><p>If I had to write a new service/utility that does not have to interact with C code a lot - I would definily choose Go. If I had to call some C or C++ libraries - I would stick to C++ (unfortunately). What place would Rust and Zig take in the modern programming world - only time will tell. I wish Zig had a better documentation to gain popularity before it becomes too niche and obscured. I will definitely pay a closer attention to it, so far it&rsquo;s the first real C replacement I&rsquo;ve met, especially when it comes to the low-level coding.</p><p>But of course, C is here to stay despite its age. There are still too many areas where C is the only real choice. And I&rsquo;m glad that C exists.</p><p>I hope you’ve enjoyed this article. You can follow – and contribute to – on <a href=https://github.com/zserge>Github</a>, <a href=https://twitter.com/zsergo>Twitter</a> or subscribe via <a href=/rss.xml>rss</a>.</p><p class=date style=text-align:right><em>Mar 18, 2021</em></p><p>See also:
<a href=/posts/etude-in-c/>Étude in C minor</a> and <a href=/posts/>more</a>.</p></div><footer><p>&copy;2012&ndash;2021 &#183;
<a href=https://zserge.com>Serge Zaitsev</a> &#183;
<a href=mailto:hello@zserge.com>hello@zserge.com</a></p></footer><script>(function(e,t,n,i,s,a,c){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)};a=t.createElement(i);c=t.getElementsByTagName(i)[0];a.async=true;a.src=s;c.parentNode.insertBefore(a,c)})(window,document,"galite","script","https://cdn.jsdelivr.net/npm/ga-lite@2/dist/ga-lite.min.js");galite('create','UA-33644825-1','auto');galite('send','pageview');</script><script>new Image().src='https://nullitics.com/file.gif?r='+encodeURI(document.referrer)+'&d='+screen.width</script><noscript><img src=https://nullitics.com/file.gif></noscript></body></html>